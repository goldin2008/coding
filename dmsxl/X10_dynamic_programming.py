"""
===================================================================================================
åŠ¨æ€è§„åˆ’æ–¹æ³•æ€»ç»“:

1. ç¡®å®šdpæ•°ç»„ (dp table) ä»¥åŠä¸‹æ ‡çš„å«ä¹‰
2. ç¡®å®šé€’æ¨å…¬å¼
3. dpæ•°ç»„å¦‚ä½•åˆå§‹åŒ–
4. ç¡®å®šéå†é¡ºåº
5. ä¸¾ä¾‹æ¨å¯¼dpæ•°ç»„

æ€»ç»“:
2D:ä»å°åˆ°å¤§éå†,å†…å¤–å±‚å¯æ¢
1D:åªæœ‰ä»å°åˆ°å¤§éå†,æ‰å¯èƒ½å†…å±‚å¤–å±‚å˜æ¢(æ¯”å¦‚å®Œå…¨èƒŒåŒ…)(å–å†³äºç»„åˆè¿˜æ˜¯æ’åˆ—,å¦‚æœæ˜¯æœ€å¤§æœ€å°å€¼,é‚£éƒ½å¯ä»¥)
å¦‚æœåŒ…å«ä»å¤§åˆ°å°éå†(æ¯”å¦‚01èƒŒåŒ…çš„1Dæ•°ç»„),é‚£åªèƒ½å…ˆç‰©å“åå®¹é‡,åŸå› æ˜¯éœ€è¦æ¯ä¸€è¡Œéƒ½å¡«å……ä»¥åæ‰èƒ½åˆ°ä¸‹ä¸€è¡Œ,è¿™æ ·ç”¨ä¸Šä¸€è¡Œçš„å…ƒç´ è®¡ç®—ä¸‹ä¸€è¡Œçš„å…ƒç´ 


ç‰¹æ€§	01èƒŒåŒ…	å®Œå…¨èƒŒåŒ…
ç‰©å“ä½¿ç”¨æ¬¡æ•°	æ¯ä¸ªç‰©å“åªèƒ½é€‰1æ¬¡	æ¯ä¸ªç‰©å“å¯æ— é™æ¬¡é€‰
å®¹é‡éå†æ–¹å‘	å¿…é¡»å€’åºï¼ˆä»å¤§åˆ°å°ï¼‰	å¿…é¡»æ­£åºï¼ˆä»å°åˆ°å¤§ï¼‰
å¾ªç¯é¡ºåºçµæ´»æ€§	âŒ ä¸å¯äº¤æ¢åµŒå¥—é¡ºåº	âœ… å¯äº¤æ¢ï¼ˆä½†æ¨èå…ˆç‰©å“ï¼‰
çŠ¶æ€è½¬ç§»ä¾èµ–	ä¾èµ–æœªé€‰å½“å‰ç‰©å“çš„çŠ¶æ€	ä¾èµ–å¯èƒ½å·²é€‰å½“å‰ç‰©å“çš„çŠ¶æ€
ç©ºé—´ä¼˜åŒ–å¿…è¦æ€§	å¿…é¡»å€’åºæ‰èƒ½ä¼˜åŒ–	æ­£åºå³æ”¯æŒä¼˜åŒ–

| ç±»å‹   | ç‰©å“ä½¿ç”¨è§„åˆ™               | å…¸å‹é—®é¢˜åœºæ™¯               |
|--------|---------------------------|---------------------------|
| 01èƒŒåŒ… | æ¯ä¸ªç‰©å“**æœ€å¤šé€‰ä¸€æ¬¡**     | é€‰/ä¸é€‰é—®é¢˜ï¼ˆå¦‚è£…æœ€å¤§ä»·å€¼ï¼‰|
| å®Œå…¨èƒŒåŒ… | æ¯ä¸ªç‰©å“**æ— é™æ¬¡ä½¿ç”¨**    | æ— é™å…‘æ¢é—®é¢˜ï¼ˆå¦‚ç¡¬å¸æ‰¾é›¶ï¼‰|

*** 01èƒŒåŒ…:
é€’å½’å…¬å¼: 2D dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
         1D dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
äºŒç»´æ•°ç»„, å¤–å±‚å†…å±‚éå†**å¯ä»¥äº¤æ¢**, éƒ½æ˜¯**ä»å°åˆ°å¤§**éå†
ä¸€ç»´æ•°ç»„, å¤–å±‚ç‰©å“**ä»å°åˆ°å¤§**, å†…å±‚å®¹é‡**ä»å¤§åˆ°å°**, ***éå†ä¸å¯äº¤æ¢***
ä¸€ç»´dpæ•°ç»„ä¸å¯ä»¥å…ˆéå†èƒŒåŒ…å®¹é‡åµŒå¥—éå†ç‰©å“,å› ä¸ºä¸€ç»´dpçš„å†™æ³•,èƒŒåŒ…å®¹é‡ä¸€å®šæ˜¯è¦å€’åºéå† (åŸå› ä¸Šé¢å·²ç»è®²äº†)
å¦‚æœéå†èƒŒåŒ…å®¹é‡æ”¾åœ¨ä¸Šä¸€å±‚,é‚£ä¹ˆæ¯ä¸ªdp[j]å°±åªä¼šæ”¾å…¥ä¸€ä¸ªç‰©å“,å³:èƒŒåŒ…é‡Œåªæ”¾å…¥äº†ä¸€ä¸ªç‰©å“ã€‚
å€’åºéå†çš„åŸå› æ˜¯,æœ¬è´¨ä¸Šè¿˜æ˜¯ä¸€ä¸ªå¯¹äºŒç»´æ•°ç»„çš„éå†,å¹¶ä¸”å³ä¸‹è§’çš„å€¼ä¾èµ–ä¸Šä¸€å±‚å·¦ä¸Šè§’çš„å€¼,å› æ­¤éœ€è¦ä¿è¯å·¦è¾¹çš„å€¼ä»ç„¶æ˜¯ä¸Šä¸€å±‚çš„,ä»å³å‘å·¦è¦†ç›–ã€‚
å¦‚æœå…ˆå®¹é‡å†ç‰©å“,æœ€å¤§å®¹é‡çš„æ—¶å€™,éå†æ¯ä¸€ä¸ªç‰©å“,è¿™ä¸ªæ—¶å€™ä¸ç¬¦åˆ1Dæ•°ç»„çš„å…³ç³»,å› ä¸º1Dæ•°ç»„æ˜¯ä¸€è¡Œä¸€è¡Œçš„,è¿™ä¸ªæ—¶å€™éå†æ¯ä¸ªç‰©å“,ä¸Šä¸€è¡Œè¿˜æ²¡æœ‰å®Œå…¨å®Œæˆ,
å½“éå†åˆ°ä¸‹ä¸€ä¸ªç‰©å“çš„æ—¶å€™,ä¸èƒ½ä¾é ä¸Šä¸€è¡Œç‰©å“çš„æ•°ç»„æ¥è®¡ç®—,å› ä¸ºéƒ½æ˜¯ä¾é ä¸Šä¸€è¡Œå·¦é¢çš„å…ƒç´ .è¿™æ—¶æ˜¯ä»æœ€å¤§å®¹é‡éå†,å·¦é¢å…ƒç´ è¿˜æ²¡æœ‰ready
ä¸€ç»´dpæ•°ç»„çš„èƒŒåŒ…åœ¨éå†é¡ºåºä¸Šå’ŒäºŒç»´dpæ•°ç»„å®ç°çš„01èƒŒåŒ…å…¶å®æ˜¯æœ‰å¾ˆå¤§å·®å¼‚çš„, éœ€è¦æ³¨æ„!

*** å®Œå…¨èƒŒåŒ…:
çº¯å®Œå…¨èƒŒåŒ…(æ±‚æ˜¯å¦èƒ½è£…æ»¡èƒŒåŒ…)
01èƒŒåŒ…å’Œå®Œå…¨èƒŒåŒ…å”¯ä¸€ä¸åŒå°±æ˜¯ä½“ç°åœ¨éå†é¡ºåºä¸Š,æˆ‘ä»¬çŸ¥é“01èƒŒåŒ…å†…åµŒçš„å¾ªç¯æ˜¯ä»å¤§åˆ°å°éå†(1D),ä¸ºäº†ä¿è¯æ¯ä¸ªç‰©å“ä»…è¢«æ·»åŠ ä¸€æ¬¡ã€‚
è€Œå®Œå…¨èƒŒåŒ…çš„ç‰©å“æ˜¯å¯ä»¥æ·»åŠ å¤šæ¬¡çš„,æ‰€ä»¥è¦ä»å°åˆ°å¤§å»éå†(1D)
(æ±‚æœ€å¤§ä»·å€¼)å…ˆéå†ç‰©å“, å†éå†èƒŒåŒ… ä¸ å…ˆéå†èƒŒåŒ…, å†éå†ç‰©å“éƒ½æ˜¯å¯ä»¥çš„, éƒ½è¦**ä»å°åˆ°å¤§**å»éå†
(æ±‚å‡ ç§æ–¹æ³•)éå†æ–¹å¼è·Ÿæ˜¯æ’åˆ—è¿˜æ˜¯ç»„åˆé—®é¢˜ç›¸å…³

æˆ‘ä»¬å…ˆæ¥çœ‹ å¤–å±‚forå¾ªç¯éå†ç‰©å“(é’±å¸),å†…å±‚foréå†èƒŒåŒ…(é‡‘é’±æ€»é¢)çš„æƒ…å†µã€‚
å‡è®¾:coins[0] = 1,coins[1] = 5ã€‚
é‚£ä¹ˆå°±æ˜¯å…ˆæŠŠ1åŠ å…¥è®¡ç®—,ç„¶åå†æŠŠ5åŠ å…¥è®¡ç®—,å¾—åˆ°çš„æ–¹æ³•æ•°é‡åªæœ‰{1, 5}è¿™ç§æƒ…å†µã€‚è€Œä¸ä¼šå‡ºç°{5, 1}çš„æƒ…å†µã€‚
æ‰€ä»¥è¿™ç§éå†é¡ºåºä¸­dp[j]é‡Œè®¡ç®—çš„æ˜¯ç»„åˆæ•°ï¼
å¦‚æœæŠŠä¸¤ä¸ªforäº¤æ¢é¡ºåº
èƒŒåŒ…å®¹é‡çš„æ¯ä¸€ä¸ªå€¼,éƒ½æ˜¯ç»è¿‡ 1 å’Œ 5 çš„è®¡ç®—,åŒ…å«äº†{1, 5} å’Œ {5, 1}ä¸¤ç§æƒ…å†µã€‚

*** 01èƒŒåŒ…,å®Œå…¨èƒŒåŒ…åŒºåˆ«
01èƒŒåŒ…ä¸­äºŒç»´dpæ•°ç»„çš„ä¸¤ä¸ªforéå†çš„å…ˆåå¾ªåºæ˜¯å¯ä»¥é¢ å€’äº†,ä¸€ç»´dpæ•°ç»„çš„ä¸¤ä¸ªforå¾ªç¯å…ˆåå¾ªåºä¸€å®šæ˜¯å…ˆéå†ç‰©å“,å†éå†èƒŒåŒ…å®¹é‡ã€‚
åœ¨å®Œå…¨èƒŒåŒ…ä¸­,å¯¹äºä¸€ç»´dpæ•°ç»„æ¥è¯´,å…¶å®ä¸¤ä¸ªforå¾ªç¯åµŒå¥—é¡ºåºæ˜¯æ— æ‰€è°“çš„!

éçº¯å®Œå…¨èƒŒåŒ…(æ±‚è£…æ»¡èƒŒåŒ…æœ‰å‡ ç§æ–¹æ³•)
ä¸€ç»´æ•°ç»„ (ç»„åˆé—®é¢˜), å¤–å±‚ç‰©å“, å†…å±‚å®¹é‡, éƒ½æ˜¯ä»å°åˆ°å¤§, éå†ä¸å¯äº¤æ¢
ä¸€ç»´æ•°ç»„ (æ’åˆ—é—®é¢˜), å¤–å±‚å®¹é‡, å†…å±‚ç‰©å“, éƒ½æ˜¯ä»å°åˆ°å¤§, éå†ä¸å¯äº¤æ¢
(DPæ–¹æ³•æ±‚çš„æ˜¯æ’åˆ—æ€»å’Œ, è€Œä¸”ä»…ä»…æ˜¯æ±‚æ’åˆ—æ€»å’Œçš„ä¸ªæ•°, å¹¶ä¸æ˜¯æŠŠæ‰€æœ‰çš„æ’åˆ—éƒ½åˆ—å‡ºæ¥ã€‚å¦‚æœè¦æŠŠæ’åˆ—éƒ½åˆ—å‡ºæ¥çš„è¯, åªèƒ½ä½¿ç”¨å›æº¯ç®—æ³•çˆ†æœã€‚)
å¦‚æœæ±‚æœ€å°æ•°, é‚£ä¹ˆä¸¤å±‚å¾ªç¯çš„å…ˆåé¡ºåºå°±æ— æ‰€è°“äº†

é€’æ¨å…¬å¼åœºæ™¯:
éƒ½ç”¨çš„1Dæ•°ç»„
é—®èƒŒåŒ…è£…æ»¡æœ€å¤§ä»·å€¼: dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
é—®èƒ½å¦èƒ½è£…æ»¡èƒŒåŒ…(æˆ–è€…æœ€å¤šè£…å¤šå°‘): dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])
é—®è£…æ»¡èƒŒåŒ…æ‰€æœ‰ç‰©å“çš„æœ€å°ä¸ªæ•°: dp[j] = min(dp[j], dp[j - coins[i]] + 1)
é—®è£…æ»¡èƒŒåŒ…æœ‰å‡ ç§æ–¹æ³•: dp[j] += dp[j - nums[i]]
===================================================================================================
"""

"""
01èƒŒåŒ…: æ¯ä»¶ç‰©å“åªèƒ½ç”¨ä¸€æ¬¡
å®Œå…¨èƒŒåŒ…: å•†å“å¯ä»¥é‡å¤å¤šæ¬¡æ”¾å…¥
å¤šé‡èƒŒåŒ…
åˆ†ç»„èƒŒåŒ…

å¯¹äºèƒŒåŒ…é—®é¢˜å…¶å®çŠ¶æ€éƒ½æ˜¯å¯ä»¥å‹ç¼©çš„ã€‚
åœ¨ä½¿ç”¨äºŒç»´æ•°ç»„çš„æ—¶å€™, é€’æ¨å…¬å¼: 
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
å…¶å®å¯ä»¥å‘ç°å¦‚æœæŠŠdp[i - 1]é‚£ä¸€å±‚æ‹·è´åˆ°dp[i]ä¸Š, è¡¨è¾¾å¼å®Œå…¨å¯ä»¥æ˜¯: 
dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);
ä¸å…¶æŠŠdp[i - 1]è¿™ä¸€å±‚æ‹·è´åˆ°dp[i]ä¸Š, ä¸å¦‚åªç”¨ä¸€ä¸ªä¸€ç»´æ•°ç»„äº†, åªç”¨dp[j](ä¸€ç»´æ•°ç»„, ä¹Ÿå¯ä»¥ç†è§£æ˜¯ä¸€ä¸ªæ»šåŠ¨æ•°ç»„)ã€‚
è¿™å°±æ˜¯æ»šåŠ¨æ•°ç»„çš„ç”±æ¥, éœ€è¦æ»¡è¶³çš„æ¡ä»¶æ˜¯ä¸Šä¸€å±‚å¯ä»¥é‡å¤åˆ©ç”¨, ç›´æ¥æ‹·è´åˆ°å½“å‰å±‚ã€‚
è¯»åˆ°è¿™é‡Œä¼°è®¡å¤§å®¶éƒ½å¿˜äº† dp[i][j]é‡Œçš„iå’Œjè¡¨è¾¾çš„æ˜¯ä»€ä¹ˆäº†, iæ˜¯ç‰©å“, jæ˜¯èƒŒåŒ…å®¹é‡ã€‚
dp[i][j] è¡¨ç¤ºä»ä¸‹æ ‡ä¸º[0-i]çš„ç‰©å“é‡Œä»»æ„å–, æ”¾è¿›å®¹é‡ä¸ºjçš„èƒŒåŒ…, ä»·å€¼æ€»å’Œæœ€å¤§æ˜¯å¤šå°‘

dp[j]å¯ä»¥é€šè¿‡dp[j - weight[i]]æ¨å¯¼å‡ºæ¥, dp[j - weight[i]]è¡¨ç¤ºå®¹é‡ä¸ºj - weight[i]çš„èƒŒåŒ…æ‰€èƒŒçš„æœ€å¤§ä»·å€¼ã€‚
dp[j - weight[i]] + value[i] è¡¨ç¤º å®¹é‡ä¸º (j - ç‰©å“ié‡é‡) çš„èƒŒåŒ… åŠ ä¸Š ç‰©å“içš„ä»·å€¼ã€‚
ä¹Ÿå°±æ˜¯å®¹é‡ä¸ºjçš„èƒŒåŒ…, æ”¾å…¥ç‰©å“iäº†ä¹‹åçš„ä»·å€¼å³:dp[j])ã€
æ­¤æ—¶dp[j]æœ‰ä¸¤ä¸ªé€‰æ‹©, ä¸€ä¸ªæ˜¯å–è‡ªå·±dp[j] ç›¸å½“äº äºŒç»´dpæ•°ç»„ä¸­çš„dp[i-1][j], å³ä¸æ”¾ç‰©å“i
ä¸€ä¸ªæ˜¯å–dp[j - weight[i]] + value[i], å³æ”¾ç‰©å“i, æŒ‡å®šæ˜¯å–æœ€å¤§çš„, æ¯•ç«Ÿæ˜¯æ±‚æœ€å¤§ä»·å€¼, 
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);


01èƒŒåŒ…äºŒç»´dpæ•°ç»„åœ¨éå†é¡ºåºä¸Š, å¤–å±‚éå†ç‰©å“ , å†…å±‚éå†èƒŒåŒ…å®¹é‡ å’Œ å¤–å±‚éå†èƒŒåŒ…å®¹é‡ , å†…å±‚éå†ç‰©å“ éƒ½æ˜¯å¯ä»¥çš„!
å¦‚æœä½¿ç”¨ä¸€ç»´dpæ•°ç»„, ç‰©å“éå†çš„forå¾ªç¯æ”¾åœ¨å¤–å±‚, éå†èƒŒåŒ…çš„forå¾ªç¯æ”¾åœ¨å†…å±‚, ä¸”å†…å±‚forå¾ªç¯å€’åºéå†!
***äºŒç»´dpéå†çš„æ—¶å€™, èƒŒåŒ…å®¹é‡æ˜¯ä»å°åˆ°å¤§, è€Œä¸€ç»´dpéå†çš„æ—¶å€™, èƒŒåŒ…æ˜¯ä»å¤§åˆ°å°ã€‚***

å…³é”®ç†è§£
æ­£åºéå†ï¼š
dp[j] ä¼šä¾èµ– å¯èƒ½å·²è¢«å½“å‰ç‰©å“æ›´æ–°è¿‡çš„ dp[j - weight[i]]ï¼Œå¯¼è‡´é‡å¤è®¡ç®—ã€‚
å€’åºéå†ï¼š
dp[j] ä¾èµ–çš„æ˜¯ æœªè¢«å½“å‰ç‰©å“æ±¡æŸ“çš„ä¸Šä¸€ä¸ªçŠ¶æ€ï¼Œä¿è¯ç‰©å“åªä½¿ç”¨ä¸€æ¬¡ã€‚

1. å€’åºéå†æ˜¯ä¸ºäº†ä¿è¯ç‰©å“iåªè¢«æ”¾å…¥ä¸€æ¬¡! ???
2. ä¸ºä»€ä¹ˆäºŒç»´dpæ•°ç»„å†çš„æ—¶å€™ä¸ç”¨å€’åºå‘¢?
å› ä¸ºå¯¹äºäºŒç»´dp, dp[i][j]éƒ½æ˜¯é€šè¿‡ä¸Šä¸€å±‚å³dp[i - 1][j]è®¡ç®—è€Œæ¥, æœ¬å±‚çš„dp[i][j]å¹¶ä¸ä¼šè¢«è¦†ç›–!
3. å¯¹äºä¸€ç»´dp, å€’åºéå†çš„åŸå› æ˜¯, æœ¬è´¨ä¸Šè¿˜æ˜¯ä¸€ä¸ªå¯¹äºŒç»´æ•°ç»„çš„éå†, å¹¶ä¸”å³ä¸‹è§’çš„å€¼ä¾èµ–ä¸Šä¸€å±‚å·¦ä¸Šè§’çš„å€¼, 
å› æ­¤éœ€è¦ä¿è¯å·¦è¾¹çš„å€¼ä»ç„¶æ˜¯ä¸Šä¸€å±‚çš„, ä»å³å‘å·¦è¦†ç›–ã€‚
4. ä¸¤ä¸ªåµŒå¥—forå¾ªç¯çš„é¡ºåº, ä»£ç ä¸­æ˜¯å…ˆéå†ç‰©å“åµŒå¥—éå†èƒŒåŒ…å®¹é‡, é‚£å¯ä¸å¯ä»¥å…ˆéå†èƒŒåŒ…å®¹é‡åµŒå¥—éå†ç‰©å“å‘¢ï¼Ÿä¸å¯ä»¥!
å› ä¸ºä¸€ç»´dpçš„å†™æ³•, èƒŒåŒ…å®¹é‡ä¸€å®šæ˜¯è¦å€’åºéå†, å¦‚æœéå†èƒŒåŒ…å®¹é‡æ”¾åœ¨ä¸Šä¸€å±‚, é‚£ä¹ˆæ¯ä¸ªdp[j]å°±åªä¼šæ”¾å…¥ä¸€ä¸ªç‰©å“, å³:èƒŒåŒ…é‡Œåªæ”¾å…¥äº†ä¸€ä¸ªç‰©å“ã€‚???
5. ä¸€ç»´dpæ•°ç»„åœ¨æ¨å¯¼çš„æ—¶å€™ä¸€å®šæ˜¯å–ä»·å€¼æœ€å¤§çš„æ•°, é¦–å…ˆdp[0]ä¸€å®šæ˜¯0
å¦‚æœé¢˜ç›®ç»™çš„ä»·å€¼éƒ½æ˜¯æ­£æ•´æ•°é‚£ä¹ˆé0ä¸‹æ ‡éƒ½åˆå§‹åŒ–ä¸º0å°±å¯ä»¥äº†, å¦‚æœé¢˜ç›®ç»™çš„ä»·å€¼æœ‰è´Ÿæ•°, é‚£ä¹ˆé0ä¸‹æ ‡å°±è¦åˆå§‹åŒ–ä¸ºè´Ÿæ— ç©·ã€‚
å› ä¸ºé‡é‡éƒ½ä¸ä¼šæ˜¯è´Ÿæ•°, æ‰€ä»¥dp[j]éƒ½åˆå§‹åŒ–ä¸º0å°±å¯ä»¥äº†, 
è¿™æ ·åœ¨é€’å½’å…¬å¼dp[j] = max(dp[j], dp[j - weights[i]] + values[i])ä¸­dp[j]æ‰ä¸ä¼šåˆå§‹å€¼æ‰€è¦†ç›–ã€‚
å› ä¸ºå¦‚æœæŒ‰ç…§äºŒç»´dpæ•°ç»„é‚£æ ·æ¥åˆå§‹åŒ–ç¬¬ä¸€row, é‚£ä¹ˆèƒŒåŒ…å®¹é‡ååºéå†çš„æ—¶å€™, åŒä¸€ä¸ªç‰©å“iä¼šæ”¾ä¸¤æ¬¡ã€‚
"""

"""
éå†é¡ºåº
#01èƒŒåŒ…
åœ¨åŠ¨æ€è§„åˆ’:å…³äº01èƒŒåŒ…é—®é¢˜,ä½ è¯¥äº†è§£è¿™äº›! ä¸­æˆ‘ä»¬è®²è§£äºŒç»´dpæ•°ç»„01èƒŒåŒ…å…ˆéå†ç‰©å“è¿˜æ˜¯å…ˆéå†èƒŒåŒ…éƒ½æ˜¯å¯ä»¥çš„,ä¸”ç¬¬äºŒå±‚forå¾ªç¯æ˜¯ä»å°åˆ°å¤§éå†ã€‚
å’ŒåŠ¨æ€è§„åˆ’:å…³äº01èƒŒåŒ…é—®é¢˜,ä½ è¯¥äº†è§£è¿™äº›!(æ»šåŠ¨æ•°ç»„) ä¸­,æˆ‘ä»¬è®²è§£ä¸€ç»´dpæ•°ç»„01èƒŒåŒ…åªèƒ½å…ˆéå†ç‰©å“å†éå†èƒŒåŒ…å®¹é‡,ä¸”ç¬¬äºŒå±‚forå¾ªç¯æ˜¯ä»å¤§åˆ°å°éå†ã€‚
ä¸€ç»´dpæ•°ç»„çš„èƒŒåŒ…åœ¨éå†é¡ºåºä¸Šå’ŒäºŒç»´dpæ•°ç»„å®ç°çš„01èƒŒåŒ…å…¶å®æ˜¯æœ‰å¾ˆå¤§å·®å¼‚çš„,å¤§å®¶éœ€è¦æ³¨æ„!

å®Œå…¨èƒŒåŒ…
è¯´å®Œ01èƒŒåŒ…,å†çœ‹çœ‹å®Œå…¨èƒŒåŒ…ã€‚

åœ¨åŠ¨æ€è§„åˆ’:å…³äºå®Œå…¨èƒŒåŒ…,ä½ è¯¥äº†è§£è¿™äº›! ä¸­,è®²è§£äº†çº¯å®Œå…¨èƒŒåŒ…çš„ä¸€ç»´dpæ•°ç»„å®ç°,å…ˆéå†ç‰©å“è¿˜æ˜¯å…ˆéå†èƒŒåŒ…éƒ½æ˜¯å¯ä»¥çš„,ä¸”ç¬¬äºŒå±‚forå¾ªç¯æ˜¯ä»å°åˆ°å¤§éå†ã€‚
ä½†æ˜¯ä»…ä»…æ˜¯çº¯å®Œå…¨èƒŒåŒ…çš„éå†é¡ºåºæ˜¯è¿™æ ·çš„,é¢˜ç›®ç¨æœ‰å˜åŒ–,ä¸¤ä¸ªforå¾ªç¯çš„å…ˆåé¡ºåºå°±ä¸ä¸€æ ·äº†ã€‚

å¦‚æœæ±‚ç»„åˆæ•°å°±æ˜¯å¤–å±‚forå¾ªç¯éå†ç‰©å“,å†…å±‚foréå†èƒŒåŒ…ã€‚
å¦‚æœæ±‚æ’åˆ—æ•°å°±æ˜¯å¤–å±‚foréå†èƒŒåŒ…,å†…å±‚forå¾ªç¯éå†ç‰©å“ã€‚

ç›¸å…³é¢˜ç›®å¦‚ä¸‹:
æ±‚ç»„åˆæ•°:åŠ¨æ€è§„åˆ’:518.é›¶é’±å…‘æ¢II
æ±‚æ’åˆ—æ•°:åŠ¨æ€è§„åˆ’:377. ç»„åˆæ€»å’Œ â…£ ã€åŠ¨æ€è§„åˆ’:70. çˆ¬æ¥¼æ¢¯è¿›é˜¶ç‰ˆ(å®Œå…¨èƒŒåŒ…)
å¦‚æœæ±‚æœ€å°æ•°,é‚£ä¹ˆä¸¤å±‚forå¾ªç¯çš„å…ˆåé¡ºåºå°±æ— æ‰€è°“äº†,ç›¸å…³é¢˜ç›®å¦‚ä¸‹:
æ±‚æœ€å°æ•°:åŠ¨æ€è§„åˆ’:322. é›¶é’±å…‘æ¢ ã€åŠ¨æ€è§„åˆ’:279.å®Œå…¨å¹³æ–¹æ•°
å¯¹äºèƒŒåŒ…é—®é¢˜,å…¶å®é€’æ¨å…¬å¼ç®—æ˜¯å®¹æ˜“çš„,éš¾æ˜¯éš¾åœ¨éå†é¡ºåºä¸Š,å¦‚æœæŠŠéå†é¡ºåºæé€,æ‰ç®—æ˜¯çœŸæ­£ç†è§£äº†ã€‚
"""

# èƒŒåŒ…é€’æ¨å…¬å¼
# é—®èƒ½å¦èƒ½è£…æ»¡èƒŒåŒ…(æˆ–è€…æœ€å¤šè£…å¤šå°‘):dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); ,å¯¹åº”é¢˜ç›®å¦‚ä¸‹:
# åŠ¨æ€è§„åˆ’:416.åˆ†å‰²ç­‰å’Œå­é›†
# åŠ¨æ€è§„åˆ’:1049.æœ€åä¸€å—çŸ³å¤´çš„é‡é‡ II

# é—®è£…æ»¡èƒŒåŒ…æœ‰å‡ ç§æ–¹æ³•:dp[j] += dp[j - nums[i]] ,å¯¹åº”é¢˜ç›®å¦‚ä¸‹:
# åŠ¨æ€è§„åˆ’:494.ç›®æ ‡å’Œ
# åŠ¨æ€è§„åˆ’:518. é›¶é’±å…‘æ¢ II
# åŠ¨æ€è§„åˆ’:377.ç»„åˆæ€»å’Œâ…£
# åŠ¨æ€è§„åˆ’:70. çˆ¬æ¥¼æ¢¯è¿›é˜¶ç‰ˆ(å®Œå…¨èƒŒåŒ…)

# é—®èƒŒåŒ…è£…æ»¡æœ€å¤§ä»·å€¼:dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); ,å¯¹åº”é¢˜ç›®å¦‚ä¸‹:
# åŠ¨æ€è§„åˆ’:474.ä¸€å’Œé›¶

# é—®è£…æ»¡èƒŒåŒ…æ‰€æœ‰ç‰©å“çš„æœ€å°ä¸ªæ•°:dp[j] = min(dp[j - coins[i]] + 1, dp[j]); ,å¯¹åº”é¢˜ç›®å¦‚ä¸‹:
# åŠ¨æ€è§„åˆ’:322.é›¶é’±å…‘æ¢
# åŠ¨æ€è§„åˆ’:279.å®Œå…¨å¹³æ–¹æ•°


# äºŒç»´dp
def test_2_wei_bag_problem1(bag_size, weight, value) -> int: 
	rows, cols = len(weight), bag_size + 1
	dp = [[0 for _ in range(cols)] for _ in range(rows)]
    
	# åˆå§‹åŒ–dpæ•°ç»„. 
	for i in range(rows): 
		dp[i][0] = 0
	first_item_weight, first_item_value = weight[0], value[0]
	for j in range(1, cols): 	
		if first_item_weight <= j: 
			dp[0][j] = first_item_value

	# æ›´æ–°dpæ•°ç»„: å…ˆéå†ç‰©å“, å†éå†èƒŒåŒ…. 
	for i in range(1, len(weight)): 
		cur_weight, cur_val = weight[i], value[i]
		for j in range(1, cols): 
			if cur_weight > j: # è¯´æ˜èƒŒåŒ…è£…ä¸ä¸‹å½“å‰ç‰©å“. 
				dp[i][j] = dp[i - 1][j] # æ‰€ä»¥ä¸è£…å½“å‰ç‰©å“. 
			else: 
				# å®šä¹‰dpæ•°ç»„: dp[i][j] å‰iä¸ªç‰©å“é‡Œ, æ”¾è¿›å®¹é‡ä¸ºjçš„èƒŒåŒ…, ä»·å€¼æ€»å’Œæœ€å¤§æ˜¯å¤šå°‘ã€‚
				dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - cur_weight]+ cur_val)

	print(dp)

if __name__ == "__main__": 
	bag_size = 4
	weight = [1, 3, 4]
	value = [15, 20, 30]
	test_2_wei_bag_problem1(bag_size, weight, value)

# ä¸€ç»´dp
def test_1_wei_bag_problem():
    weight = [1, 3, 4]
    value = [15, 20, 30]
    bag_weight = 4
    # åˆå§‹åŒ–: å…¨ä¸º0
    dp = [0] * (bag_weight + 1)

    # å…ˆéå†ç‰©å“, å†éå†èƒŒåŒ…å®¹é‡
    for i in range(len(weight)):
        for j in range(bag_weight, weight[i] - 1, -1):
            # é€’å½’å…¬å¼
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

    print(dp)

test_1_wei_bag_problem()


"""
01èƒŒåŒ…ä¸­äºŒç»´dpæ•°ç»„çš„ä¸¤ä¸ªforéå†çš„å…ˆåå¾ªåºæ˜¯å¯ä»¥é¢ å€’äº†, 
ä¸€ç»´dpæ•°ç»„çš„ä¸¤ä¸ªforå¾ªç¯å…ˆåå¾ªåºä¸€å®šæ˜¯å…ˆéå†ç‰©å“, å†éå†èƒŒåŒ…å®¹é‡ã€‚
åœ¨å®Œå…¨èƒŒåŒ…ä¸­, å¯¹äºä¸€ç»´dpæ•°ç»„æ¥è¯´, å…¶å®ä¸¤ä¸ªforå¾ªç¯åµŒå¥—é¡ºåºæ˜¯æ— æ‰€è°“çš„!
"""
# å…ˆéå†ç‰©å“, å†éå†èƒŒåŒ…
def test_complete_pack1():
    weight = [1, 3, 4]
    value = [15, 20, 30]
    bag_weight = 4

    dp = [0]*(bag_weight + 1)

    for i in range(len(weight)):
        for j in range(weight[i], bag_weight + 1):
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
    
    print(dp[bag_weight])

# å…ˆéå†èƒŒåŒ…, å†éå†ç‰©å“
def test_complete_pack2():
    weight = [1, 3, 4]
    value = [15, 20, 30]
    bag_weight = 4

    dp = [0]*(bag_weight + 1)

    for j in range(bag_weight + 1):
        for i in range(len(weight)):
            if j >= weight[i]: dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
    
    print(dp[bag_weight])

if __name__ == '__main__':
    test_complete_pack1()
    test_complete_pack2()


"""
ğŸ”¥ å…³é”®åŒºåˆ« (ä¸01èƒŒåŒ…å¯¹æ¯”)
é—®é¢˜ç±»å‹	å¾ªç¯é¡ºåºè¦æ±‚	å®¹é‡éå†æ–¹å‘	èƒ½å¦äº¤æ¢å¾ªç¯é¡ºåº
01èƒŒåŒ…	å¿…é¡»å¤–å±‚ç‰©å“ï¼Œå†…å±‚å®¹é‡	å€’åº	âŒ ä¸å¯äº¤æ¢
å®Œå…¨èƒŒåŒ…	å¤–å±‚ç‰©å“æˆ–å®¹é‡å‡å¯	æ­£åº	âœ… å¯äº¤æ¢


å®Œå…¨èƒŒåŒ…å’Œ01èƒŒåŒ…é—®é¢˜å”¯ä¸€ä¸åŒçš„åœ°æ–¹å°±æ˜¯, æ¯ç§ç‰©å“æœ‰æ— é™ä»¶ã€‚
æˆ‘ä»¬çŸ¥é“01èƒŒåŒ…å†…åµŒçš„å¾ªç¯æ˜¯ä»å¤§åˆ°å°éå†, ä¸ºäº†ä¿è¯æ¯ä¸ªç‰©å“ä»…è¢«æ·»åŠ ä¸€æ¬¡ã€‚
è€Œå®Œå…¨èƒŒåŒ…çš„ç‰©å“æ˜¯å¯ä»¥æ·»åŠ å¤šæ¬¡çš„, æ‰€ä»¥è¦ä»å°åˆ°å¤§å»éå†

å†…å¤–å¾ªç¯éå†é¡ºåº:
01èƒŒåŒ…ä¸­: äºŒç»´dpæ•°ç»„çš„ä¸¤ä¸ªforéå†çš„å…ˆåå¾ªåºæ˜¯å¯ä»¥é¢ å€’äº†, ä¸€ç»´dpæ•°ç»„çš„ä¸¤ä¸ªforå¾ªç¯å…ˆåå¾ªåºä¸€å®šæ˜¯å…ˆéå†ç‰©å“, å†éå†èƒŒåŒ…å®¹é‡ã€‚
å®Œå…¨èƒŒåŒ…ä¸­: å¯¹äºä¸€ç»´dpæ•°ç»„æ¥è¯´, å…¶å®ä¸¤ä¸ªforå¾ªç¯åµŒå¥—é¡ºåºæ˜¯æ— æ‰€è°“çš„!

å¦‚æœæ±‚ç»„åˆæ•°å°±æ˜¯å¤–å±‚forå¾ªç¯éå†ç‰©å“, å†…å±‚foréå†èƒŒåŒ…ã€‚
å¦‚æœæ±‚æ’åˆ—æ•°å°±æ˜¯å¤–å±‚foréå†èƒŒåŒ…, å†…å±‚forå¾ªç¯éå†ç‰©å“ã€‚

| é—®é¢˜ç±»å‹ | å¾ªç¯é¡ºåº                  | å…¸å‹åº”ç”¨åœºæ™¯              |
|----------|--------------------------|-------------------------|
| ç»„åˆæ•°   | **å¤–å±‚ç‰©å“** + å†…å±‚å®¹é‡  | ä¸è€ƒè™‘é¡ºåºçš„é€‰å–ï¼ˆå¦‚ç¡¬å¸ç»„åˆï¼‰ | å›ºå®šç‰©å“é¡ºåºï¼Œé¿å…é‡å¤è®¡ç®—ä¸åŒé¡ºåºçš„ç»„åˆ
| æ’åˆ—æ•°   | **å¤–å±‚å®¹é‡** + å†…å±‚ç‰©å“  | è€ƒè™‘é¡ºåºçš„æ’åˆ—ï¼ˆå¦‚çˆ¬æ¥¼æ¢¯æ–¹å¼ï¼‰ | å¯¹æ¯ä¸ªå®¹é‡ j, å°è¯•æ‰€æœ‰å¯èƒ½çš„ç‰©å“, è¿™æ ·ä¸åŒé¡ºåºçš„ç»„åˆä¼šè¢«åˆ†åˆ«è®¡ç®—

æœ¬è´¨åŸç†
å¾ªç¯é¡ºåº	è®¡ç®—é¡ºåº	æ•°å­¦æ„ä¹‰
ç‰©å“â†’å®¹é‡	æŒ‰ç‰©å“é¡ºåºé€æ­¥æ„å»ºç»„åˆ	ç»„åˆæ•°çš„åŠ¨æ€è§„åˆ’
å®¹é‡â†’ç‰©å“	å¯¹æ¯ä¸ªå®¹é‡è€ƒè™‘æ‰€æœ‰å¯èƒ½æ€§	æ’åˆ—æ•°çš„åŠ¨æ€è§„åˆ’

å¾ªç¯é¡ºåº	è®¡ç®—æ–¹å¼	æ˜¯å¦è€ƒè™‘é¡ºåº	é€‚ç”¨é—®é¢˜
å¤–å±‚ç‰©å“ â†’ å†…å±‚å®¹é‡	æŒ‰ç‰©å“é¡ºåºè®¡ç®—ç»„åˆ	âŒ ä¸è€ƒè™‘é¡ºåº	é›¶é’±å…‘æ¢ II (ç»„åˆæ•°)
å¤–å±‚å®¹é‡ â†’ å†…å±‚ç‰©å“	å¯¹æ¯ä¸ªå®¹é‡å°è¯•æ‰€æœ‰ç‰©å“	âœ… è€ƒè™‘é¡ºåº	ç»„åˆæ€»å’Œ IV (æ’åˆ—æ•°)


åˆå¯ä»¥å‡ºä¸€é“é¢è¯•é¢˜äº†, å°±æ˜¯çº¯å®Œå…¨èƒŒåŒ…, è¦æ±‚å…ˆç”¨äºŒç»´dpæ•°ç»„å®ç°, ç„¶åå†ç”¨ä¸€ç»´dpæ•°ç»„å®ç°, 
æœ€ååœ¨é—®, ä¸¤ä¸ªforå¾ªç¯çš„å…ˆåæ˜¯å¦å¯ä»¥é¢ å€’? ä¸ºä»€ä¹ˆ? è¿™ä¸ªç®€å•çš„å®Œå…¨èƒŒåŒ…é—®é¢˜, ä¼°è®¡å°±å¯ä»¥éš¾ä½ä¸å°‘å€™é€‰äººäº†ã€‚
"""
# 01èƒŒåŒ…çš„æ ¸å¿ƒä»£ç 
for (int i = 0; i < weight.size(); i++) { // éå†ç‰©å“
    for(int j = bagWeight; j >= weight[i]; j--) { // éå†èƒŒåŒ…å®¹é‡
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}

# å®Œå…¨èƒŒåŒ…æ ¸å¿ƒä»£ç 
# // å…ˆéå†ç‰©å“, å†éå†èƒŒåŒ…
for(int i = 0; i < weight.size(); i++) { // éå†ç‰©å“
    for(int j = weight[i]; j <= bagWeight ; j++) { // éå†èƒŒåŒ…å®¹é‡
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}

# // å…ˆéå†èƒŒåŒ…, å†éå†ç‰©å“
for(int j = 0; j <= bagWeight; j++) { // éå†èƒŒåŒ…å®¹é‡
    for(int i = 0; i < weight.size(); i++) { // éå†ç‰©å“
        if (j - weight[i] >= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
    cout << endl;
}

"""
åŠ¨æ€è§„åˆ’åŸºç¡€
å…³äºåŠ¨æ€è§„åˆ’,ä½ è¯¥äº†è§£è¿™äº›!
åŠ¨æ€è§„åˆ’:æ–æ³¢é‚£å¥‘æ•°
åŠ¨æ€è§„åˆ’:çˆ¬æ¥¼æ¢¯
åŠ¨æ€è§„åˆ’:ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯
åŠ¨æ€è§„åˆ’:ä¸åŒè·¯å¾„
åŠ¨æ€è§„åˆ’:ä¸åŒè·¯å¾„è¿˜ä¸å¤Ÿ,è¦æœ‰éšœç¢!
åŠ¨æ€è§„åˆ’:æ•´æ•°æ‹†åˆ†,ä½ è¦æ€ä¹ˆæ‹†ï¼Ÿ
åŠ¨æ€è§„åˆ’:ä¸åŒçš„äºŒå‰æœç´¢æ ‘

èƒŒåŒ…é—®é¢˜ç³»åˆ—
åŠ¨æ€è§„åˆ’:å…³äº01èƒŒåŒ…é—®é¢˜,ä½ è¯¥äº†è§£è¿™äº›!
åŠ¨æ€è§„åˆ’:å…³äº01èƒŒåŒ…é—®é¢˜,ä½ è¯¥äº†è§£è¿™äº›!(æ»šåŠ¨æ•°ç»„)
åŠ¨æ€è§„åˆ’:åˆ†å‰²ç­‰å’Œå­é›†å¯ä»¥ç”¨01èƒŒåŒ…!
åŠ¨æ€è§„åˆ’:æœ€åä¸€å—çŸ³å¤´çš„é‡é‡ II
åŠ¨æ€è§„åˆ’:ç›®æ ‡å’Œ!
åŠ¨æ€è§„åˆ’:ä¸€å’Œé›¶!
åŠ¨æ€è§„åˆ’:å…³äºå®Œå…¨èƒŒåŒ…,ä½ è¯¥äº†è§£è¿™äº›!
åŠ¨æ€è§„åˆ’:ç»™ä½ ä¸€äº›é›¶é’±,ä½ è¦æ€ä¹ˆå‡‘ï¼Ÿ
åŠ¨æ€è§„åˆ’:Carlç§°å®ƒä¸ºæ’åˆ—æ€»å’Œ!
åŠ¨æ€è§„åˆ’:ä»¥å‰æˆ‘æ²¡å¾—é€‰,ç°åœ¨æˆ‘é€‰æ‹©å†çˆ¬ä¸€æ¬¡!
åŠ¨æ€è§„åˆ’: ç»™æˆ‘ä¸ªæœºä¼š,æˆ‘å†å…‘æ¢ä¸€æ¬¡é›¶é’±
åŠ¨æ€è§„åˆ’:ä¸€æ ·çš„å¥—è·¯,å†æ±‚ä¸€æ¬¡å®Œå…¨å¹³æ–¹æ•°
åŠ¨æ€è§„åˆ’:å•è¯æ‹†åˆ†
åŠ¨æ€è§„åˆ’:å…³äºå¤šé‡èƒŒåŒ…,ä½ è¯¥äº†è§£è¿™äº›!
å¬è¯´èƒŒåŒ…é—®é¢˜å¾ˆéš¾ï¼Ÿ è¿™ç¯‡æ€»ç»“ç¯‡æ¥æ‹¯æ•‘ä½ äº†

æ‰“å®¶åŠ«èˆç³»åˆ—
åŠ¨æ€è§„åˆ’:å¼€å§‹æ‰“å®¶åŠ«èˆ!
åŠ¨æ€è§„åˆ’:ç»§ç»­æ‰“å®¶åŠ«èˆ!
åŠ¨æ€è§„åˆ’:è¿˜è¦æ‰“å®¶åŠ«èˆ!

è‚¡ç¥¨ç³»åˆ—
åŠ¨æ€è§„åˆ’:ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº
åŠ¨æ€è§„åˆ’:æœ¬å‘¨æˆ‘ä»¬éƒ½è®²äº†è¿™äº›(ç³»åˆ—å…­)
åŠ¨æ€è§„åˆ’:ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºII
åŠ¨æ€è§„åˆ’:ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºIII
åŠ¨æ€è§„åˆ’:ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºIV
åŠ¨æ€è§„åˆ’:æœ€ä½³ä¹°å–è‚¡ç¥¨æ—¶æœºå«å†·å†»æœŸ
åŠ¨æ€è§„åˆ’:æœ¬å‘¨æˆ‘ä»¬éƒ½è®²äº†è¿™äº›(ç³»åˆ—ä¸ƒ)
åŠ¨æ€è§„åˆ’:ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºå«æ‰‹ç»­è´¹
åŠ¨æ€è§„åˆ’:è‚¡ç¥¨ç³»åˆ—æ€»ç»“ç¯‡

å­åºåˆ—ç³»åˆ—
åŠ¨æ€è§„åˆ’:æœ€é•¿é€’å¢å­åºåˆ—
åŠ¨æ€è§„åˆ’:æœ€é•¿è¿ç»­é€’å¢åºåˆ—
åŠ¨æ€è§„åˆ’:æœ€é•¿é‡å¤å­æ•°ç»„
åŠ¨æ€è§„åˆ’:æœ€é•¿å…¬å…±å­åºåˆ—
åŠ¨æ€è§„åˆ’:ä¸ç›¸äº¤çš„çº¿
åŠ¨æ€è§„åˆ’:æœ€å¤§å­åºå’Œ
åŠ¨æ€è§„åˆ’:åˆ¤æ–­å­åºåˆ—
åŠ¨æ€è§„åˆ’:ä¸åŒçš„å­åºåˆ—
åŠ¨æ€è§„åˆ’:ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ é™¤æ“ä½œ
åŠ¨æ€è§„åˆ’:ç¼–è¾‘è·ç¦»
ä¸ºäº†ç»æ€ç¼–è¾‘è·ç¦»,æˆ‘åšäº†ä¸‰æ­¥é“ºå«,ä½ éƒ½çŸ¥é“ä¹ˆï¼Ÿ
åŠ¨æ€è§„åˆ’:å›æ–‡å­ä¸²
åŠ¨æ€è§„åˆ’:æœ€é•¿å›æ–‡å­åºåˆ—

å…³äºåŠ¨è§„,è¿˜æœ‰ æ ‘å½¢DP(æ‰“å®¶åŠ«èˆç³»åˆ—é‡Œæœ‰ä¸€é“),æ•°ä½DP,åŒºé—´DP ,æ¦‚ç‡å‹DP,åšå¼ˆå‹DP,çŠ¶æ€å‹ç¼©dpç­‰ç­‰ç­‰,è¿™äº›æˆ‘å°±ä¸å»åšè®²è§£äº†,é¢è¯•ä¸­å‡ºç°çš„æ¦‚ç‡éå¸¸ä½ã€‚
èƒ½æŠŠæœ¬ç¯‡ä¸­åˆ—ä¸¾çš„é¢˜ç›®éƒ½ç ”ç©¶é€šé€çš„è¯,ä½ çš„åŠ¨è§„æ°´å¹³å°±å·²ç»éå¸¸é«˜äº†ã€‚ å¯¹ä»˜é¢è¯•å·²ç»è¶³å¤Ÿ!
"""


"""
5.æœ€é•¿å›æ–‡å­ä¸² Longest Palindromic Substring
132. åˆ†å‰²å›æ–‡ä¸² II
300.æœ€é•¿ä¸Šå‡å­åºåˆ—
647. å›æ–‡å­ä¸²
673.æœ€é•¿é€’å¢å­åºåˆ—çš„ä¸ªæ•°

115. Distinct Subsequences
392. Is Subsequence
516. Longest Palindromic Subsequence
673. Number of Longest Increasing Subsequence
2407. Longest Increasing Subsequence II

53. Maximum Subarray
209. Minimum Size Subarray Sum
560. Subarray Sum Equals K

1162. As Far from Land as Possible

72. Edit Distance
"""

"""
1. åŠ¨æ€è§„åˆ’åŸºç¡€ (7)

å…³äºåŠ¨æ€è§„åˆ’,ä½ è¯¥äº†è§£è¿™äº›!
åŠ¨æ€è§„åˆ’:æ–æ³¢é‚£å¥‘æ•°
åŠ¨æ€è§„åˆ’:çˆ¬æ¥¼æ¢¯
åŠ¨æ€è§„åˆ’:ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯
åŠ¨æ€è§„åˆ’:ä¸åŒè·¯å¾„
åŠ¨æ€è§„åˆ’:ä¸åŒè·¯å¾„è¿˜ä¸å¤Ÿ,è¦æœ‰éšœç¢!
åŠ¨æ€è§„åˆ’:æ•´æ•°æ‹†åˆ†,ä½ è¦æ€ä¹ˆæ‹†ï¼Ÿ
åŠ¨æ€è§„åˆ’:ä¸åŒçš„äºŒå‰æœç´¢æ ‘
"""
#1 (Easy) 509.æ–æ³¢é‚£å¥‘æ•°
    # æ–æ³¢é‚£å¥‘æ•°, é€šå¸¸ç”¨ F(n) è¡¨ç¤º, å½¢æˆçš„åºåˆ—ç§°ä¸º æ–æ³¢é‚£å¥‘æ•°åˆ— ã€‚
    # è¯¥æ•°åˆ—ç”± 0 å’Œ 1 å¼€å§‹, åé¢çš„æ¯ä¸€é¡¹æ•°å­—éƒ½æ˜¯å‰é¢ä¸¤é¡¹æ•°å­—çš„å’Œã€‚
    # ä¹Ÿå°±æ˜¯: F(0) = 0, F(1) = 1 F(n) = F(n - 1) + F(n - 2), å…¶ä¸­ n > 1 ç»™ä½ n , è¯·è®¡ç®— F(n) ã€‚
# é€’å½’å®ç°
class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        return self.fib(n - 1) + self.fib(n - 2)
# åŠ¨æ€è§„åˆ’(ç‰ˆæœ¬ä¸€)
class Solution:
    def fib(self, n: int) -> int:
        # æ’é™¤ Corner Case
        if n == 0:
            return 0
        
        # åˆ›å»º dp table 
        dp = [0] * (n + 1)

        # åˆå§‹åŒ– dp æ•°ç»„
        dp[0] = 0
        dp[1] = 1

        # éå†é¡ºåº: ç”±å‰å‘åã€‚å› ä¸ºåé¢è¦ç”¨åˆ°å‰é¢çš„çŠ¶æ€
        for i in range(2, n + 1):

            # ç¡®å®šé€’å½’å…¬å¼/çŠ¶æ€è½¬ç§»å…¬å¼
            dp[i] = dp[i - 1] + dp[i - 2]
        
        # è¿”å›ç­”æ¡ˆ
        return dp[n]
# *** åŠ¨æ€è§„åˆ’(ç‰ˆæœ¬äºŒ)
class Solution:
    def fib(self, n: int) -> int:
        if n <= 1:
            return n
        
        dp = [0, 1]
        
        for i in range(2, n + 1):
            total = dp[0] + dp[1]
            dp[0] = dp[1]
            dp[1] = total
        
        return dp[1]
# åŠ¨æ€è§„åˆ’(ç‰ˆæœ¬ä¸‰)
# class Solution:
#     def fib(self, n: int) -> int:
#         if n <= 1:
#             return n
        
#         prev1, prev2 = 0, 1
        
#         for _ in range(2, n + 1):
#             curr = prev1 + prev2
#             prev1, prev2 = prev2, curr
#         return prev2


#X2 (Easy) 70.çˆ¬æ¥¼æ¢¯
    # å‡è®¾ä½ æ­£åœ¨çˆ¬æ¥¼æ¢¯ã€‚éœ€è¦ n é˜¶ä½ æ‰èƒ½åˆ°è¾¾æ¥¼é¡¶ã€‚
    # æ¯æ¬¡ä½ å¯ä»¥çˆ¬ 1 æˆ– 2 ä¸ªå°é˜¶ã€‚ä½ æœ‰å¤šå°‘ç§ä¸åŒçš„æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶å‘¢ï¼Ÿ
    # æ³¨æ„:ç»™å®š n æ˜¯ä¸€ä¸ªæ­£æ•´æ•°ã€‚
# åŠ¨æ€è§„åˆ’(ç‰ˆæœ¬ä¸€)
# ç©ºé—´å¤æ‚åº¦ä¸ºO(n)ç‰ˆæœ¬
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 1:
            return n
        
        dp = [0] * (n + 1)
        dp[1] = 1
        dp[2] = 2
        
        for i in range(3, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        
        return dp[n]
# åŠ¨æ€è§„åˆ’(ç‰ˆæœ¬äºŒ)
# ç©ºé—´å¤æ‚åº¦ä¸ºO(3)ç‰ˆæœ¬
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 1:
            return n
        
        dp = [0] * 3
        dp[1] = 1
        dp[2] = 2
        
        for i in range(3, n + 1):
            total = dp[1] + dp[2]
            dp[1] = dp[2]
            dp[2] = total
        return dp[2]
# è¿™é“é¢˜ç›®è¿˜å¯ä»¥ç»§ç»­æ·±åŒ–,å°±æ˜¯ä¸€æ­¥ä¸€ä¸ªå°é˜¶,ä¸¤ä¸ªå°é˜¶,ä¸‰ä¸ªå°é˜¶,ç›´åˆ° mä¸ªå°é˜¶,æœ‰å¤šå°‘ç§æ–¹æ³•çˆ¬åˆ°né˜¶æ¥¼é¡¶ã€‚
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) { // æŠŠmæ¢æˆ2,å°±å¯ä»¥ACçˆ¬æ¥¼æ¢¯è¿™é“é¢˜
                if (i - j >= 0) dp[i] += dp[i - j];
            }
        }
        return dp[n];
    }
};

# Climbing Stairs
# Determine the number of distinct ways to climb a staircase of n steps by taking either 1 or 2 steps at a time.
def climbing_stairs_bottom_up(n: int) -> int:
    if n <= 2:
        return n
    dp = [0] * (n + 1)
    # Base cases.
    dp[1], dp[2] = 1, 2
    # Starting from step 3, calculate the number of ways to reach each 
    # step until the n-th step.
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]

def climbing_stairs_bottom_up_optimized(n: int) -> int:
    if n <= 2:
        return n
    # Set 'one_step_before' and 'two_steps_before' as the base cases.
    one_step_before, two_steps_before = 2, 1
    for i in range(3, n + 1):
        # Calculate the number of ways to reach the current step.
        current = one_step_before + two_steps_before
        # Update the values for the next iteration.
        two_steps_before = one_step_before
        one_step_before = current
    return one_step_before


#3 ??? (Easy) 746.ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯
    # æ•°ç»„çš„æ¯ä¸ªä¸‹æ ‡ä½œä¸ºä¸€ä¸ªé˜¶æ¢¯, ç¬¬ i ä¸ªé˜¶æ¢¯å¯¹åº”ç€ä¸€ä¸ªéè´Ÿæ•°çš„ä½“åŠ›èŠ±è´¹å€¼ cost[i](ä¸‹æ ‡ä» 0 å¼€å§‹)ã€‚
    # æ¯å½“ä½ çˆ¬ä¸Šä¸€ä¸ªé˜¶æ¢¯ä½ éƒ½è¦èŠ±è´¹å¯¹åº”çš„ä½“åŠ›å€¼, ä¸€æ—¦æ”¯ä»˜äº†ç›¸åº”çš„ä½“åŠ›å€¼, ä½ å°±å¯ä»¥é€‰æ‹©å‘ä¸Šçˆ¬ä¸€ä¸ªé˜¶æ¢¯æˆ–è€…çˆ¬ä¸¤ä¸ªé˜¶æ¢¯ã€‚
    # è¯·ä½ æ‰¾å‡ºè¾¾åˆ°æ¥¼å±‚é¡¶éƒ¨çš„æœ€ä½èŠ±è´¹ã€‚åœ¨å¼€å§‹æ—¶, ä½ å¯ä»¥é€‰æ‹©ä»ä¸‹æ ‡ä¸º 0 æˆ– 1 çš„å…ƒç´ ä½œä¸ºåˆå§‹é˜¶æ¢¯ã€‚
    # ç¤ºä¾‹ 1:è¾“å…¥:cost = [10, 15, 20] è¾“å‡º:15 è§£é‡Š:æœ€ä½èŠ±è´¹æ˜¯ä» cost[1] å¼€å§‹, ç„¶åèµ°ä¸¤æ­¥å³å¯åˆ°é˜¶æ¢¯é¡¶, ä¸€å…±èŠ±è´¹ 15 ã€‚
    # ç¤ºä¾‹ 2:è¾“å…¥:cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] è¾“å‡º:6 è§£é‡Š:æœ€ä½èŠ±è´¹æ–¹å¼æ˜¯ä» cost[0] å¼€å§‹, é€ä¸ªç»è¿‡é‚£äº› 1 , è·³è¿‡ cost[3] , ä¸€å…±èŠ±è´¹ 6 ã€‚
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        dp = [0] * (len(cost))
        dp[0] = cost[0]
        dp[1] = cost[1]
        for i in range(2, len(cost)):
            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]
        return min(dp[len(cost) - 1], dp[len(cost) - 2])
# åŠ¨æ€è§„åˆ’(ç‰ˆæœ¬ä¸€)
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        dp = [0] * (len(cost) + 1)
        dp[0] = 0  # åˆå§‹å€¼,è¡¨ç¤ºä»èµ·ç‚¹å¼€å§‹ä¸éœ€è¦èŠ±è´¹ä½“åŠ›
        dp[1] = 0  # åˆå§‹å€¼,è¡¨ç¤ºç»è¿‡ç¬¬ä¸€æ­¥ä¸éœ€è¦èŠ±è´¹ä½“åŠ›
        
        for i in range(2, len(cost) + 1):
            # åœ¨ç¬¬iæ­¥,å¯ä»¥é€‰æ‹©ä»å‰ä¸€æ­¥(i-1)èŠ±è´¹ä½“åŠ›åˆ°è¾¾å½“å‰æ­¥,æˆ–è€…ä»å‰ä¸¤æ­¥(i-2)èŠ±è´¹ä½“åŠ›åˆ°è¾¾å½“å‰æ­¥
            # é€‰æ‹©å…¶ä¸­èŠ±è´¹ä½“åŠ›è¾ƒå°çš„è·¯å¾„,åŠ ä¸Šå½“å‰æ­¥çš„èŠ±è´¹,æ›´æ–°dpæ•°ç»„
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
        
        return dp[len(cost)]  # è¿”å›åˆ°è¾¾æ¥¼é¡¶çš„æœ€å°èŠ±è´¹
# åŠ¨æ€è§„åˆ’(ç‰ˆæœ¬äºŒ)
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        dp0 = 0  # åˆå§‹å€¼,è¡¨ç¤ºä»èµ·ç‚¹å¼€å§‹ä¸éœ€è¦èŠ±è´¹ä½“åŠ›
        dp1 = 0  # åˆå§‹å€¼,è¡¨ç¤ºç»è¿‡ç¬¬ä¸€æ­¥ä¸éœ€è¦èŠ±è´¹ä½“åŠ›
        
        for i in range(2, len(cost) + 1):
            # åœ¨ç¬¬iæ­¥,å¯ä»¥é€‰æ‹©ä»å‰ä¸€æ­¥(i-1)èŠ±è´¹ä½“åŠ›åˆ°è¾¾å½“å‰æ­¥,æˆ–è€…ä»å‰ä¸¤æ­¥(i-2)èŠ±è´¹ä½“åŠ›åˆ°è¾¾å½“å‰æ­¥
            # é€‰æ‹©å…¶ä¸­èŠ±è´¹ä½“åŠ›è¾ƒå°çš„è·¯å¾„,åŠ ä¸Šå½“å‰æ­¥çš„èŠ±è´¹,å¾—åˆ°å½“å‰æ­¥çš„æœ€å°èŠ±è´¹
            dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2])
            
            dp0 = dp1  # æ›´æ–°dp0ä¸ºå‰ä¸€æ­¥çš„å€¼,å³ä¸Šä¸€æ¬¡å¾ªç¯ä¸­çš„dp1
            dp1 = dpi  # æ›´æ–°dp1ä¸ºå½“å‰æ­¥çš„æœ€å°èŠ±è´¹
        
        return dp1  # è¿”å›åˆ°è¾¾æ¥¼é¡¶çš„æœ€å°èŠ±è´¹
# # åŠ¨æ€è§„åˆ’(ç‰ˆæœ¬ä¸‰)
# class Solution:
#     def minCostClimbingStairs(self, cost: List[int]) -> int:
#         dp = [0] * len(cost)
#         dp[0] = cost[0]  # ç¬¬ä¸€æ­¥æœ‰èŠ±è´¹
#         dp[1] = cost[1]
#         for i in range(2, len(cost)):
#             dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]
#         # æ³¨æ„æœ€åä¸€æ­¥å¯ä»¥ç†è§£ä¸ºä¸ç”¨èŠ±è´¹,æ‰€ä»¥å–å€’æ•°ç¬¬ä¸€æ­¥,ç¬¬äºŒæ­¥çš„æœ€å°‘å€¼
#         return min(dp[-1], dp[-2])
# # åŠ¨æ€è§„åˆ’(ç‰ˆæœ¬å››)
# class Solution:
#     def minCostClimbingStairs(self, cost: List[int]) -> int:
#         n = len(cost)
#         prev_1 = cost[0]  # å‰ä¸€æ­¥çš„æœ€å°èŠ±è´¹
#         prev_2 = cost[1]  # å‰ä¸¤æ­¥çš„æœ€å°èŠ±è´¹
#         for i in range(2, n):
#             current = min(prev_1, prev_2) + cost[i]  # å½“å‰ä½ç½®çš„æœ€å°èŠ±è´¹
#             prev_1, prev_2 = prev_2, current  # æ›´æ–°å‰ä¸€æ­¥å’Œå‰ä¸¤æ­¥çš„æœ€å°èŠ±è´¹
#         return min(prev_1, prev_2)  # æœ€åä¸€æ­¥å¯ä»¥ç†è§£ä¸ºä¸ç”¨èŠ±è´¹,å–å€’æ•°ç¬¬ä¸€æ­¥å’Œç¬¬äºŒæ­¥çš„æœ€å°‘å€¼


#4 (Medium) 62.ä¸åŒè·¯å¾„
    # ä¸€ä¸ªæœºå™¨äººä½äºä¸€ä¸ª m x n ç½‘æ ¼çš„å·¦ä¸Šè§’ (èµ·å§‹ç‚¹åœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸º â€œStartâ€ )ã€‚
    # æœºå™¨äººæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚æœºå™¨äººè¯•å›¾è¾¾åˆ°ç½‘æ ¼çš„å³ä¸‹è§’(åœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸º â€œFinishâ€ )ã€‚
    # é—®æ€»å…±æœ‰å¤šå°‘æ¡ä¸åŒçš„è·¯å¾„ï¼Ÿ
    # è¾“å…¥:m = 3, n = 7
    # è¾“å‡º:28
# class Solution: # åŠ¨æ€è§„åˆ’
#     def uniquePaths(self, m: int, n: int) -> int:
#         dp = [[1 for i in range(n)] for j in range(m)]
#         for i in range(1, m):
#             for j in range(1, n):
#                 dp[i][j] = dp[i][j - 1] + dp[i - 1][j]
#         return dp[m - 1][n - 1]
# # é€’å½’
# class Solution:
#     def uniquePaths(self, m: int, n: int) -> int:
#         if m == 1 or n == 1:
#             return 1
#         return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)
# *** åŠ¨æ€è§„åˆ’(ç‰ˆæœ¬ä¸€) 2D
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # åˆ›å»ºä¸€ä¸ªäºŒç»´åˆ—è¡¨ç”¨äºå­˜å‚¨å”¯ä¸€è·¯å¾„æ•°
        dp = [[0] * n for _ in range(m)]
        
        # è®¾ç½®ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—çš„åŸºæœ¬æƒ…å†µ
        for i in range(m):
            dp[i][0] = 1
        for j in range(n):
            dp[0][j] = 1
        
        # è®¡ç®—æ¯ä¸ªå•å…ƒæ ¼çš„å”¯ä¸€è·¯å¾„æ•°
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        
        # è¿”å›å³ä¸‹è§’å•å…ƒæ ¼çš„å”¯ä¸€è·¯å¾„æ•°
        return dp[m - 1][n - 1]
# åŠ¨æ€è§„åˆ’(ç‰ˆæœ¬äºŒ) 1D
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # åˆ›å»ºä¸€ä¸ªä¸€ç»´åˆ—è¡¨ç”¨äºå­˜å‚¨æ¯åˆ—çš„å”¯ä¸€è·¯å¾„æ•°
        dp = [1] * n
        
        # è®¡ç®—æ¯ä¸ªå•å…ƒæ ¼çš„å”¯ä¸€è·¯å¾„æ•°
        for j in range(1, m):
            for i in range(1, n):
                dp[i] += dp[i - 1]
        
        # è¿”å›å³ä¸‹è§’å•å…ƒæ ¼çš„å”¯ä¸€è·¯å¾„æ•°
        return dp[n - 1]
# æ•°è®º
# class Solution:
#     def uniquePaths(self, m: int, n: int) -> int:
#         numerator = 1  # åˆ†å­
#         denominator = m - 1  # åˆ†æ¯
#         count = m - 1  # è®¡æ•°å™¨,è¡¨ç¤ºå‰©ä½™éœ€è¦è®¡ç®—çš„ä¹˜ç§¯é¡¹ä¸ªæ•°
#         t = m + n - 2  # åˆå§‹ä¹˜ç§¯é¡¹
#         while count > 0:
#             numerator *= t  # è®¡ç®—ä¹˜ç§¯é¡¹çš„åˆ†å­éƒ¨åˆ†
#             t -= 1  # é€’å‡ä¹˜ç§¯é¡¹
#             while denominator != 0 and numerator % denominator == 0:
#                 numerator //= denominator  # çº¦ç®€åˆ†å­
#                 denominator -= 1  # é€’å‡åˆ†æ¯
#             count -= 1  # è®¡æ•°å™¨å‡1,ç»§ç»­ä¸‹ä¸€é¡¹çš„è®¡ç®—
#         return numerator  # è¿”å›æœ€ç»ˆçš„å”¯ä¸€è·¯å¾„æ•°


#5 (Medium) 63.ä¸åŒè·¯å¾„ II
    # ä¸€ä¸ªæœºå™¨äººä½äºä¸€ä¸ª m x n ç½‘æ ¼çš„å·¦ä¸Šè§’ (èµ·å§‹ç‚¹åœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸ºâ€œStartâ€ )ã€‚
    # æœºå™¨äººæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚æœºå™¨äººè¯•å›¾è¾¾åˆ°ç½‘æ ¼çš„å³ä¸‹è§’(åœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸ºâ€œFinishâ€)ã€‚
    # ç°åœ¨è€ƒè™‘ç½‘æ ¼ä¸­æœ‰éšœç¢ç‰©ã€‚é‚£ä¹ˆä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’å°†ä¼šæœ‰å¤šå°‘æ¡ä¸åŒçš„è·¯å¾„ï¼Ÿ
    # ç½‘æ ¼ä¸­çš„éšœç¢ç‰©å’Œç©ºä½ç½®åˆ†åˆ«ç”¨ 1 å’Œ 0 æ¥è¡¨ç¤ºã€‚
    # è¾“å…¥:obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
    # è¾“å‡º:2
"""
ä½†å°±ç®—æ˜¯åšè¿‡62.ä¸åŒè·¯å¾„, åœ¨åšæœ¬é¢˜ä¹Ÿä¼šæœ‰æ„Ÿè§‰é‡åˆ°éšœç¢æ— ä»ä¸‹æ‰‹ã€‚
å…¶å®åªè¦è€ƒè™‘åˆ°, é‡åˆ°éšœç¢dp[i][j]ä¿æŒ0å°±å¯ä»¥äº†ã€‚
ä¹Ÿæœ‰ä¸€äº›å°ç»†èŠ‚, ä¾‹å¦‚: åˆå§‹åŒ–çš„éƒ¨åˆ†, å¾ˆå®¹æ˜“å¿½ç•¥äº†éšœç¢ä¹‹ååº”è¯¥éƒ½æ˜¯0çš„æƒ…å†µã€‚
"""
# class Solution:
#     def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
#         # æ„é€ ä¸€ä¸ªDP table
#         row = len(obstacleGrid)
#         col = len(obstacleGrid[0])
#         dp = [[0 for _ in range(col)] for _ in range(row)]

#         dp[0][0] = 1 if obstacleGrid[0][0] != 1 else 0
#         if dp[0][0] == 0: return 0  # å¦‚æœç¬¬ä¸€ä¸ªæ ¼å­å°±æ˜¯éšœç¢, return 0
#         # ç¬¬ä¸€è¡Œ
#         for i in range(1, col):
#             if obstacleGrid[0][i] != 1:
#                 dp[0][i] = dp[0][i-1]

#         # ç¬¬ä¸€åˆ—
#         for i in range(1, row):
#             if obstacleGrid[i][0] != 1:
#                 dp[i][0] = dp[i-1][0]
#         print(dp)

#         for i in range(1, row):
#             for j in range(1, col):
#                 if obstacleGrid[i][j] != 1:
#                     dp[i][j] = dp[i-1][j] + dp[i][j-1]
#         return dp[-1][-1]
# åŠ¨æ€è§„åˆ’(ç‰ˆæœ¬ä¸€)äºŒç»´æ•°ç»„
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid):
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        if obstacleGrid[m - 1][n - 1] == 1 or obstacleGrid[0][0] == 1:
            return 0
        dp = [[0] * n for _ in range(m)]
        for i in range(m):
            if obstacleGrid[i][0] == 0:  # é‡åˆ°éšœç¢ç‰©æ—¶,ç›´æ¥é€€å‡ºå¾ªç¯,åé¢é»˜è®¤éƒ½æ˜¯0
                dp[i][0] = 1
            else:
                break # breack will stop the for loop
        for j in range(n):
            if obstacleGrid[0][j] == 0:
                dp[0][j] = 1
            else:
                break
        for i in range(1, m):
            for j in range(1, n):
                if obstacleGrid[i][j] == 1:
                    continue # continue will go to the next iteration in loop
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[m - 1][n - 1]
# åŠ¨æ€è§„åˆ’(ç‰ˆæœ¬äºŒ)
# class Solution:
#     def uniquePathsWithObstacles(self, obstacleGrid):
#         m = len(obstacleGrid)  # ç½‘æ ¼çš„è¡Œæ•°
#         n = len(obstacleGrid[0])  # ç½‘æ ¼çš„åˆ—æ•°
        
#         if obstacleGrid[m - 1][n - 1] == 1 or obstacleGrid[0][0] == 1:
#             # å¦‚æœèµ·ç‚¹æˆ–ç»ˆç‚¹æœ‰éšœç¢ç‰©,ç›´æ¥è¿”å›0
#             return 0
        
#         dp = [[0] * n for _ in range(m)]  # åˆ›å»ºä¸€ä¸ªäºŒç»´åˆ—è¡¨ç”¨äºå­˜å‚¨è·¯å¾„æ•°
        
#         # è®¾ç½®èµ·ç‚¹çš„è·¯å¾„æ•°ä¸º1
#         dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0
        
#         # è®¡ç®—ç¬¬ä¸€åˆ—çš„è·¯å¾„æ•°
#         for i in range(1, m):
#             if obstacleGrid[i][0] == 0:
#                 dp[i][0] = dp[i - 1][0]
        
#         # è®¡ç®—ç¬¬ä¸€è¡Œçš„è·¯å¾„æ•°
#         for j in range(1, n):
#             if obstacleGrid[0][j] == 0:
#                 dp[0][j] = dp[0][j - 1]
        
#         # è®¡ç®—å…¶ä»–ä½ç½®çš„è·¯å¾„æ•°
#         for i in range(1, m):
#             for j in range(1, n):
#                 if obstacleGrid[i][j] == 1:
#                     continue
#                 dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
#         return dp[m - 1][n - 1]  # è¿”å›ç»ˆç‚¹çš„è·¯å¾„æ•°
# åŠ¨æ€è§„åˆ’(ç‰ˆæœ¬ä¸‰)
# class Solution:
#     def uniquePathsWithObstacles(self, obstacleGrid):
#         if obstacleGrid[0][0] == 1:
#             return 0
        
#         dp = [0] * len(obstacleGrid[0])  # åˆ›å»ºä¸€ä¸ªä¸€ç»´åˆ—è¡¨ç”¨äºå­˜å‚¨è·¯å¾„æ•°
        
#         # åˆå§‹åŒ–ç¬¬ä¸€è¡Œçš„è·¯å¾„æ•°
#         for j in range(len(dp)):
#             if obstacleGrid[0][j] == 1:
#                 dp[j] = 0
#             elif j == 0:
#                 dp[j] = 1
#             else:
#                 dp[j] = dp[j - 1]

#         # è®¡ç®—å…¶ä»–è¡Œçš„è·¯å¾„æ•°
#         for i in range(1, len(obstacleGrid)):
#             for j in range(len(dp)):
#                 if obstacleGrid[i][j] == 1:
#                     dp[j] = 0
#                 elif j != 0:
#                     dp[j] = dp[j] + dp[j - 1]
        
#         return dp[-1]  # è¿”å›æœ€åä¸€ä¸ªå…ƒç´ ,å³ç»ˆç‚¹çš„è·¯å¾„æ•°
# *** åŠ¨æ€è§„åˆ’(ç‰ˆæœ¬å››)ä¸€ç»´æ•°ç»„
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid):
        if obstacleGrid[0][0] == 1:
            return 0
        
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        
        dp = [0] * n  # åˆ›å»ºä¸€ä¸ªä¸€ç»´åˆ—è¡¨ç”¨äºå­˜å‚¨è·¯å¾„æ•°
        
        # åˆå§‹åŒ–ç¬¬ä¸€è¡Œçš„è·¯å¾„æ•°
        for j in range(n):
            if obstacleGrid[0][j] == 1:
                break
            dp[j] = 1

        # è®¡ç®—å…¶ä»–è¡Œçš„è·¯å¾„æ•°
        for i in range(1, m):
            if obstacleGrid[i][0] == 1:
                dp[0] = 0
            for j in range(1, n):
                if obstacleGrid[i][j] == 1:
                    dp[j] = 0
                else:
                    dp[j] += dp[j - 1]
        
        return dp[-1]  # è¿”å›æœ€åä¸€ä¸ªå…ƒç´ ,å³ç»ˆç‚¹çš„è·¯å¾„æ•°
# åŠ¨æ€è§„åˆ’(ç‰ˆæœ¬äº”)
# class Solution:
#     def uniquePathsWithObstacles(self, obstacleGrid):
#         if obstacleGrid[0][0] == 1:
#             return 0
        
#         m, n = len(obstacleGrid), len(obstacleGrid[0])
        
#         dp = [0] * n  # åˆ›å»ºä¸€ä¸ªä¸€ç»´åˆ—è¡¨ç”¨äºå­˜å‚¨è·¯å¾„æ•°
        
#         # åˆå§‹åŒ–ç¬¬ä¸€è¡Œçš„è·¯å¾„æ•°
#         for j in range(n):
#             if obstacleGrid[0][j] == 1:
#                 break
#             dp[j] = 1

#         # è®¡ç®—å…¶ä»–è¡Œçš„è·¯å¾„æ•°
#         for i in range(1, m):
#             if obstacleGrid[i][0] == 1:
#                 dp[0] = 0
#             for j in range(1, n):
#                 if obstacleGrid[i][j] == 1:
#                     dp[j] = 0
#                     continue
                
#                 dp[j] += dp[j - 1]
#         return dp[-1]  # è¿”å›æœ€åä¸€ä¸ªå…ƒç´ ,å³ç»ˆç‚¹çš„è·¯å¾„æ•°


#6 ??? (Medium) 343.æ•´æ•°æ‹†åˆ†
    # ç»™å®šä¸€ä¸ªæ­£æ•´æ•° n, å°†å…¶æ‹†åˆ†ä¸ºè‡³å°‘ä¸¤ä¸ªæ­£æ•´æ•°çš„å’Œ, å¹¶ä½¿è¿™äº›æ•´æ•°çš„ä¹˜ç§¯æœ€å¤§åŒ–ã€‚ è¿”å›ä½ å¯ä»¥è·å¾—çš„æœ€å¤§ä¹˜ç§¯ã€‚
    # ç¤ºä¾‹ 1:
    # è¾“å…¥: 2
    # è¾“å‡º: 1
    # è§£é‡Š: 2 = 1 + 1, 1 Ã— 1 = 1ã€‚
    # ç¤ºä¾‹ 2:
    # è¾“å…¥: 10
    # è¾“å‡º: 36
    # è§£é‡Š: 10 = 3 + 3 + 4, 3 Ã— 3 Ã— 4 = 36ã€‚
    # è¯´æ˜: ä½ å¯ä»¥å‡è®¾ n ä¸å°äº 2 ä¸”ä¸å¤§äº 58
# XXX dp[i] = max(dp[i], dp[i - j] * dp[j])
# dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
# ä¹Ÿå¯ä»¥è¿™ä¹ˆç†è§£,j * (i - j) æ˜¯å•çº¯çš„æŠŠæ•´æ•°æ‹†åˆ†ä¸ºä¸¤ä¸ªæ•°ç›¸ä¹˜,è€Œj * dp[i - j]æ˜¯æ‹†åˆ†æˆä¸¤ä¸ªä»¥åŠä¸¤ä¸ªä»¥ä¸Šçš„ä¸ªæ•°ç›¸ä¹˜ã€‚
# é‚£ä¹ˆåœ¨å–æœ€å¤§å€¼çš„æ—¶å€™,ä¸ºä»€ä¹ˆè¿˜è¦æ¯”è¾ƒdp[i]å‘¢ï¼Ÿå› ä¸ºåœ¨é€’æ¨å…¬å¼æ¨å¯¼çš„è¿‡ç¨‹ä¸­,æ¯æ¬¡è®¡ç®—dp[i],å–æœ€å¤§çš„è€Œå·²ã€‚
class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[2] = 1
        for i in range(3, n + 1):
            # å‡è®¾å¯¹æ­£æ•´æ•° i æ‹†åˆ†å‡ºçš„ç¬¬ä¸€ä¸ªæ­£æ•´æ•°æ˜¯ j(1 <= j < i), åˆ™æœ‰ä»¥ä¸‹ä¸¤ç§æ–¹æ¡ˆ:
            # 1) å°† i æ‹†åˆ†æˆ j å’Œ iâˆ’j çš„å’Œ, ä¸” iâˆ’j ä¸å†æ‹†åˆ†æˆå¤šä¸ªæ­£æ•´æ•°, æ­¤æ—¶çš„ä¹˜ç§¯æ˜¯ j * (i-j)
            # 2) å°† i æ‹†åˆ†æˆ j å’Œ iâˆ’j çš„å’Œ, ä¸” iâˆ’j ç»§ç»­æ‹†åˆ†æˆå¤šä¸ªæ­£æ•´æ•°, æ­¤æ—¶çš„ä¹˜ç§¯æ˜¯ j * dp[i-j]
            for j in range(1, i - 1):
                # dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))
                dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j)
        return dp[n]
# åŠ¨æ€è§„åˆ’(ç‰ˆæœ¬ä¸€)
# class Solution:
#          # å‡è®¾å¯¹æ­£æ•´æ•° i æ‹†åˆ†å‡ºçš„ç¬¬ä¸€ä¸ªæ­£æ•´æ•°æ˜¯ j(1 <= j < i),åˆ™æœ‰ä»¥ä¸‹ä¸¤ç§æ–¹æ¡ˆ:
#         # 1) å°† i æ‹†åˆ†æˆ j å’Œ iâˆ’j çš„å’Œ,ä¸” iâˆ’j ä¸å†æ‹†åˆ†æˆå¤šä¸ªæ­£æ•´æ•°,æ­¤æ—¶çš„ä¹˜ç§¯æ˜¯ j * (i-j)
#         # 2) å°† i æ‹†åˆ†æˆ j å’Œ iâˆ’j çš„å’Œ,ä¸” iâˆ’j ç»§ç»­æ‹†åˆ†æˆå¤šä¸ªæ­£æ•´æ•°,æ­¤æ—¶çš„ä¹˜ç§¯æ˜¯ j * dp[i-j]
#     def integerBreak(self, n):
#         dp = [0] * (n + 1)   # åˆ›å»ºä¸€ä¸ªå¤§å°ä¸ºn+1çš„æ•°ç»„æ¥å­˜å‚¨è®¡ç®—ç»“æœ
#         dp[2] = 1  # åˆå§‹åŒ–dp[2]ä¸º1,å› ä¸ºå½“n=2æ—¶,åªæœ‰ä¸€ä¸ªåˆ‡å‰²æ–¹å¼1+1=2,ä¹˜ç§¯ä¸º1
       
#         # ä»3å¼€å§‹è®¡ç®—,ç›´åˆ°n
#         for i in range(3, n + 1):
#             # éå†æ‰€æœ‰å¯èƒ½çš„åˆ‡å‰²ç‚¹
#                 # å› ä¸ºæ‹†åˆ†ä¸€ä¸ªæ•°n ä½¿ä¹‹ä¹˜ç§¯æœ€å¤§,é‚£ä¹ˆä¸€å®šæ˜¯æ‹†åˆ†æˆmä¸ªè¿‘ä¼¼ç›¸åŒçš„å­æ•°ç›¸ä¹˜æ‰æ˜¯æœ€å¤§çš„ã€‚
#                 # åªä¸è¿‡æˆ‘ä»¬ä¸çŸ¥é“mç©¶ç«Ÿæ˜¯å¤šå°‘è€Œå·²,ä½†å¯ä»¥æ˜ç¡®çš„æ˜¯mä¸€å®šå¤§äºç­‰äº2,æ—¢ç„¶må¤§äºç­‰äº2,ä¹Ÿå°±æ˜¯ æœ€å·®ä¹Ÿåº”è¯¥æ˜¯æ‹†æˆä¸¤ä¸ªç›¸åŒçš„ å¯èƒ½æ˜¯æœ€å¤§å€¼ã€‚
#                 # é‚£ä¹ˆ j éå†,åªéœ€è¦éå†åˆ° n/2 å°±å¯ä»¥,åé¢å°±æ²¡æœ‰å¿…è¦éå†äº†,ä¸€å®šä¸æ˜¯æœ€å¤§å€¼ã€‚
#             for j in range(1, i // 2 + 1):

#                 # è®¡ç®—åˆ‡å‰²ç‚¹jå’Œå‰©ä½™éƒ¨åˆ†(i-j)çš„ä¹˜ç§¯,å¹¶ä¸ä¹‹å‰çš„ç»“æœè¿›è¡Œæ¯”è¾ƒå–è¾ƒå¤§å€¼
                
#                 dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j)
#         return dp[n]  # è¿”å›æœ€ç»ˆçš„è®¡ç®—ç»“æœ
# åŠ¨æ€è§„åˆ’(ç‰ˆæœ¬äºŒ)
# class Solution:
#     def integerBreak(self, n):
#         if n <= 3:
#             return 1 * (n - 1)  # å¯¹äºnå°äºç­‰äº3çš„æƒ…å†µ,è¿”å›1 * (n - 1)

#         dp = [0] * (n + 1)  # åˆ›å»ºä¸€ä¸ªå¤§å°ä¸ºn+1çš„æ•°ç»„æ¥å­˜å‚¨æœ€å¤§ä¹˜ç§¯ç»“æœ
#         dp[1] = 1  # å½“nç­‰äº1æ—¶,æœ€å¤§ä¹˜ç§¯ä¸º1
#         dp[2] = 2  # å½“nç­‰äº2æ—¶,æœ€å¤§ä¹˜ç§¯ä¸º2
#         dp[3] = 3  # å½“nç­‰äº3æ—¶,æœ€å¤§ä¹˜ç§¯ä¸º3

#         # ä»4å¼€å§‹è®¡ç®—,ç›´åˆ°n
#         for i in range(4, n + 1):
#             # éå†æ‰€æœ‰å¯èƒ½çš„åˆ‡å‰²ç‚¹
#             for j in range(1, i // 2 + 1):
#                 # è®¡ç®—åˆ‡å‰²ç‚¹jå’Œå‰©ä½™éƒ¨åˆ†(i - j)çš„ä¹˜ç§¯,å¹¶ä¸ä¹‹å‰çš„ç»“æœè¿›è¡Œæ¯”è¾ƒå–è¾ƒå¤§å€¼
#                 dp[i] = max(dp[i], dp[i - j] * dp[j])
#         return dp[n]  # è¿”å›æ•´æ•°æ‹†åˆ†çš„æœ€å¤§ä¹˜ç§¯ç»“æœ
# è´ªå¿ƒ
# class Solution:
#     def integerBreak(self, n):
#         if n == 2:  # å½“nç­‰äº2æ—¶,åªæœ‰ä¸€ç§æ‹†åˆ†æ–¹å¼:1+1=2,ä¹˜ç§¯ä¸º1
#             return 1
#         if n == 3:  # å½“nç­‰äº3æ—¶,åªæœ‰ä¸€ç§æ‹†åˆ†æ–¹å¼:1+1+1=3,ä¹˜ç§¯ä¸º1
#             return 2
#         if n == 4:  # å½“nç­‰äº4æ—¶,æœ‰ä¸¤ç§æ‹†åˆ†æ–¹å¼:2+2=4å’Œ1+1+1+1=4,ä¹˜ç§¯éƒ½ä¸º4
#             return 4
#         result = 1
#         while n > 4:
#             result *= 3  # æ¯æ¬¡ä¹˜ä»¥3,å› ä¸º3çš„ä¹˜ç§¯æ¯”å…¶ä»–æ•°å­—æ›´å¤§
#             n -= 3  # æ¯æ¬¡å‡å»3
#         result *= n  # å°†å‰©ä½™çš„nä¹˜ä»¥æœ€åçš„ç»“æœ
#         return result


#7 (Medium) 96.ä¸åŒçš„äºŒå‰æœç´¢æ ‘
    # ç»™å®šä¸€ä¸ªæ•´æ•° n, æ±‚ä»¥ 1 ... n ä¸ºèŠ‚ç‚¹ç»„æˆçš„äºŒå‰æœç´¢æ ‘æœ‰å¤šå°‘ç§ï¼Ÿ
# dp[i] += dp[j - 1] * dp[i - j]
# åœ¨ä¸Šé¢çš„åˆ†æä¸­,å…¶å®å·²ç»çœ‹å‡ºå…¶é€’æ¨å…³ç³», dp[i] += dp[ä»¥jä¸ºå¤´ç»“ç‚¹å·¦å­æ ‘èŠ‚ç‚¹æ•°é‡] * dp[ä»¥jä¸ºå¤´ç»“ç‚¹å³å­æ ‘èŠ‚ç‚¹æ•°é‡]
# jç›¸å½“äºæ˜¯å¤´ç»“ç‚¹çš„å…ƒç´ ,ä»1éå†åˆ°iä¸ºæ­¢ã€‚
# æ‰€ä»¥é€’æ¨å…¬å¼:dp[i] += dp[j - 1] * dp[i - j]; ,j-1 ä¸ºjä¸ºå¤´ç»“ç‚¹å·¦å­æ ‘èŠ‚ç‚¹æ•°é‡,i-j ä¸ºä»¥jä¸ºå¤´ç»“ç‚¹å³å­æ ‘èŠ‚ç‚¹æ•°é‡
# 1, 2, ..., j, ..., i, in this list, left of j is j-1, right of j is i-j
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0] * (n + 1)  # åˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸ºn+1çš„æ•°ç»„,åˆå§‹åŒ–ä¸º0
        dp[0] = 1  # å½“nä¸º0æ—¶,åªæœ‰ä¸€ç§æƒ…å†µ,å³ç©ºæ ‘,æ‰€ä»¥dp[0] = 1
        for i in range(1, n + 1):  # éå†ä»1åˆ°nçš„æ¯ä¸ªæ•°å­—
            for j in range(1, i + 1):  # å¯¹äºæ¯ä¸ªæ•°å­—i,è®¡ç®—ä»¥iä¸ºæ ¹èŠ‚ç‚¹çš„äºŒå‰æœç´¢æ ‘çš„æ•°é‡
                dp[i] += dp[j - 1] * dp[i - j]  # åˆ©ç”¨åŠ¨æ€è§„åˆ’çš„æ€æƒ³,ç´¯åŠ å·¦å­æ ‘å’Œå³å­æ ‘çš„ç»„åˆæ•°é‡
        return dp[n]  # è¿”å›ä»¥1åˆ°nä¸ºèŠ‚ç‚¹çš„äºŒå‰æœç´¢æ ‘çš„æ€»æ•°é‡


"""
2. èƒŒåŒ…é—®é¢˜ç³»åˆ— (13)

åŠ¨æ€è§„åˆ’:å…³äº01èƒŒåŒ…é—®é¢˜,ä½ è¯¥äº†è§£è¿™äº›!
åŠ¨æ€è§„åˆ’:å…³äº01èƒŒåŒ…é—®é¢˜,ä½ è¯¥äº†è§£è¿™äº›!(æ»šåŠ¨æ•°ç»„)
åŠ¨æ€è§„åˆ’:åˆ†å‰²ç­‰å’Œå­é›†å¯ä»¥ç”¨01èƒŒåŒ…!
åŠ¨æ€è§„åˆ’:æœ€åä¸€å—çŸ³å¤´çš„é‡é‡ II
åŠ¨æ€è§„åˆ’:ç›®æ ‡å’Œ!
åŠ¨æ€è§„åˆ’:ä¸€å’Œé›¶!
åŠ¨æ€è§„åˆ’:å…³äºå®Œå…¨èƒŒåŒ…,ä½ è¯¥äº†è§£è¿™äº›!
åŠ¨æ€è§„åˆ’:ç»™ä½ ä¸€äº›é›¶é’±,ä½ è¦æ€ä¹ˆå‡‘ï¼Ÿ
åŠ¨æ€è§„åˆ’:Carlç§°å®ƒä¸ºæ’åˆ—æ€»å’Œ!
åŠ¨æ€è§„åˆ’:ä»¥å‰æˆ‘æ²¡å¾—é€‰,ç°åœ¨æˆ‘é€‰æ‹©å†çˆ¬ä¸€æ¬¡!
åŠ¨æ€è§„åˆ’: ç»™æˆ‘ä¸ªæœºä¼š,æˆ‘å†å…‘æ¢ä¸€æ¬¡é›¶é’±
åŠ¨æ€è§„åˆ’:ä¸€æ ·çš„å¥—è·¯,å†æ±‚ä¸€æ¬¡å®Œå…¨å¹³æ–¹æ•°
åŠ¨æ€è§„åˆ’:å•è¯æ‹†åˆ†
åŠ¨æ€è§„åˆ’:å…³äºå¤šé‡èƒŒåŒ…,ä½ è¯¥äº†è§£è¿™äº›!
å¬è¯´èƒŒåŒ…é—®é¢˜å¾ˆéš¾ï¼Ÿ è¿™ç¯‡æ€»ç»“ç¯‡æ¥æ‹¯æ•‘ä½ äº†
"""
#X8 01 èƒŒåŒ…
    # æœ‰nä»¶ç‰©å“å’Œä¸€ä¸ªæœ€å¤šèƒ½èƒŒé‡é‡ä¸ºw çš„èƒŒåŒ…ã€‚ç¬¬iä»¶ç‰©å“çš„é‡é‡æ˜¯weight[i], å¾—åˆ°çš„ä»·å€¼æ˜¯value[i] ã€‚æ¯ä»¶ç‰©å“åªèƒ½ç”¨ä¸€æ¬¡, 
    # æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…é‡Œç‰©å“ä»·å€¼æ€»å’Œæœ€å¤§ã€‚
    # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
    # å¤§å®¶å¯ä»¥çœ‹å‡º, è™½ç„¶ä¸¤ä¸ªforå¾ªç¯éå†çš„æ¬¡åºä¸åŒ, ä½†æ˜¯dp[i][j]æ‰€éœ€è¦çš„æ•°æ®å°±æ˜¯å·¦ä¸Šè§’, æ ¹æœ¬ä¸å½±å“dp[i][j]å…¬å¼çš„æ¨å¯¼!
    # å…¶å®èƒŒåŒ…é—®é¢˜é‡Œ, ä¸¤ä¸ªforå¾ªç¯çš„å…ˆåå¾ªåºæ˜¯éå¸¸æœ‰è®²ç©¶çš„, ç†è§£éå†é¡ºåºå…¶å®æ¯”ç†è§£æ¨å¯¼å…¬å¼éš¾å¤šäº†ã€‚
# 0/1 Knapsack
# You are a thief planning to rob a store. However, you can only carry a knapsack with a 
# maximum capacity of cap units. Each item (i) in the store has a weight (weights[i]) and a value (values[i]).
# Find the maximum total value of items you can carry in your knapsack.
# Example:
# Input: cap = 7, weights = [5, 3, 4, 1], values = [70, 50, 40, 10]
# Output: 90
# Explanation: The most valuable combination of items that can fit in the knapsack together are items 1 and 2 . These items have a combined value of 50 + 40 = 90 and a total weight of 3 + 4 = 7 , which fits within the knapsack's capacity.
def knapsack(cap: int, weights: List[int], values: List[int]) -> int:
    n = len(values)
    # Base case: Set the first column and last row to 0 by
    # initializing the entire DP table to 0.
    dp = [[0 for x in range(cap + 1)] for x in range(n + 1)]
    # Populate the DP table.
    for i in range(n - 1, -1, -1):
        for c in range(1, cap + 1):
            # If the item 'i' fits in the current knapsack capacity, 
            # the maximum value at 'dp[i][c]' is the largest of either:
            # 1. The maximum value if we include item 'i'.
            # 2. The maximum value if we exclude item 'i'.
            if weights[i] <= c:
                dp[i][c] = max(values[i] + dp[i + 1][c - weights[i]], dp[i + 1][c])
            # If it doesn't fit, we have to exclude it.
            else:
                dp[i][c] = dp[i + 1][c]
    return dp[0][cap]

def knapsack_optimized(cap: int, weights: List[int], values: List[int]) -> int:
    n = len(values)
    # Initialize 'prev_row' as the DP values of the row below the 
    # current row.
    prev_row = [0] * (cap + 1)
    for i in range(n - 1, -1, -1):
        # Set the first cell of the 'curr_row' to 0 to set the base 
        # case for this row. This is done by initializing the entire 
        # row to 0.
        curr_row = [0] * (cap + 1)
        for c in range(1, cap + 1):
            # If item 'i' fits in the current knapsack capacity, the 
            # maximum value at 'curr_row[c]' is the largest of either:
            # 1. The maximum value if we include item 'i'.
            # 2. The maximum value if we exclude item 'i'.
            if weights[i] <= c:
                curr_row[c] = max(values[i] + prev_row[c - weights[i]], prev_row[c])
            # If item 'i' doesn't fit, we exclude it.
            else:
                curr_row[c] = prev_row[c]
        # Set 'prev_row' to 'curr_row' values for the next iteration.
        prev_row = curr_row
    return prev_row[cap]

def test_2_wei_bag_problem1(bag_size, weight, value) -> int: 
	rows, cols = len(weight), bag_size + 1
	# dp = [[0 for _ in range(cols)] for _ in range(rows)]
	dp = [[0]*len(cols) for _ in range(rows)]
    
	# åˆå§‹åŒ–dpæ•°ç»„. 
	for i in range(rows): 
		dp[i][0] = 0
	first_item_weight, first_item_value = weight[0], value[0]
	for j in range(1, cols): 	
		if first_item_weight <= j: 
			dp[0][j] = first_item_value

	# æ›´æ–°dpæ•°ç»„: å…ˆéå†ç‰©å“, å†éå†èƒŒåŒ…. 
	for i in range(1, len(weight)): 
		cur_weight, cur_val = weight[i], value[i]
		for j in range(1, cols): 
			if cur_weight > j: # è¯´æ˜èƒŒåŒ…è£…ä¸ä¸‹å½“å‰ç‰©å“. 
				dp[i][j] = dp[i - 1][j] # æ‰€ä»¥ä¸è£…å½“å‰ç‰©å“. 
			else: 
				# å®šä¹‰dpæ•°ç»„: dp[i][j] å‰iä¸ªç‰©å“é‡Œ, æ”¾è¿›å®¹é‡ä¸ºjçš„èƒŒåŒ…, ä»·å€¼æ€»å’Œæœ€å¤§æ˜¯å¤šå°‘ã€‚
				dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - cur_weight]+ cur_val)
	print(dp)

if __name__ == "__main__": 
	bag_size = 4
	weight = [1, 3, 4]
	value = [15, 20, 30]
	test_2_wei_bag_problem1(bag_size, weight, value)

# æ— å‚æ•°ç‰ˆ
# def test_2_wei_bag_problem1():
#     weight = [1, 3, 4]
#     value = [15, 20, 30]
#     bagweight = 4

#     # äºŒç»´æ•°ç»„
#     dp = [[0] * (bagweight + 1) for _ in range(len(weight))]

#     # åˆå§‹åŒ–
#     for j in range(weight[0], bagweight + 1):
#         dp[0][j] = value[0]

#     # weightæ•°ç»„çš„å¤§å°å°±æ˜¯ç‰©å“ä¸ªæ•°
#     for i in range(1, len(weight)):  # éå†ç‰©å“
#         for j in range(bagweight + 1):  # éå†èƒŒåŒ…å®¹é‡
#             if j < weight[i]:
#                 dp[i][j] = dp[i - 1][j]
#             else:
#                 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])

#     print(dp[len(weight) - 1][bagweight])

# test_2_wei_bag_problem1()
# æœ‰å‚æ•°ç‰ˆ
# def test_2_wei_bag_problem1(weight, value, bagweight):
#     # äºŒç»´æ•°ç»„
#     dp = [[0] * (bagweight + 1) for _ in range(len(weight))]

#     # åˆå§‹åŒ–
#     for j in range(weight[0], bagweight + 1):
#         dp[0][j] = value[0]

#     # weightæ•°ç»„çš„å¤§å°å°±æ˜¯ç‰©å“ä¸ªæ•°
#     for i in range(1, len(weight)):  # éå†ç‰©å“
#         for j in range(bagweight + 1):  # éå†èƒŒåŒ…å®¹é‡
#             if j < weight[i]:
#                 dp[i][j] = dp[i - 1][j]
#             else:
#                 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])

#     return dp[len(weight) - 1][bagweight]

# if __name__ == "__main__":

#     weight = [1, 3, 4]
#     value = [15, 20, 30]
#     bagweight = 4
#     result = test_2_wei_bag_problem1(weight, value, bagweight)
#     print(result)


#9 01 èƒŒåŒ…(æ»šåŠ¨æ•°ç»„)
    # æŠŠiç›¸å…³çš„éƒ¨åˆ†å»æ‰
    # dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
    # äºŒç»´dpéå†çš„æ—¶å€™, èƒŒåŒ…å®¹é‡æ˜¯ä»å°åˆ°å¤§, è€Œä¸€ç»´dpéå†çš„æ—¶å€™, èƒŒåŒ…æ˜¯ä»å¤§åˆ°å°ã€‚
    # å€’åºéå†æ˜¯ä¸ºäº†ä¿è¯ç‰©å“iåªè¢«æ”¾å…¥ä¸€æ¬¡!ã€‚ä½†å¦‚æœä¸€æ—¦æ­£åºéå†äº†, é‚£ä¹ˆç‰©å“0å°±ä¼šè¢«é‡å¤åŠ å…¥å¤šæ¬¡!
    # ************
    # å¤šæ¬¡æ”¾å…¥çš„æ ¹æœ¬åŸå› æ˜¯,æ–°è¡Œçš„å€¼ä¾èµ–äºä¸Šä¸€è¡Œå½“å‰ä½ç½®å’Œå‰é¢ä½ç½®ã€‚å¦‚æœåªç”¨ä¸€ç»´æ•°ç»„,ä»å·¦åˆ°å³çš„è¯,ä¼šè¦†ç›–å‰é¢ä½ç½®
    # æ­¤æ—¶å‰é¢ä½ç½®çš„å€¼æ˜¯æ–°è¡Œ,è€Œä¸æ˜¯ä¸Šä¸€è¡Œçš„å€¼,æ‰€ä»¥é€ æˆé‡å¤æ”¾å…¥ã€‚æ ¹æœ¬åŸå› è¿˜æ˜¯æ²¡æœ‰æ‰¾åˆ°ä¸Šä¸€è¡Œçš„å¯¹åº”å€¼,é€ æˆè®¡ç®—é”™è¯¯
# æ— å‚ç‰ˆ
def test_1_wei_bag_problem():
    weight = [1, 3, 4]
    value = [15, 20, 30]
    bag_weight = 4
    # åˆå§‹åŒ–: å…¨ä¸º0
    dp = [0] * (bag_weight + 1)

    # å…ˆéå†ç‰©å“, å†éå†èƒŒåŒ…å®¹é‡
    for i in range(len(weight)): # éå†ç‰©å“
        for j in range(bag_weight, weight[i] - 1, -1): # éå†èƒŒåŒ…å®¹é‡
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

    print(dp)

test_1_wei_bag_problem()
# æœ‰å‚ç‰ˆ
# def test_1_wei_bag_problem(weight, value, bagWeight):
#     # åˆå§‹åŒ–
#     dp = [0] * (bagWeight + 1)
#     for i in range(len(weight)):  # éå†ç‰©å“
#         for j in range(bagWeight, weight[i] - 1, -1):  # éå†èƒŒåŒ…å®¹é‡
#             dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

#     return dp[bagWeight]


# if __name__ == "__main__":

#     weight = [1, 3, 4]
#     value = [15, 20, 30]
#     bagweight = 4

#     result = test_1_wei_bag_problem(weight, value, bagweight)
#     print(result)


#10 (Medium) 416.åˆ†å‰²ç­‰å’Œå­é›†
    # ç»™å®šä¸€ä¸ªåªåŒ…å«æ­£æ•´æ•°çš„éç©ºæ•°ç»„ã€‚æ˜¯å¦å¯ä»¥å°†è¿™ä¸ªæ•°ç»„åˆ†å‰²æˆä¸¤ä¸ªå­é›†, ä½¿å¾—ä¸¤ä¸ªå­é›†çš„å…ƒç´ å’Œç›¸ç­‰ã€‚
    # æ³¨æ„: æ¯ä¸ªæ•°ç»„ä¸­çš„å…ƒç´ ä¸ä¼šè¶…è¿‡ 100 æ•°ç»„çš„å¤§å°ä¸ä¼šè¶…è¿‡ 200
    # ç¤ºä¾‹ 1: è¾“å…¥: [1, 5, 11, 5] è¾“å‡º: true è§£é‡Š: æ•°ç»„å¯ä»¥åˆ†å‰²æˆ [1, 5, 5] å’Œ [11].
# è¿™é“é¢˜ç›®æ˜¯è¦æ‰¾æ˜¯å¦å¯ä»¥å°†è¿™ä¸ªæ•°ç»„åˆ†å‰²æˆä¸¤ä¸ªå­é›†,ä½¿å¾—ä¸¤ä¸ªå­é›†çš„å…ƒç´ å’Œç›¸ç­‰ã€‚
# é‚£ä¹ˆåªè¦æ‰¾åˆ°é›†åˆé‡Œèƒ½å¤Ÿå‡ºç° sum / 2 çš„å­é›†æ€»å’Œ,å°±ç®—æ˜¯å¯ä»¥åˆ†å‰²æˆä¸¤ä¸ªç›¸åŒå…ƒç´ å’Œå­é›†äº†ã€‚

# å³ä¸€ä¸ªå•†å“å¦‚æœå¯ä»¥é‡å¤å¤šæ¬¡æ”¾å…¥æ˜¯å®Œå…¨èƒŒåŒ…,è€Œåªèƒ½æ”¾å…¥ä¸€æ¬¡æ˜¯01èƒŒåŒ…,å†™æ³•è¿˜æ˜¯ä¸ä¸€æ ·çš„ã€‚
# è¦æ˜ç¡®æœ¬é¢˜ä¸­æˆ‘ä»¬è¦ä½¿ç”¨çš„æ˜¯01èƒŒåŒ…,å› ä¸ºå…ƒç´ æˆ‘ä»¬åªèƒ½ç”¨ä¸€æ¬¡ã€‚
# ä¸€ç»´DP
# class Solution:
#     def canPartition(self, nums: List[int]) -> bool:
#         target = sum(nums)
#         if target % 2 == 1: return False
#         target //= 2
#         # // æ€»å’Œä¸ä¼šå¤§äº20000, èƒŒåŒ…æœ€å¤§åªéœ€è¦å…¶ä¸­ä¸€åŠ, æ‰€ä»¥10001å¤§å°å°±å¯ä»¥äº†
#         dp = [0] * 10001
#         for i in range(len(nums)):
#             for j in range(target, nums[i] - 1, -1):
#                 dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])
#         return target == dp[target]
# å¡å“¥ç‰ˆ
# class Solution:
#     def canPartition(self, nums: List[int]) -> bool:
#         _sum = 0

#         # dp[i]ä¸­çš„iè¡¨ç¤ºèƒŒåŒ…å†…æ€»å’Œ
#         # é¢˜ç›®ä¸­è¯´:æ¯ä¸ªæ•°ç»„ä¸­çš„å…ƒç´ ä¸ä¼šè¶…è¿‡ 100,æ•°ç»„çš„å¤§å°ä¸ä¼šè¶…è¿‡ 200
#         # æ€»å’Œä¸ä¼šå¤§äº20000,èƒŒåŒ…æœ€å¤§åªéœ€è¦å…¶ä¸­ä¸€åŠ,æ‰€ä»¥10001å¤§å°å°±å¯ä»¥äº†
#         dp = [0] * 10001
#         for num in nums:
#             _sum += num
#         # ä¹Ÿå¯ä»¥ä½¿ç”¨å†…ç½®å‡½æ•°ä¸€æ­¥æ±‚å’Œ
#         # _sum = sum(nums)
#         if _sum % 2 == 1:
#             return False
#         target = _sum // 2

#         # å¼€å§‹ 0-1èƒŒåŒ…
#         for num in nums:
#             for j in range(target, num - 1, -1):  # æ¯ä¸€ä¸ªå…ƒç´ ä¸€å®šæ˜¯ä¸å¯é‡å¤æ”¾å…¥,æ‰€ä»¥ä»å¤§åˆ°å°éå†
#                 dp[j] = max(dp[j], dp[j - num] + num)

#         # é›†åˆä¸­çš„å…ƒç´ æ­£å¥½å¯ä»¥å‡‘æˆæ€»å’Œtarget
#         if dp[target] == target:
#             return True
#         return False
# *** ä¸€ç»´DP å¡å“¥ç‰ˆ(ç®€åŒ–ç‰ˆ)
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2 != 0:
            return False
        target = sum(nums) // 2
        dp = [0] * (target + 1)
        for num in nums:
            # å¦‚æœä½¿ç”¨ä¸€ç»´dpæ•°ç»„,ç‰©å“éå†çš„forå¾ªç¯æ”¾åœ¨å¤–å±‚,éå†èƒŒåŒ…çš„forå¾ªç¯æ”¾åœ¨å†…å±‚,ä¸”å†…å±‚forå¾ªç¯å€’åºéå†!
            for j in range(target, num-1, -1): # æ¯ä¸€ä¸ªå…ƒç´ ä¸€å®šæ˜¯ä¸å¯é‡å¤æ”¾å…¥,æ‰€ä»¥ä»å¤§åˆ°å°éå†
                dp[j] = max(dp[j], dp[j-num] + num)
        return dp[-1] == target
# äºŒç»´DPç‰ˆ
# class Solution:
#     def canPartition(self, nums: List[int]) -> bool:
        
#         total_sum = sum(nums)

#         if total_sum % 2 != 0:
#             return False

#         target_sum = total_sum // 2
#         dp = [[False] * (target_sum + 1) for _ in range(len(nums) + 1)]

#         # åˆå§‹åŒ–ç¬¬ä¸€è¡Œ(ç©ºå­é›†å¯ä»¥å¾—åˆ°å’Œä¸º0)
#         for i in range(len(nums) + 1):
#             dp[i][0] = True

#         for i in range(1, len(nums) + 1):
#             for j in range(1, target_sum + 1):
#                 if j < nums[i - 1]:
#                     # å½“å‰æ•°å­—å¤§äºç›®æ ‡å’Œæ—¶,æ— æ³•ä½¿ç”¨è¯¥æ•°å­—
#                     dp[i][j] = dp[i - 1][j]
#                 else:
#                     # å½“å‰æ•°å­—å°äºç­‰äºç›®æ ‡å’Œæ—¶,å¯ä»¥é€‰æ‹©ä½¿ç”¨æˆ–ä¸ä½¿ç”¨è¯¥æ•°å­—
#                     dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]

#         return dp[len(nums)][target_sum]
# ä¸€ç»´DPç‰ˆ
# class Solution:
#     def canPartition(self, nums: List[int]) -> bool:

#         total_sum = sum(nums)

#         if total_sum % 2 != 0:
#             return False

#         target_sum = total_sum // 2
#         dp = [False] * (target_sum + 1)
#         dp[0] = True

#         for num in nums:
#             # ä»target_sumé€†åºè¿­ä»£åˆ°num,æ­¥é•¿ä¸º-1
#             for i in range(target_sum, num - 1, -1):
#                 dp[i] = dp[i] or dp[i - num]
#         return dp[target_sum]


#11 (Medium) 1049.æœ€åä¸€å—çŸ³å¤´çš„é‡é‡II
    # æœ‰ä¸€å †çŸ³å¤´,æ¯å—çŸ³å¤´çš„é‡é‡éƒ½æ˜¯æ­£æ•´æ•°ã€‚
    # æ¯ä¸€å›åˆ,ä»ä¸­é€‰å‡ºä»»æ„ä¸¤å—çŸ³å¤´,ç„¶åå°†å®ƒä»¬ä¸€èµ·ç²‰ç¢ã€‚å‡è®¾çŸ³å¤´çš„é‡é‡åˆ†åˆ«ä¸º x å’Œ y,ä¸” x <= yã€‚é‚£ä¹ˆç²‰ç¢çš„å¯èƒ½ç»“æœå¦‚ä¸‹:
    # å¦‚æœ x == y,é‚£ä¹ˆä¸¤å—çŸ³å¤´éƒ½ä¼šè¢«å®Œå…¨ç²‰ç¢ï¼›
    # å¦‚æœ x != y,é‚£ä¹ˆé‡é‡ä¸º x çš„çŸ³å¤´å°†ä¼šå®Œå…¨ç²‰ç¢,è€Œé‡é‡ä¸º y çš„çŸ³å¤´æ–°é‡é‡ä¸º y-xã€‚
    # æœ€å,æœ€å¤šåªä¼šå‰©ä¸‹ä¸€å—çŸ³å¤´ã€‚è¿”å›æ­¤çŸ³å¤´æœ€å°çš„å¯èƒ½é‡é‡ã€‚å¦‚æœæ²¡æœ‰çŸ³å¤´å‰©ä¸‹,å°±è¿”å› 0ã€‚
    # ç¤ºä¾‹:
    # è¾“å…¥:[2,7,4,1,8,1]
    # è¾“å‡º:1
    # è§£é‡Š:
    # ç»„åˆ 2 å’Œ 4,å¾—åˆ° 2,æ‰€ä»¥æ•°ç»„è½¬åŒ–ä¸º [2,7,1,8,1],
    # ç»„åˆ 7 å’Œ 8,å¾—åˆ° 1,æ‰€ä»¥æ•°ç»„è½¬åŒ–ä¸º [2,1,1,1],
    # ç»„åˆ 2 å’Œ 1,å¾—åˆ° 1,æ‰€ä»¥æ•°ç»„è½¬åŒ–ä¸º [1,1,1],
    # ç»„åˆ 1 å’Œ 1,å¾—åˆ° 0,æ‰€ä»¥æ•°ç»„è½¬åŒ–ä¸º [1],è¿™å°±æ˜¯æœ€ä¼˜å€¼ã€‚
# æœ¬é¢˜å…¶å®å°±æ˜¯å°½é‡è®©çŸ³å¤´åˆ†æˆé‡é‡ç›¸åŒçš„ä¸¤å †,ç›¸æ’ä¹‹åå‰©ä¸‹çš„çŸ³å¤´æœ€å°,è¿™æ ·å°±åŒ–è§£æˆ01èƒŒåŒ…é—®é¢˜äº†ã€‚
# æ˜¯ä¸æ˜¯æ„Ÿè§‰å’Œæ˜¨å¤©è®²è§£çš„416. åˆ†å‰²ç­‰å’Œå­é›† (opens new window)éå¸¸åƒäº†ã€‚
# æœ¬é¢˜ç‰©å“çš„é‡é‡ä¸ºstones[i],ç‰©å“çš„ä»·å€¼ä¹Ÿä¸ºstones[i]ã€‚
# å¯¹åº”ç€01èƒŒåŒ…é‡Œçš„ç‰©å“é‡é‡weight[i]å’Œ ç‰©å“ä»·å€¼value[i]ã€‚
# å¡å“¥ç‰ˆ
# class Solution:
#     def lastStoneWeightII(self, stones: List[int]) -> int:
#         dp = [0] * 15001
#         total_sum = sum(stones)
#         target = total_sum // 2

#         for stone in stones:  # éå†ç‰©å“
#             for j in range(target, stone - 1, -1):  # éå†èƒŒåŒ…
#                 dp[j] = max(dp[j], dp[j - stone] + stone)

#         return total_sum - dp[target] - dp[target]
# å¡å“¥ç‰ˆ(ç®€åŒ–ç‰ˆ)
class Solution:
    def lastStoneWeightII(self, stones):
        total_sum = sum(stones)
        target = total_sum // 2
        dp = [0] * (target + 1)
        for stone in stones: # éå†ç‰©å“
            for j in range(target, stone - 1, -1): # éå†èƒŒåŒ…
                dp[j] = max(dp[j], dp[j - stone] + stone)
        return total_sum - 2* dp[-1]
# äºŒç»´DPç‰ˆ
# class Solution:
#     def lastStoneWeightII(self, stones: List[int]) -> int:
#         total_sum = sum(stones)
#         target = total_sum // 2
        
#         # åˆ›å»ºäºŒç»´dpæ•°ç»„,è¡Œæ•°ä¸ºçŸ³å¤´çš„æ•°é‡åŠ 1,åˆ—æ•°ä¸ºtargetåŠ 1
#         # dp[i][j]è¡¨ç¤ºå‰iä¸ªçŸ³å¤´èƒ½å¦ç»„æˆæ€»é‡é‡ä¸ºj
#         dp = [[False] * (target + 1) for _ in range(len(stones) + 1)]
        
#         # åˆå§‹åŒ–ç¬¬ä¸€åˆ—,è¡¨ç¤ºæ€»é‡é‡ä¸º0æ—¶,å‰iä¸ªçŸ³å¤´éƒ½èƒ½ç»„æˆ
#         for i in range(len(stones) + 1):
#             dp[i][0] = True
        
#         for i in range(1, len(stones) + 1):
#             for j in range(1, target + 1):
#                 # å¦‚æœå½“å‰çŸ³å¤´é‡é‡å¤§äºå½“å‰ç›®æ ‡é‡é‡j,åˆ™æ— æ³•é€‰æ‹©è¯¥çŸ³å¤´
#                 if stones[i - 1] > j:
#                     dp[i][j] = dp[i - 1][j]
#                 else:
#                     # å¯é€‰æ‹©è¯¥çŸ³å¤´æˆ–ä¸é€‰æ‹©è¯¥çŸ³å¤´
#                     dp[i][j] = dp[i - 1][j] or dp[i - 1][j - stones[i - 1]]
        
#         # æ‰¾åˆ°æœ€å¤§çš„é‡é‡i,ä½¿å¾—dp[len(stones)][i]ä¸ºTrue
#         # è¿”å›æ€»é‡é‡å‡å»ä¸¤å€çš„æœ€æ¥è¿‘æ€»é‡é‡ä¸€åŠçš„é‡é‡
#         for i in range(target, -1, -1):
#             if dp[len(stones)][i]:
#                 return total_sum - 2 * i
#         return 0
# ä¸€ç»´DPç‰ˆ
# class Solution:
#     def lastStoneWeightII(self, stones):
#         total_sum = sum(stones)
#         target = total_sum // 2
#         dp = [False] * (target + 1)
#         dp[0] = True

#         for stone in stones:
#             for j in range(target, stone - 1, -1):
#                 # åˆ¤æ–­å½“å‰é‡é‡æ˜¯å¦å¯ä»¥é€šè¿‡é€‰æ‹©ä¹‹å‰çš„çŸ³å¤´å¾—åˆ°æˆ–é€‰æ‹©å½“å‰çŸ³å¤´å’Œä¹‹å‰çš„çŸ³å¤´å¾—åˆ°
#                 dp[j] = dp[j] or dp[j - stone]

#         for i in range(target, -1, -1):
#             if dp[i]:
#                 # è¿”å›å‰©ä½™çŸ³å¤´çš„é‡é‡,å³æ€»é‡é‡å‡å»ä¸¤å€çš„æœ€æ¥è¿‘æ€»é‡é‡ä¸€åŠçš„é‡é‡
#                 return total_sum - 2 * i
#         return 0


#12 (Medium) 494.ç›®æ ‡å’Œ
    # ç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„,a1, a2, ..., an, å’Œä¸€ä¸ªç›®æ ‡æ•°,Sã€‚ç°åœ¨ä½ æœ‰ä¸¤ä¸ªç¬¦å· + å’Œ -ã€‚å¯¹äºæ•°ç»„ä¸­çš„ä»»æ„ä¸€ä¸ªæ•´æ•°,ä½ éƒ½å¯ä»¥ä» + æˆ– -ä¸­é€‰æ‹©ä¸€ä¸ªç¬¦å·æ·»åŠ åœ¨å‰é¢ã€‚
    # è¿”å›å¯ä»¥ä½¿æœ€ç»ˆæ•°ç»„å’Œä¸ºç›®æ ‡æ•° S çš„æ‰€æœ‰æ·»åŠ ç¬¦å·çš„æ–¹æ³•æ•°ã€‚
    # ç¤ºä¾‹:
    # è¾“å…¥:nums: [1, 1, 1, 1, 1], S: 3
    # è¾“å‡º:5
    # è§£é‡Š:
    # -1+1+1+1+1 = 3
    # +1-1+1+1+1 = 3
    # +1+1-1+1+1 = 3
    # +1+1+1-1+1 = 3
    # +1+1+1+1-1 = 3
    # ä¸€å…±æœ‰5ç§æ–¹æ³•è®©æœ€ç»ˆç›®æ ‡å’Œä¸º3ã€‚
# å¦‚æœä»…ä»…æ˜¯æ±‚ä¸ªæ•°çš„è¯,å°±å¯ä»¥ç”¨dp,ä½†å›æº¯ç®—æ³•:39. ç»„åˆæ€»å’Œè¦æ±‚çš„æ˜¯æŠŠæ‰€æœ‰ç»„åˆåˆ—å‡ºæ¥,è¿˜æ˜¯è¦ä½¿ç”¨å›æº¯æ³•çˆ†æœçš„ã€‚
# å¤§å®¶ä¹Ÿå¯ä»¥è®°ä½,åœ¨æ±‚è£…æ»¡èƒŒåŒ…æœ‰å‡ ç§æ–¹æ³•çš„æƒ…å†µä¸‹,é€’æ¨å…¬å¼ä¸€èˆ¬ä¸º:dp[j] += dp[j - nums[i]];
# å›æº¯ç‰ˆ
# class Solution:
#     def backtracking(self, candidates, target, total, startIndex, path, result):
#         if total == target:
#             result.append(path[:])  # å°†å½“å‰è·¯å¾„çš„å‰¯æœ¬æ·»åŠ åˆ°ç»“æœä¸­
#         # å¦‚æœ sum + candidates[i] > target,åˆ™åœæ­¢éå†
#         for i in range(startIndex, len(candidates)):
#             if total + candidates[i] > target:
#                 break
#             total += candidates[i]
#             path.append(candidates[i])
#             self.backtracking(candidates, target, total, i + 1, path, result)
#             total -= candidates[i]
#             path.pop()

#     def findTargetSumWays(self, nums: List[int], target: int) -> int:
#         total = sum(nums)
#         if target > total:
#             return 0  # æ­¤æ—¶æ²¡æœ‰æ–¹æ¡ˆ
#         if (target + total) % 2 != 0:
#             return 0  # æ­¤æ—¶æ²¡æœ‰æ–¹æ¡ˆ,ä¸¤ä¸ªæ•´æ•°ç›¸åŠ æ—¶è¦æ³¨æ„æ•°å€¼æº¢å‡ºçš„é—®é¢˜
#         bagSize = (target + total) // 2  # è½¬åŒ–ä¸ºç»„åˆæ€»å’Œé—®é¢˜,bagSizeå°±æ˜¯ç›®æ ‡å’Œ

#         # ä»¥ä¸‹æ˜¯å›æº¯æ³•ä»£ç 
#         result = []
#         nums.sort()  # éœ€è¦å¯¹numsè¿›è¡Œæ’åº
#         self.backtracking(nums, bagSize, 0, 0, [], result)
#         return len(result)
# # äºŒç»´DP
# class Solution:
#     def findTargetSumWays(self, nums: List[int], target: int) -> int:
#         total_sum = sum(nums)  # è®¡ç®—numsçš„æ€»å’Œ
#         if abs(target) > total_sum:
#             return 0  # æ­¤æ—¶æ²¡æœ‰æ–¹æ¡ˆ
#         if (target + total_sum) % 2 == 1:
#             return 0  # æ­¤æ—¶æ²¡æœ‰æ–¹æ¡ˆ
#         target_sum = (target + total_sum) // 2  # ç›®æ ‡å’Œ

#         # åˆ›å»ºäºŒç»´åŠ¨æ€è§„åˆ’æ•°ç»„,è¡Œè¡¨ç¤ºé€‰å–çš„å…ƒç´ æ•°é‡,åˆ—è¡¨ç¤ºç´¯åŠ å’Œ
#         dp = [[0] * (target_sum + 1) for _ in range(len(nums) + 1)]

#         # åˆå§‹åŒ–çŠ¶æ€
#         dp[0][0] = 1

#         # åŠ¨æ€è§„åˆ’è¿‡ç¨‹
#         for i in range(1, len(nums) + 1):
#             for j in range(target_sum + 1):
#                 dp[i][j] = dp[i - 1][j]  # ä¸é€‰å–å½“å‰å…ƒç´ 
#                 if j >= nums[i - 1]:
#                     dp[i][j] += dp[i - 1][j - nums[i - 1]]  # é€‰å–å½“å‰å…ƒç´ 

#         return dp[len(nums)][target_sum]  # è¿”å›è¾¾åˆ°ç›®æ ‡å’Œçš„æ–¹æ¡ˆæ•°
# ä¸€ç»´DP
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        total_sum = sum(nums)  # è®¡ç®—numsçš„æ€»å’Œ
        if abs(target) > total_sum:
            return 0  # æ­¤æ—¶æ²¡æœ‰æ–¹æ¡ˆ
        if (target + total_sum) % 2 == 1:
            return 0  # æ­¤æ—¶æ²¡æœ‰æ–¹æ¡ˆ
        target_sum = (target + total_sum) // 2  # ç›®æ ‡å’Œ
        dp = [0] * (target_sum + 1)  # åˆ›å»ºåŠ¨æ€è§„åˆ’æ•°ç»„,åˆå§‹åŒ–ä¸º0
        dp[0] = 1  # å½“ç›®æ ‡å’Œä¸º0æ—¶,åªæœ‰ä¸€ç§æ–¹æ¡ˆ,å³ä»€ä¹ˆéƒ½ä¸é€‰
        for num in nums:
            for j in range(target_sum, num - 1, -1):
                dp[j] += dp[j - num]  # çŠ¶æ€è½¬ç§»æ–¹ç¨‹,ç´¯åŠ ä¸åŒé€‰æ‹©æ–¹å¼çš„æ•°é‡
        return dp[target_sum]  # è¿”å›è¾¾åˆ°ç›®æ ‡å’Œçš„æ–¹æ¡ˆæ•°


#13 (Medium) 474.ä¸€å’Œé›¶
    # ç»™ä½ ä¸€ä¸ªäºŒè¿›åˆ¶å­—ç¬¦ä¸²æ•°ç»„ strs å’Œä¸¤ä¸ªæ•´æ•° m å’Œ n ã€‚
    # è¯·ä½ æ‰¾å‡ºå¹¶è¿”å› strs çš„æœ€å¤§å­é›†çš„å¤§å°,è¯¥å­é›†ä¸­ æœ€å¤š æœ‰ m ä¸ª 0 å’Œ n ä¸ª 1 ã€‚
    # ç¤ºä¾‹ 1:
    # è¾“å…¥:strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
    # è¾“å‡º:4
    # è§£é‡Š:æœ€å¤šæœ‰ 5 ä¸ª 0 å’Œ 3 ä¸ª 1 çš„æœ€å¤§å­é›†æ˜¯ {"10","0001","1","0"} ,å› æ­¤ç­”æ¡ˆæ˜¯ 4 ã€‚ å…¶ä»–æ»¡è¶³é¢˜æ„ä½†è¾ƒå°çš„å­é›†åŒ…æ‹¬ {"0001","1"} å’Œ {"10","1","0"} ã€‚{"111001"} ä¸æ»¡è¶³é¢˜æ„,å› ä¸ºå®ƒå« 4 ä¸ª 1 ,å¤§äº n çš„å€¼ 3 ã€‚
    # ç¤ºä¾‹ 2:
    # è¾“å…¥:strs = ["10", "0", "1"], m = 1, n = 1
    # è¾“å‡º:2
    # è§£é‡Š:æœ€å¤§çš„å­é›†æ˜¯ {"0", "1"} ,æ‰€ä»¥ç­”æ¡ˆæ˜¯ 2 ã€‚
# æœ¬é¢˜ä¸­strs æ•°ç»„é‡Œçš„å…ƒç´ å°±æ˜¯ç‰©å“,æ¯ä¸ªç‰©å“éƒ½æ˜¯ä¸€ä¸ª!
# è€Œm å’Œ nç›¸å½“äºæ˜¯ä¸€ä¸ªèƒŒåŒ…,ä¸¤ä¸ªç»´åº¦çš„èƒŒåŒ…ã€‚
# æœ‰åŒå­¦å¯èƒ½æƒ³,é‚£ä¸ªéå†èƒŒåŒ…å®¹é‡çš„ä¸¤å±‚forå¾ªç¯å…ˆåå¾ªåºæœ‰æ²¡æœ‰ä»€ä¹ˆè®²ç©¶ï¼Ÿ
# æ²¡è®²ç©¶,éƒ½æ˜¯ç‰©å“é‡é‡çš„ä¸€ä¸ªç»´åº¦,å…ˆéå†å“ªä¸ªéƒ½è¡Œ!
"""
# dp[i][j]:æœ€å¤šæœ‰iä¸ª0å’Œjä¸ª1çš„strsçš„æœ€å¤§å­é›†çš„å¤§å°ä¸ºdp[i][j]ã€‚
dp[i][j] å¯ä»¥ç”±å‰ä¸€ä¸ªstrsé‡Œçš„å­—ç¬¦ä¸²æ¨å¯¼å‡ºæ¥,strsé‡Œçš„å­—ç¬¦ä¸²æœ‰zeroNumä¸ª0,oneNumä¸ª1ã€‚
dp[i][j] å°±å¯ä»¥æ˜¯ dp[i - zeroNum][j - oneNum] + 1ã€‚
ç„¶åæˆ‘ä»¬åœ¨éå†çš„è¿‡ç¨‹ä¸­,å–dp[i][j]çš„æœ€å¤§å€¼ã€‚
æ‰€ä»¥é€’æ¨å…¬å¼:dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
æ­¤æ—¶å¤§å®¶å¯ä»¥å›æƒ³ä¸€ä¸‹01èƒŒåŒ…çš„é€’æ¨å…¬å¼:dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
å¯¹æ¯”ä¸€ä¸‹å°±ä¼šå‘ç°,å­—ç¬¦ä¸²çš„zeroNumå’ŒoneNumç›¸å½“äºç‰©å“çš„é‡é‡(weight[i]),å­—ç¬¦ä¸²æœ¬èº«çš„ä¸ªæ•°ç›¸å½“äºç‰©å“çš„ä»·å€¼(value[i])ã€‚
è¿™å°±æ˜¯ä¸€ä¸ªå…¸å‹çš„01èƒŒåŒ…! åªä¸è¿‡ç‰©å“çš„é‡é‡æœ‰äº†ä¸¤ä¸ªç»´åº¦è€Œå·²ã€‚
"""
# DP(ç‰ˆæœ¬ä¸€)
# class Solution:
#     def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
#         dp = [[0] * (n + 1) for _ in range(m + 1)]  # åˆ›å»ºäºŒç»´åŠ¨æ€è§„åˆ’æ•°ç»„,åˆå§‹åŒ–ä¸º0
#         for s in strs:  # éå†ç‰©å“
#             zeroNum = s.count('0')  # ç»Ÿè®¡0çš„ä¸ªæ•°
#             oneNum = len(s) - zeroNum  # ç»Ÿè®¡1çš„ä¸ªæ•°
#             for i in range(m, zeroNum - 1, -1):  # éå†èƒŒåŒ…å®¹é‡ä¸”ä»åå‘å‰éå†
#                 for j in range(n, oneNum - 1, -1):
#                     dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)  # çŠ¶æ€è½¬ç§»æ–¹ç¨‹
#         return dp[m][n]
# DP(ç‰ˆæœ¬äºŒ)
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        dp = [[0] * (n + 1) for _ in range(m + 1)]  # åˆ›å»ºäºŒç»´åŠ¨æ€è§„åˆ’æ•°ç»„,åˆå§‹åŒ–ä¸º0
        # éå†ç‰©å“,ä¸¤ä¸ª1Dæ•°ç»„,æ‰€ä»¥éœ€è¦ä»åå¾€å‰éå†
        for s in strs:
            ones = s.count('1')  # ç»Ÿè®¡å­—ç¬¦ä¸²ä¸­1çš„ä¸ªæ•°
            zeros = s.count('0')  # ç»Ÿè®¡å­—ç¬¦ä¸²ä¸­0çš„ä¸ªæ•°
            # éå†èƒŒåŒ…å®¹é‡ä¸”ä»åå‘å‰éå†
            for i in range(m, zeros - 1, -1):
                for j in range(n, ones - 1, -1):
                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)  # çŠ¶æ€è½¬ç§»æ–¹ç¨‹
        return dp[m][n]


#14 åŠ¨æ€è§„åˆ’:å®Œå…¨èƒŒåŒ…ç†è®ºåŸºç¡€
    # æˆ‘ä»¬çŸ¥é“01èƒŒåŒ…å†…åµŒ1Dçš„å¾ªç¯æ˜¯ä»å¤§åˆ°å°éå†,ä¸ºäº†ä¿è¯æ¯ä¸ªç‰©å“ä»…è¢«æ·»åŠ ä¸€æ¬¡ã€‚
    # è€Œå®Œå…¨èƒŒåŒ…çš„ç‰©å“æ˜¯å¯ä»¥æ·»åŠ å¤šæ¬¡çš„,æ‰€ä»¥è¦ä»å°åˆ°å¤§å»éå†
    # 01èƒŒåŒ…ä¸­äºŒç»´dpæ•°ç»„çš„ä¸¤ä¸ªforéå†çš„å…ˆåå¾ªåºæ˜¯å¯ä»¥é¢ å€’äº†
    # ä¸€ç»´dpæ•°ç»„çš„ä¸¤ä¸ªforå¾ªç¯å…ˆåå¾ªåºä¸€å®šæ˜¯å…ˆéå†ç‰©å“,å†éå†èƒŒåŒ…å®¹é‡ã€‚
    # åœ¨å®Œå…¨èƒŒåŒ…ä¸­,å¯¹äºä¸€ç»´dpæ•°ç»„æ¥è¯´,å…¶å®ä¸¤ä¸ªforå¾ªç¯åµŒå¥—é¡ºåºæ˜¯æ— æ‰€è°“çš„!
# å…ˆéå†ç‰©å“,å†éå†èƒŒåŒ…(æ— å‚ç‰ˆ)
def test_CompletePack():
    weight = [1, 3, 4]
    value = [15, 20, 30]
    bagWeight = 4
    dp = [0] * (bagWeight + 1)
    for i in range(len(weight)):  # éå†ç‰©å“
        for j in range(weight[i], bagWeight + 1):  # éå†èƒŒåŒ…å®¹é‡
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
    print(dp[bagWeight])

test_CompletePack()
# å…ˆéå†ç‰©å“,å†éå†èƒŒåŒ…(æœ‰å‚ç‰ˆ)
def test_CompletePack(weight, value, bagWeight):
    dp = [0] * (bagWeight + 1)
    for i in range(len(weight)):  # éå†ç‰©å“
        for j in range(weight[i], bagWeight + 1):  # éå†èƒŒåŒ…å®¹é‡
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
    return dp[bagWeight]

if __name__ == "__main__":
    weight = [1, 3, 4]
    value = [15, 20, 30]
    bagWeight = 4
    result = test_CompletePack(weight, value, bagWeight)
    print(result)
# å…ˆéå†èƒŒåŒ…,å†éå†ç‰©å“(æ— å‚ç‰ˆ)
def test_CompletePack():
    weight = [1, 3, 4]
    value = [15, 20, 30]
    bagWeight = 4

    dp = [0] * (bagWeight + 1)

    for j in range(bagWeight + 1):  # éå†èƒŒåŒ…å®¹é‡
        for i in range(len(weight)):  # éå†ç‰©å“
            if j - weight[i] >= 0:
                dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

    print(dp[bagWeight])

test_CompletePack()
# å…ˆéå†èƒŒåŒ…,å†éå†ç‰©å“(æœ‰å‚ç‰ˆ)
def test_CompletePack(weight, value, bagWeight):
    dp = [0] * (bagWeight + 1)
    for j in range(bagWeight + 1):  # éå†èƒŒåŒ…å®¹é‡
        for i in range(len(weight)):  # éå†ç‰©å“
            if j - weight[i] >= 0:
                dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
    return dp[bagWeight]


if __name__ == "__main__":
    weight = [1, 3, 4]
    value = [15, 20, 30]
    bagWeight = 4
    result = test_CompletePack(weight, value, bagWeight)
    print(result)


#15 (Medium) 518.é›¶é’±å…‘æ¢II
    # ç»™å®šä¸åŒé¢é¢çš„ç¡¬å¸å’Œä¸€ä¸ªæ€»é‡‘é¢ã€‚å†™å‡ºå‡½æ•°æ¥è®¡ç®—å¯ä»¥å‡‘æˆæ€»é‡‘é¢çš„ç¡¬å¸ç»„åˆæ•°ã€‚å‡è®¾æ¯ä¸€ç§é¢é¢çš„ç¡¬å¸æœ‰æ— é™ä¸ªã€‚
    # ç¤ºä¾‹ 1:
    # è¾“å…¥: amount = 5, coins = [1, 2, 5]
    # è¾“å‡º: 4
    # è§£é‡Š: æœ‰å››ç§æ–¹å¼å¯ä»¥å‡‘æˆæ€»é‡‘é¢:
    # 5=5
    # 5=2+2+1
    # 5=2+1+1+1
    # 5=1+1+1+1+1
    # ç¤ºä¾‹ 2:
    # è¾“å…¥: amount = 3, coins = [2]
    # è¾“å‡º: 0
    # è§£é‡Š: åªç”¨é¢é¢2çš„ç¡¬å¸ä¸èƒ½å‡‘æˆæ€»é‡‘é¢3ã€‚
    # ç¤ºä¾‹ 3:
    # è¾“å…¥: amount = 10, coins = [10]
    # è¾“å‡º: 1
# è¿™æ˜¯ä¸€é“å…¸å‹çš„èƒŒåŒ…é—®é¢˜,ä¸€çœ‹åˆ°é’±å¸æ•°é‡ä¸é™,å°±çŸ¥é“è¿™æ˜¯ä¸€ä¸ªå®Œå…¨èƒŒåŒ…ã€‚
# ä½†æœ¬é¢˜å’Œçº¯å®Œå…¨èƒŒåŒ…ä¸ä¸€æ ·,çº¯å®Œå…¨èƒŒåŒ…æ˜¯å‡‘æˆèƒŒåŒ…æœ€å¤§ä»·å€¼æ˜¯å¤šå°‘,è€Œæœ¬é¢˜æ˜¯è¦æ±‚å‡‘æˆæ€»é‡‘é¢çš„ç‰©å“ç»„åˆä¸ªæ•°ï¼
# ç»„åˆä¸å¼ºè°ƒå…ƒç´ ä¹‹é—´çš„é¡ºåº,æ’åˆ—å¼ºè°ƒå…ƒç´ ä¹‹é—´çš„é¡ºåºã€‚
# dp[j] å°±æ˜¯æ‰€æœ‰çš„dp[j - coins[i]](è€ƒè™‘coins[i]çš„æƒ…å†µ)ç›¸åŠ ã€‚
# æ‰€ä»¥é€’æ¨å…¬å¼:dp[j] += dp[j - coins[i]];
# è¿™ä¸ªé€’æ¨å…¬å¼å¤§å®¶åº”è¯¥ä¸é™Œç”Ÿäº†,æˆ‘åœ¨è®²è§£01èƒŒåŒ…é¢˜ç›®çš„æ—¶å€™åœ¨è¿™ç¯‡494. 
# ç›®æ ‡å’Œä¸­å°±è®²è§£äº†,æ±‚è£…æ»¡èƒŒåŒ…æœ‰å‡ ç§æ–¹æ³•,å…¬å¼éƒ½æ˜¯:dp[j] += dp[j - nums[i]];

# æˆ‘åœ¨åŠ¨æ€è§„åˆ’:å…³äºå®Œå…¨èƒŒåŒ…,ä½ è¯¥äº†è§£è¿™äº›ï¼ä¸­è®²è§£äº†å®Œå…¨èƒŒåŒ…çš„ä¸¤ä¸ªforå¾ªç¯çš„å…ˆåé¡ºåºéƒ½æ˜¯å¯ä»¥çš„ã€‚
# ä½†æœ¬é¢˜å°±ä¸è¡Œäº†ï¼
# å› ä¸ºçº¯å®Œå…¨èƒŒåŒ…æ±‚å¾—è£…æ»¡èƒŒåŒ…çš„æœ€å¤§ä»·å€¼æ˜¯å¤šå°‘,å’Œå‡‘æˆæ€»å’Œçš„å…ƒç´ æœ‰æ²¡æœ‰é¡ºåºæ²¡å…³ç³»,å³:æœ‰é¡ºåºä¹Ÿè¡Œ,æ²¡æœ‰é¡ºåºä¹Ÿè¡Œï¼
# è€Œæœ¬é¢˜è¦æ±‚å‡‘æˆæ€»å’Œçš„ç»„åˆæ•°,å…ƒç´ ä¹‹é—´æ˜ç¡®è¦æ±‚æ²¡æœ‰é¡ºåºã€‚
# æ‰€ä»¥çº¯å®Œå…¨èƒŒåŒ…æ˜¯èƒ½å‡‘æˆæ€»å’Œå°±è¡Œ,ä¸ç”¨ç®¡æ€ä¹ˆå‡‘çš„ã€‚
# æœ¬é¢˜æ˜¯æ±‚å‡‘å‡ºæ¥çš„æ–¹æ¡ˆä¸ªæ•°,ä¸”æ¯ä¸ªæ–¹æ¡ˆä¸ªæ•°æ˜¯ä¸ºç»„åˆæ•°ã€‚

# æˆ‘ä»¬å…ˆæ¥çœ‹ å¤–å±‚forå¾ªç¯éå†ç‰©å“(é’±å¸),å†…å±‚foréå†èƒŒåŒ…(é‡‘é’±æ€»é¢)çš„æƒ…å†µã€‚
# å‡è®¾:coins[0] = 1,coins[1] = 5ã€‚
# é‚£ä¹ˆå°±æ˜¯å…ˆæŠŠ1åŠ å…¥è®¡ç®—,ç„¶åå†æŠŠ5åŠ å…¥è®¡ç®—,å¾—åˆ°çš„æ–¹æ³•æ•°é‡åªæœ‰{1, 5}è¿™ç§æƒ…å†µã€‚è€Œä¸ä¼šå‡ºç°{5, 1}çš„æƒ…å†µã€‚
# æ‰€ä»¥è¿™ç§éå†é¡ºåºä¸­dp[j]é‡Œè®¡ç®—çš„æ˜¯ç»„åˆæ•°ï¼
# å¦‚æœæŠŠä¸¤ä¸ªforäº¤æ¢é¡ºåº
# èƒŒåŒ…å®¹é‡çš„æ¯ä¸€ä¸ªå€¼,éƒ½æ˜¯ç»è¿‡ 1 å’Œ 5 çš„è®¡ç®—,åŒ…å«äº†{1, 5} å’Œ {5, 1}ä¸¤ç§æƒ…å†µã€‚

# åœ¨æ±‚è£…æ»¡èƒŒåŒ…æœ‰å‡ ç§æ–¹æ¡ˆçš„æ—¶å€™,è®¤æ¸…éå†é¡ºåºæ˜¯éå¸¸å…³é”®çš„ã€‚
# å¦‚æœæ±‚ç»„åˆæ•°å°±æ˜¯å¤–å±‚forå¾ªç¯éå†ç‰©å“,å†…å±‚foréå†èƒŒåŒ…ã€‚
# å¦‚æœæ±‚æ’åˆ—æ•°å°±æ˜¯å¤–å±‚foréå†èƒŒåŒ…,å†…å±‚forå¾ªç¯éå†ç‰©å“ã€‚
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [0]*(amount + 1)
        dp[0] = 1
        # éå†ç‰©å“
        for i in range(len(coins)):
            # éå†èƒŒåŒ…
            for j in range(coins[i], amount + 1):
                dp[j] += dp[j - coins[i]]
        return dp[amount]


#16 (Medium) 377.ç»„åˆæ€»å’Œ â…£
    # ç»™å®šä¸€ä¸ªç”±æ­£æ•´æ•°ç»„æˆä¸”ä¸å­˜åœ¨é‡å¤æ•°å­—çš„æ•°ç»„ï¼Œæ‰¾å‡ºå’Œä¸ºç»™å®šç›®æ ‡æ­£æ•´æ•°çš„ç»„åˆçš„ä¸ªæ•°ã€‚
    # ç¤ºä¾‹:
    # nums = [1, 2, 3]
    # target = 4
    # æ‰€æœ‰å¯èƒ½çš„ç»„åˆä¸ºï¼š (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)
    # è¯·æ³¨æ„ï¼Œé¡ºåºä¸åŒçš„åºåˆ—è¢«è§†ä½œä¸åŒçš„ç»„åˆã€‚
    # å› æ­¤è¾“å‡ºä¸º 7ã€‚
# å¦‚æœæŠŠéå†nums(ç‰©å“)æ”¾åœ¨å¤–å¾ªç¯,éå†targetçš„ä½œä¸ºå†…å¾ªç¯çš„è¯
# ä¸¾ä¸€ä¸ªä¾‹å­:è®¡ç®—dp[4]çš„æ—¶å€™,ç»“æœé›†åªæœ‰ {1,3} è¿™æ ·çš„é›†åˆ,ä¸ä¼šæœ‰{3,1}è¿™æ ·çš„é›†åˆ
# å› ä¸ºnumséå†æ”¾åœ¨å¤–å±‚,3åªèƒ½å‡ºç°åœ¨1åé¢!
# æ‰€ä»¥æœ¬é¢˜éå†é¡ºåºæœ€ç»ˆéå†é¡ºåº:target(èƒŒåŒ…)æ”¾åœ¨å¤–å¾ªç¯,å°†nums(ç‰©å“)æ”¾åœ¨å†…å¾ªç¯,å†…å¾ªç¯ä»å‰åˆ°åéå†ã€‚
# å¡å“¥ç‰ˆ
# class Solution:
#     def combinationSum4(self, nums: List[int], target: int) -> int:
#         dp = [0] * (target + 1)
#         dp[0] = 1
#         for i in range(1, target + 1):  # éå†èƒŒåŒ…
#             for j in range(len(nums)):  # éå†ç‰©å“
#                 if i - nums[j] >= 0:
#                     dp[i] += dp[i - nums[j]]
#         return dp[target]
# ä¼˜åŒ–ç‰ˆ
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        dp = [0] * (target + 1)  # åˆ›å»ºåŠ¨æ€è§„åˆ’æ•°ç»„,ç”¨äºå­˜å‚¨ç»„åˆæ€»æ•°
        dp[0] = 1  # åˆå§‹åŒ–èƒŒåŒ…å®¹é‡ä¸º0æ—¶çš„ç»„åˆæ€»æ•°ä¸º1

        for i in range(1, target + 1):  # éå†èƒŒåŒ…å®¹é‡
            for j in nums:  # éå†ç‰©å“åˆ—è¡¨
                if i >= j:  # å½“èƒŒåŒ…å®¹é‡å¤§äºç­‰äºå½“å‰ç‰©å“é‡é‡æ—¶
                    dp[i] += dp[i - j]  # æ›´æ–°ç»„åˆæ€»æ•°

        return dp[-1]  # è¿”å›èƒŒåŒ…å®¹é‡ä¸ºtargetæ—¶çš„ç»„åˆæ€»æ•°


#17 (Easy) 70.çˆ¬æ¥¼æ¢¯(è¿›é˜¶ç‰ˆ)
# å‡è®¾ä½ æ­£åœ¨çˆ¬æ¥¼æ¢¯ã€‚éœ€è¦ n é˜¶ä½ æ‰èƒ½åˆ°è¾¾æ¥¼é¡¶ã€‚
# æ¯æ¬¡ä½ å¯ä»¥çˆ¬è‡³å¤šm (1 <= m < n)ä¸ªå°é˜¶ã€‚ä½ æœ‰å¤šå°‘ç§ä¸åŒçš„æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶å‘¢ï¼Ÿ
# æ³¨æ„:ç»™å®š n æ˜¯ä¸€ä¸ªæ­£æ•´æ•°ã€‚
# è¾“å…¥æè¿°:è¾“å…¥å…±ä¸€è¡Œ,åŒ…å«ä¸¤ä¸ªæ­£æ•´æ•°,åˆ†åˆ«è¡¨ç¤ºn, m
# è¾“å‡ºæè¿°:è¾“å‡ºä¸€ä¸ªæ•´æ•°,è¡¨ç¤ºçˆ¬åˆ°æ¥¼é¡¶çš„æ–¹æ³•æ•°ã€‚
# è¾“å…¥ç¤ºä¾‹:3 2
# è¾“å‡ºç¤ºä¾‹:3
# æç¤º:
# å½“ m = 2,n = 3 æ—¶,n = 3 è¿™è¡¨ç¤ºä¸€å…±æœ‰ä¸‰ä¸ªå°é˜¶,m = 2 ä»£è¡¨ä½ æ¯æ¬¡å¯ä»¥çˆ¬ä¸€ä¸ªå°é˜¶æˆ–è€…ä¸¤ä¸ªå°é˜¶ã€‚
# æ­¤æ—¶ä½ æœ‰ä¸‰ç§æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶ã€‚
# 1 é˜¶ + 1 é˜¶ + 1 é˜¶æ®µ
# 1 é˜¶ + 2 é˜¶
# 2 é˜¶ + 1 é˜¶
# æ—¶é—´å¤æ‚åº¦: O(n * m)
# ç©ºé—´å¤æ‚åº¦: O(n)
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) { // éå†èƒŒåŒ…
            for (int j = 1; j <= m; j++) { // éå†ç‰©å“
                if (i - j >= 0) dp[i] += dp[i - j];
            }
        }
        return dp[n];
    }
};


#18 (Medium) 322.é›¶é’±å…‘æ¢
    # ç»™å®šä¸åŒé¢é¢çš„ç¡¬å¸ coins å’Œä¸€ä¸ªæ€»é‡‘é¢ amountã€‚ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥è®¡ç®—å¯ä»¥å‡‘æˆæ€»é‡‘é¢æ‰€éœ€çš„æœ€å°‘çš„ç¡¬å¸ä¸ªæ•°ã€‚å¦‚æœæ²¡æœ‰ä»»ä½•ä¸€ç§ç¡¬å¸ç»„åˆèƒ½ç»„æˆæ€»é‡‘é¢ï¼Œè¿”å› -1ã€‚
    # ä½ å¯ä»¥è®¤ä¸ºæ¯ç§ç¡¬å¸çš„æ•°é‡æ˜¯æ— é™çš„ã€‚
    # ç¤ºä¾‹ 1ï¼š
    # è¾“å…¥ï¼šcoins = [1, 2, 5], amount = 11
    # è¾“å‡ºï¼š3
    # è§£é‡Šï¼š11 = 5 + 5 + 1
    # ç¤ºä¾‹ 2ï¼š
    # è¾“å…¥ï¼šcoins = [2], amount = 3
    # è¾“å‡ºï¼š-1
    # ç¤ºä¾‹ 3ï¼š
    # è¾“å…¥ï¼šcoins = [1], amount = 0
    # è¾“å‡ºï¼š0
    # ç¤ºä¾‹ 4ï¼š
    # è¾“å…¥ï¼šcoins = [1], amount = 1
    # è¾“å‡ºï¼š1
    # ç¤ºä¾‹ 5ï¼š
    # è¾“å…¥ï¼šcoins = [1], amount = 2
    # è¾“å‡ºï¼š2
# æœ¬é¢˜æ±‚é’±å¸æœ€å°ä¸ªæ•°ï¼Œé‚£ä¹ˆé’±å¸æœ‰é¡ºåºå’Œæ²¡æœ‰é¡ºåºéƒ½å¯ä»¥ï¼Œéƒ½ä¸å½±å“é’±å¸çš„æœ€å°ä¸ªæ•°ã€‚
# æ‰€ä»¥æœ¬é¢˜å¹¶ä¸å¼ºè°ƒé›†åˆæ˜¯ç»„åˆè¿˜æ˜¯æ’åˆ—ã€‚
# å¦‚æœæ±‚ç»„åˆæ•°å°±æ˜¯å¤–å±‚forå¾ªç¯éå†ç‰©å“ï¼Œå†…å±‚foréå†èƒŒåŒ…ã€‚
# å¦‚æœæ±‚æ’åˆ—æ•°å°±æ˜¯å¤–å±‚foréå†èƒŒåŒ…ï¼Œå†…å±‚forå¾ªç¯éå†ç‰©å“ã€‚
# åœ¨åŠ¨æ€è§„åˆ’ä¸“é¢˜æˆ‘ä»¬è®²è¿‡äº†æ±‚ç»„åˆæ•°æ˜¯åŠ¨æ€è§„åˆ’ï¼š518.é›¶é’±å…‘æ¢IIï¼Œæ±‚æ’åˆ—æ•°æ˜¯åŠ¨æ€è§„åˆ’ï¼š377. ç»„åˆæ€»å’Œ â…£ã€‚
# æœ¬é¢˜çš„ä¸¤ä¸ªforå¾ªç¯çš„å…³ç³»æ˜¯ï¼šå¤–å±‚forå¾ªç¯éå†ç‰©å“ï¼Œå†…å±‚foréå†èƒŒåŒ…æˆ–è€…å¤–å±‚foréå†èƒŒåŒ…ï¼Œå†…å±‚forå¾ªç¯éå†ç‰©å“éƒ½æ˜¯å¯ä»¥çš„ï¼
# å…ˆéå†ç‰©å“ åéå†èƒŒåŒ…
# class Solution:
#     def coinChange(self, coins: List[int], amount: int) -> int:
#         dp = [float('inf')] * (amount + 1)  # åˆ›å»ºåŠ¨æ€è§„åˆ’æ•°ç»„,åˆå§‹å€¼ä¸ºæ­£æ— ç©·å¤§
#         dp[0] = 0  # åˆå§‹åŒ–èƒŒåŒ…å®¹é‡ä¸º0æ—¶çš„æœ€å°ç¡¬å¸æ•°é‡ä¸º0

#         for coin in coins:  # éå†ç¡¬å¸åˆ—è¡¨,ç›¸å½“äºéå†ç‰©å“
#             for i in range(coin, amount + 1):  # éå†èƒŒåŒ…å®¹é‡
#                 if dp[i - coin] != float('inf'):  # å¦‚æœdp[i - coin]ä¸æ˜¯åˆå§‹å€¼,åˆ™è¿›è¡ŒçŠ¶æ€è½¬ç§»
#                     dp[i] = min(dp[i - coin] + 1, dp[i])  # æ›´æ–°æœ€å°ç¡¬å¸æ•°é‡

#         if dp[amount] == float('inf'):  # å¦‚æœæœ€ç»ˆèƒŒåŒ…å®¹é‡çš„æœ€å°ç¡¬å¸æ•°é‡ä»ä¸ºæ­£æ— ç©·å¤§,è¡¨ç¤ºæ— è§£
#             return -1
#         return dp[amount]  # è¿”å›èƒŒåŒ…å®¹é‡ä¸ºamountæ—¶çš„æœ€å°ç¡¬å¸æ•°é‡
# å…ˆéå†èƒŒåŒ… åéå†ç‰©å“
# class Solution:
#     def coinChange(self, coins: List[int], amount: int) -> int:
#         dp = [float('inf')] * (amount + 1)  # åˆ›å»ºåŠ¨æ€è§„åˆ’æ•°ç»„,åˆå§‹å€¼ä¸ºæ­£æ— ç©·å¤§
#         dp[0] = 0  # åˆå§‹åŒ–èƒŒåŒ…å®¹é‡ä¸º0æ—¶çš„æœ€å°ç¡¬å¸æ•°é‡ä¸º0

#         for i in range(1, amount + 1):  # éå†èƒŒåŒ…å®¹é‡
#             for j in range(len(coins)):  # éå†ç¡¬å¸åˆ—è¡¨,ç›¸å½“äºéå†ç‰©å“
#                 if i - coins[j] >= 0 and dp[i - coins[j]] != float('inf'):  # å¦‚æœdp[i - coins[j]]ä¸æ˜¯åˆå§‹å€¼,åˆ™è¿›è¡ŒçŠ¶æ€è½¬ç§»
#                     dp[i] = min(dp[i - coins[j]] + 1, dp[i])  # æ›´æ–°æœ€å°ç¡¬å¸æ•°é‡

#         if dp[amount] == float('inf'):  # å¦‚æœæœ€ç»ˆèƒŒåŒ…å®¹é‡çš„æœ€å°ç¡¬å¸æ•°é‡ä»ä¸ºæ­£æ— ç©·å¤§,è¡¨ç¤ºæ— è§£
#             return -1
#         return dp[amount]  # è¿”å›èƒŒåŒ…å®¹é‡ä¸ºamountæ—¶çš„æœ€å°ç¡¬å¸æ•°é‡
# å…ˆéå†ç‰©å“ åéå†èƒŒåŒ…(ä¼˜åŒ–ç‰ˆ)
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0

        for coin in coins:
            for i in range(coin, amount + 1): # è¿›è¡Œä¼˜åŒ–,ä»èƒ½è£…å¾—ä¸‹çš„èƒŒåŒ…å¼€å§‹è®¡ç®—,åˆ™ä¸éœ€è¦è¿›è¡Œæ¯”è¾ƒ
                # æ›´æ–°å‡‘æˆé‡‘é¢ i æ‰€éœ€çš„æœ€å°‘ç¡¬å¸æ•°é‡
                dp[i] = min(dp[i], dp[i - coin] + 1)

        return dp[amount] if dp[amount] != float('inf') else -1
# å…ˆéå†èƒŒåŒ… åéå†ç‰©å“(ä¼˜åŒ–ç‰ˆ)
# class Solution:
#     def coinChange(self, coins: List[int], amount: int) -> int:
#         dp = [float('inf')] * (amount + 1)
#         dp[0] = 0

#         for i in range(1, amount + 1):  # éå†èƒŒåŒ…å®¹é‡
#             for coin in coins:  # éå†ç‰©å“
#                 if i - coin >= 0:
#                     # æ›´æ–°å‡‘æˆé‡‘é¢ i æ‰€éœ€çš„æœ€å°‘ç¡¬å¸æ•°é‡
#                     dp[i] = min(dp[i], dp[i - coin] + 1)
#         return dp[amount] if dp[amount] != float('inf') else -1


#19 (Medium) 279.å®Œå…¨å¹³æ–¹æ•°
    # ç»™å®šæ­£æ•´æ•° nï¼Œæ‰¾åˆ°è‹¥å¹²ä¸ªå®Œå…¨å¹³æ–¹æ•°ï¼ˆæ¯”å¦‚ 1, 4, 9, 16, ...ï¼‰ä½¿å¾—å®ƒä»¬çš„å’Œç­‰äº nã€‚ä½ éœ€è¦è®©ç»„æˆå’Œçš„å®Œå…¨å¹³æ–¹æ•°çš„ä¸ªæ•°æœ€å°‘ã€‚
    # ç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œè¿”å›å’Œä¸º n çš„å®Œå…¨å¹³æ–¹æ•°çš„ æœ€å°‘æ•°é‡ ã€‚
    # å®Œå…¨å¹³æ–¹æ•° æ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œå…¶å€¼ç­‰äºå¦ä¸€ä¸ªæ•´æ•°çš„å¹³æ–¹ï¼›æ¢å¥è¯è¯´ï¼Œå…¶å€¼ç­‰äºä¸€ä¸ªæ•´æ•°è‡ªä¹˜çš„ç§¯ã€‚ä¾‹å¦‚ï¼Œ1ã€4ã€9 å’Œ 16 éƒ½æ˜¯å®Œå…¨å¹³æ–¹æ•°ï¼Œè€Œ 3 å’Œ 11 ä¸æ˜¯ã€‚
    # ç¤ºä¾‹ 1ï¼š
    # è¾“å…¥ï¼šn = 12
    # è¾“å‡ºï¼š3
    # è§£é‡Šï¼š12 = 4 + 4 + 4
    # ç¤ºä¾‹ 2ï¼š
    # è¾“å…¥ï¼šn = 13
    # è¾“å‡ºï¼š2
    # è§£é‡Šï¼š13 = 4 + 9
# åœ¨åŠ¨æ€è§„åˆ’ï¼š322. é›¶é’±å…‘æ¢ä¸­æˆ‘ä»¬å°±æ·±å…¥æ¢è®¨äº†è¿™ä¸ªé—®é¢˜ï¼Œæœ¬é¢˜ä¹Ÿæ˜¯ä¸€æ ·çš„ï¼Œæ˜¯æ±‚æœ€å°æ•°ï¼
# æ‰€ä»¥æœ¬é¢˜å¤–å±‚foréå†èƒŒåŒ…ï¼Œå†…å±‚foréå†ç‰©å“ï¼Œè¿˜æ˜¯å¤–å±‚foréå†ç‰©å“ï¼Œå†…å±‚foréå†èƒŒåŒ…ï¼Œéƒ½æ˜¯å¯ä»¥çš„ï¼
# å…ˆéå†èƒŒåŒ…, å†éå†ç‰©å“
# class Solution:
#     def numSquares(self, n: int) -> int:
#         dp = [float('inf')] * (n + 1)
#         dp[0] = 0

#         for i in range(1, n + 1):  # éå†èƒŒåŒ…
#             for j in range(1, int(i ** 0.5) + 1):  # éå†ç‰©å“
#                 # æ›´æ–°å‡‘æˆæ•°å­— i æ‰€éœ€çš„æœ€å°‘å®Œå…¨å¹³æ–¹æ•°æ•°é‡
#                 dp[i] = min(dp[i], dp[i - j * j] + 1)

#         return dp[n]
# å…ˆéå†ç‰©å“, å†éå†èƒŒåŒ…
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [float('inf')] * (n + 1)
        dp[0] = 0

        for i in range(1, int(n ** 0.5) + 1):  # éå†ç‰©å“
            for j in range(i * i, n + 1):  # éå†èƒŒåŒ…
                # æ›´æ–°å‡‘æˆæ•°å­— j æ‰€éœ€çš„æœ€å°‘å®Œå…¨å¹³æ–¹æ•°æ•°é‡
                dp[j] = min(dp[j - i * i] + 1, dp[j])

        return dp[n]
# å…¶ä»–ç‰ˆæœ¬
# class Solution:
#     def numSquares(self, n: int) -> int:
#         # åˆ›å»ºåŠ¨æ€è§„åˆ’æ•°ç»„,åˆå§‹å€¼ä¸ºæœ€å¤§å€¼
#         dp = [float('inf')] * (n + 1)
#         # åˆå§‹åŒ–å·²çŸ¥æƒ…å†µ
#         dp[0] = 0

#         # éå†èƒŒåŒ…å®¹é‡
#         for i in range(1, n + 1):
#             # éå†å®Œå…¨å¹³æ–¹æ•°ä½œä¸ºç‰©å“
#             j = 1
#             while j * j <= i:
#                 # æ›´æ–°æœ€å°‘å®Œå…¨å¹³æ–¹æ•°çš„æ•°é‡
#                 dp[i] = min(dp[i], dp[i - j * j] + 1)
#                 j += 1

#         # è¿”å›ç»“æœ
#         return dp[n]


#20 ??? (Medium) 139.å•è¯æ‹†åˆ†
    # ç»™å®šä¸€ä¸ªéç©ºå­—ç¬¦ä¸² s å’Œä¸€ä¸ªåŒ…å«éç©ºå•è¯çš„åˆ—è¡¨ wordDictï¼Œåˆ¤å®š s æ˜¯å¦å¯ä»¥è¢«ç©ºæ ¼æ‹†åˆ†ä¸ºä¸€ä¸ªæˆ–å¤šä¸ªåœ¨å­—å…¸ä¸­å‡ºç°çš„å•è¯ã€‚
    # è¯´æ˜ï¼š
    # æ‹†åˆ†æ—¶å¯ä»¥é‡å¤ä½¿ç”¨å­—å…¸ä¸­çš„å•è¯ã€‚
    # ä½ å¯ä»¥å‡è®¾å­—å…¸ä¸­æ²¡æœ‰é‡å¤çš„å•è¯ã€‚
    # ç¤ºä¾‹ 1ï¼š
    # è¾“å…¥: s = "leetcode", wordDict = ["leet", "code"]
    # è¾“å‡º: true
    # è§£é‡Š: è¿”å› true å› ä¸º "leetcode" å¯ä»¥è¢«æ‹†åˆ†æˆ "leet code"ã€‚
    # ç¤ºä¾‹ 2ï¼š
    # è¾“å…¥: s = "applepenapple", wordDict = ["apple", "pen"]
    # è¾“å‡º: true
    # è§£é‡Š: è¿”å› true å› ä¸º "applepenapple" å¯ä»¥è¢«æ‹†åˆ†æˆ "apple pen apple"ã€‚
    # æ³¨æ„ä½ å¯ä»¥é‡å¤ä½¿ç”¨å­—å…¸ä¸­çš„å•è¯ã€‚
    # ç¤ºä¾‹ 3ï¼š
    # è¾“å…¥: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
    # è¾“å‡º: false
# dp[i] : å­—ç¬¦ä¸²é•¿åº¦ä¸ºiçš„è¯ï¼Œdp[i]ä¸ºtrueï¼Œè¡¨ç¤ºå¯ä»¥æ‹†åˆ†ä¸ºä¸€ä¸ªæˆ–å¤šä¸ªåœ¨å­—å…¸ä¸­å‡ºç°çš„å•è¯ã€‚
# å¦‚æœç¡®å®šdp[j] æ˜¯trueï¼Œä¸” [j, i] è¿™ä¸ªåŒºé—´çš„å­ä¸²å‡ºç°åœ¨å­—å…¸é‡Œï¼Œé‚£ä¹ˆdp[i]ä¸€å®šæ˜¯trueã€‚ï¼ˆj < i ï¼‰ã€‚
# æ‰€ä»¥é€’æ¨å…¬å¼æ˜¯ if([j, i] è¿™ä¸ªåŒºé—´çš„å­ä¸²å‡ºç°åœ¨å­—å…¸é‡Œ && dp[j]æ˜¯true) é‚£ä¹ˆ dp[i] = trueã€‚
# æœ¬é¢˜å…¶å®æˆ‘ä»¬æ±‚çš„æ˜¯æ’åˆ—æ•°ï¼Œä¸ºä»€ä¹ˆå‘¢ã€‚ æ‹¿ s = "applepenapple", wordDict = ["apple", "pen"] ä¸¾ä¾‹ã€‚
# "apple", "pen" æ˜¯ç‰©å“ï¼Œé‚£ä¹ˆæˆ‘ä»¬è¦æ±‚ ç‰©å“çš„ç»„åˆä¸€å®šæ˜¯ "apple" + "pen" + "apple" æ‰èƒ½ç»„æˆ "applepenapple"ã€‚
# "apple" + "apple" + "pen" æˆ–è€… "pen" + "apple" + "apple" æ˜¯ä¸å¯ä»¥çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æ˜¯å¼ºè°ƒç‰©å“ä¹‹é—´é¡ºåºã€‚
# æ‰€ä»¥è¯´ï¼Œæœ¬é¢˜ä¸€å®šæ˜¯ å…ˆéå† èƒŒåŒ…ï¼Œå†éå†ç‰©å“ã€‚

# æ±‚ç»„åˆæ•°:åŠ¨æ€è§„åˆ’:518.é›¶é’±å…‘æ¢II 
# æ±‚æ’åˆ—æ•°:åŠ¨æ€è§„åˆ’:377. ç»„åˆæ€»å’Œ â…£ ã€åŠ¨æ€è§„åˆ’:70. çˆ¬æ¥¼æ¢¯è¿›é˜¶ç‰ˆ(å®Œå…¨èƒŒåŒ…) 
# æ±‚æœ€å°æ•°:åŠ¨æ€è§„åˆ’:322. é›¶é’±å…‘æ¢ ã€åŠ¨æ€è§„åˆ’:279.å®Œå…¨å¹³æ–¹æ•°
# å›æº¯
# class Solution:
#     def backtracking(self, s: str, wordSet: set[str], startIndex: int) -> bool:
#         # è¾¹ç•Œæƒ…å†µ:å·²ç»éå†åˆ°å­—ç¬¦ä¸²æœ«å°¾,è¿”å›True
#         if startIndex >= len(s):
#             return True

#         # éå†æ‰€æœ‰å¯èƒ½çš„æ‹†åˆ†ä½ç½®
#         for i in range(startIndex, len(s)):
#             word = s[startIndex:i + 1]  # æˆªå–å­ä¸²
#             if word in wordSet and self.backtracking(s, wordSet, i + 1):
#                 # å¦‚æœæˆªå–çš„å­ä¸²åœ¨å­—å…¸ä¸­,å¹¶ä¸”åç»­éƒ¨åˆ†ä¹Ÿå¯ä»¥è¢«æ‹†åˆ†æˆå•è¯,è¿”å›True
#                 return True

#         # æ— æ³•è¿›è¡Œæœ‰æ•ˆæ‹†åˆ†,è¿”å›False
#         return False

#     def wordBreak(self, s: str, wordDict: List[str]) -> bool:
#         wordSet = set(wordDict)  # è½¬æ¢ä¸ºå“ˆå¸Œé›†åˆ,æé«˜æŸ¥æ‰¾æ•ˆç‡
#         return self.backtracking(s, wordSet, 0)
# DP(ç‰ˆæœ¬ä¸€)
# class Solution:
#     def wordBreak(self, s: str, wordDict: List[str]) -> bool:
#         wordSet = set(wordDict)
#         n = len(s)
#         dp = [False] * (n + 1)  # dp[i] è¡¨ç¤ºå­—ç¬¦ä¸²çš„å‰ i ä¸ªå­—ç¬¦æ˜¯å¦å¯ä»¥è¢«æ‹†åˆ†æˆå•è¯
#         dp[0] = True  # åˆå§‹çŠ¶æ€,ç©ºå­—ç¬¦ä¸²å¯ä»¥è¢«æ‹†åˆ†æˆå•è¯

#         for i in range(1, n + 1): # éå†èƒŒåŒ…
#             for j in range(i): # éå†å•è¯
#                 if dp[j] and s[j:i] in wordSet:
#                     dp[i] = True  # å¦‚æœ s[0:j] å¯ä»¥è¢«æ‹†åˆ†æˆå•è¯,å¹¶ä¸” s[j:i] åœ¨å•è¯é›†åˆä¸­å­˜åœ¨,åˆ™ s[0:i] å¯ä»¥è¢«æ‹†åˆ†æˆå•è¯
#                     break
#         return dp[n]
# DP(ç‰ˆæœ¬äºŒ)
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        dp = [False]*(len(s) + 1)
        dp[0] = True
        # éå†èƒŒåŒ…
        for j in range(1, len(s) + 1):
            # éå†å•è¯
            for word in wordDict:
                if j >= len(word):
                    dp[j] = dp[j] or (dp[j - len(word)] and word == s[j - len(word):j])
        return dp[len(s)]


"""
3. æ‰“å®¶åŠ«èˆç³»åˆ— (3)

åŠ¨æ€è§„åˆ’:å¼€å§‹æ‰“å®¶åŠ«èˆ!
åŠ¨æ€è§„åˆ’:ç»§ç»­æ‰“å®¶åŠ«èˆ!
åŠ¨æ€è§„åˆ’:è¿˜è¦æ‰“å®¶åŠ«èˆ!
"""
#X21 (Medium) 198.æ‰“å®¶åŠ«èˆ
    # ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å°å·ï¼Œè®¡åˆ’å·çªƒæ²¿è¡—çš„æˆ¿å±‹ã€‚æ¯é—´æˆ¿å†…éƒ½è—æœ‰ä¸€å®šçš„ç°é‡‘ï¼Œå½±å“ä½ å·çªƒçš„å”¯ä¸€åˆ¶çº¦å› ç´ å°±æ˜¯ç›¸é‚»çš„æˆ¿å±‹è£…æœ‰ç›¸äº’è¿é€šçš„é˜²ç›—ç³»ç»Ÿï¼Œå¦‚æœä¸¤é—´ç›¸é‚»çš„æˆ¿å±‹åœ¨åŒä¸€æ™šä¸Šè¢«å°å·é—¯å…¥ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æŠ¥è­¦ã€‚
    # ç»™å®šä¸€ä¸ªä»£è¡¨æ¯ä¸ªæˆ¿å±‹å­˜æ”¾é‡‘é¢çš„éè´Ÿæ•´æ•°æ•°ç»„ï¼Œè®¡ç®—ä½  ä¸è§¦åŠ¨è­¦æŠ¥è£…ç½®çš„æƒ…å†µä¸‹ ï¼Œä¸€å¤œä¹‹å†…èƒ½å¤Ÿå·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ã€‚
    # ç¤ºä¾‹ 1ï¼š
    # è¾“å…¥ï¼š[1,2,3,1]
    # è¾“å‡ºï¼š4
    # è§£é‡Šï¼šå·çªƒ 1 å·æˆ¿å±‹ (é‡‘é¢ = 1) ï¼Œç„¶åå·çªƒ 3 å·æˆ¿å±‹ (é‡‘é¢ = 3)ã€‚   å·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ = 1 + 3 = 4 ã€‚
    # ç¤ºä¾‹ 2ï¼š
    # è¾“å…¥ï¼š[2,7,9,3,1]
    # è¾“å‡ºï¼š12 è§£é‡Šï¼šå·çªƒ 1 å·æˆ¿å±‹ (é‡‘é¢ = 2), å·çªƒ 3 å·æˆ¿å±‹ (é‡‘é¢ = 9)ï¼Œæ¥ç€å·çªƒ 5 å·æˆ¿å±‹ (é‡‘é¢ = 1)ã€‚   å·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ = 2 + 9 + 1 = 12 ã€‚
# dp[i]ï¼šè€ƒè™‘ä¸‹æ ‡iï¼ˆåŒ…æ‹¬iï¼‰ä»¥å†…çš„æˆ¿å±‹ï¼Œæœ€å¤šå¯ä»¥å·çªƒçš„é‡‘é¢ä¸ºdp[i]ã€‚
# å†³å®šdp[i]çš„å› ç´ å°±æ˜¯ç¬¬iæˆ¿é—´å·è¿˜æ˜¯ä¸å·ã€‚
# å¦‚æœå·ç¬¬iæˆ¿é—´ï¼Œé‚£ä¹ˆdp[i] = dp[i - 2] + nums[i] ï¼Œå³ï¼šç¬¬i-1æˆ¿ä¸€å®šæ˜¯ä¸è€ƒè™‘çš„ï¼Œæ‰¾å‡º ä¸‹æ ‡i-2ï¼ˆåŒ…æ‹¬i-2ï¼‰ä»¥å†…çš„æˆ¿å±‹ï¼Œæœ€å¤šå¯ä»¥å·çªƒçš„é‡‘é¢ä¸ºdp[i-2] åŠ ä¸Šç¬¬iæˆ¿é—´å·åˆ°çš„é’±ã€‚
# å¦‚æœä¸å·ç¬¬iæˆ¿é—´ï¼Œé‚£ä¹ˆdp[i] = dp[i - 1]ï¼Œå³è€ƒ è™‘i-1æˆ¿ï¼Œï¼ˆæ³¨æ„è¿™é‡Œæ˜¯è€ƒè™‘ï¼Œå¹¶ä¸æ˜¯ä¸€å®šè¦å·i-1æˆ¿ï¼Œè¿™æ˜¯å¾ˆå¤šåŒå­¦å®¹æ˜“æ··æ·†çš„ç‚¹ï¼‰
# ç„¶ådp[i]å–æœ€å¤§å€¼ï¼Œå³dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
# 1ç»´DP
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 0:  # å¦‚æœæ²¡æœ‰æˆ¿å±‹,è¿”å›0
            return 0
        if len(nums) == 1:  # å¦‚æœåªæœ‰ä¸€ä¸ªæˆ¿å±‹,è¿”å›å…¶é‡‘é¢
            return nums[0]

        # åˆ›å»ºä¸€ä¸ªåŠ¨æ€è§„åˆ’æ•°ç»„,ç”¨äºå­˜å‚¨æœ€å¤§é‡‘é¢
        dp = [0] * len(nums)
        dp[0] = nums[0]  # å°†dpçš„ç¬¬ä¸€ä¸ªå…ƒç´ è®¾ç½®ä¸ºç¬¬ä¸€ä¸ªæˆ¿å±‹çš„é‡‘é¢
        dp[1] = max(nums[0], nums[1])  # å°†dpçš„ç¬¬äºŒä¸ªå…ƒç´ è®¾ç½®ä¸ºç¬¬ä¸€äºŒä¸ªæˆ¿å±‹ä¸­çš„é‡‘é¢è¾ƒå¤§è€…

        # éå†å‰©ä½™çš„æˆ¿å±‹
        for i in range(2, len(nums)):
            # å¯¹äºæ¯ä¸ªæˆ¿å±‹,é€‰æ‹©æŠ¢åŠ«å½“å‰æˆ¿å±‹å’ŒæŠ¢åŠ«å‰ä¸€ä¸ªæˆ¿å±‹çš„æœ€å¤§é‡‘é¢
            # æ³¨æ„è¿™é‡Œæ˜¯è€ƒè™‘,å¹¶ä¸æ˜¯ä¸€å®šè¦å·i-1,i-2æˆ¿,è¿™æ˜¯å¾ˆå¤šåŒå­¦å®¹æ˜“æ··æ·†çš„ç‚¹
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])

        return dp[-1]  # è¿”å›æœ€åä¸€ä¸ªæˆ¿å±‹ä¸­å¯æŠ¢åŠ«çš„æœ€å¤§é‡‘é¢
# 2ç»´DP
# class Solution:
#     def rob(self, nums: List[int]) -> int:
#         if not nums:  # å¦‚æœæ²¡æœ‰æˆ¿å±‹,è¿”å›0
#             return 0

#         n = len(nums)
#         dp = [[0, 0] for _ in range(n)]  # åˆ›å»ºäºŒç»´åŠ¨æ€è§„åˆ’æ•°ç»„,dp[i][0]è¡¨ç¤ºä¸æŠ¢åŠ«ç¬¬iä¸ªæˆ¿å±‹çš„æœ€å¤§é‡‘é¢,dp[i][1]è¡¨ç¤ºæŠ¢åŠ«ç¬¬iä¸ªæˆ¿å±‹çš„æœ€å¤§é‡‘é¢

#         dp[0][1] = nums[0]  # æŠ¢åŠ«ç¬¬ä¸€ä¸ªæˆ¿å±‹çš„æœ€å¤§é‡‘é¢ä¸ºç¬¬ä¸€ä¸ªæˆ¿å±‹çš„é‡‘é¢

#         for i in range(1, n):
#             dp[i][0] = max(dp[i-1][0], dp[i-1][1])  # ä¸æŠ¢åŠ«ç¬¬iä¸ªæˆ¿å±‹,æœ€å¤§é‡‘é¢ä¸ºå‰ä¸€ä¸ªæˆ¿å±‹æŠ¢åŠ«å’Œä¸æŠ¢åŠ«çš„æœ€å¤§å€¼
#             dp[i][1] = dp[i-1][0] + nums[i]  # æŠ¢åŠ«ç¬¬iä¸ªæˆ¿å±‹,æœ€å¤§é‡‘é¢ä¸ºå‰ä¸€ä¸ªæˆ¿å±‹ä¸æŠ¢åŠ«çš„æœ€å¤§é‡‘é¢åŠ ä¸Šå½“å‰æˆ¿å±‹çš„é‡‘é¢

#         return max(dp[n-1][0], dp[n-1][1])  # è¿”å›æœ€åä¸€ä¸ªæˆ¿å±‹ä¸­å¯æŠ¢åŠ«çš„æœ€å¤§é‡‘é¢
# *** ä¼˜åŒ–ç‰ˆ
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:  # å¦‚æœæ²¡æœ‰æˆ¿å±‹,è¿”å›0
            return 0

        prev_max = 0  # ä¸Šä¸€ä¸ªæˆ¿å±‹çš„æœ€å¤§é‡‘é¢
        curr_max = 0  # å½“å‰æˆ¿å±‹çš„æœ€å¤§é‡‘é¢

        for num in nums:
            temp = curr_max  # ä¸´æ—¶å˜é‡ä¿å­˜å½“å‰æˆ¿å±‹çš„æœ€å¤§é‡‘é¢
            curr_max = max(prev_max + num, curr_max)  # æ›´æ–°å½“å‰æˆ¿å±‹çš„æœ€å¤§é‡‘é¢
            prev_max = temp  # æ›´æ–°ä¸Šä¸€ä¸ªæˆ¿å±‹çš„æœ€å¤§é‡‘é¢
        return curr_max  # è¿”å›æœ€åä¸€ä¸ªæˆ¿å±‹ä¸­å¯æŠ¢åŠ«çš„æœ€å¤§é‡‘é¢
    
# Neighborhood Burglary
    # You plan to rob houses in a street where each house stores a certain amount of money. 
    # The neighborhood has a security system that sets off an alarm when two adjacent houses are robbed. 
    # Return the maximum amount of cash that can be stolen without triggering the alarms.
def neighborhood_burglary(houses: List[int]) -> int:
    # Handle the cases when the array is less than the size of 2 to 
    # avoid out-of-bounds errors when assigning the base case values.
    if not houses:
        return 0
    if len(houses) == 1:
        return houses[0]
    dp = [0] * len(houses)
    # Base case: when there's only one house, rob that house.
    dp[0] = houses[0]
    # Base case: when there are two houses, rob the one with the most 
    # money.
    dp[1] = max(houses[0], houses[1])
    # Fill in the rest of the DP array.
    for i in range(2, len(houses)):
        # 'dp[i]' = max(profit if we skip house 'i', profit if we rob 
        # house 'i').
        dp[i] = max(dp[i - 1], houses[i] + dp[i - 2])
    return dp[len(houses) - 1]


def neighborhood_burglary_optimized(houses: List[int]) -> int:
    if not houses:
        return 0
    if len(houses) == 1:
        return houses[0]
    # Initialize the variables with the base cases.
    prev_max_profit = max(houses[0], houses[1])
    prev_prev_max_profit = houses[0]
    for i in range(2, len(houses)):
        curr_max_profit = max(prev_max_profit, houses[i] + prev_prev_max_profit)
        # Update the values for the next iteration.
        prev_prev_max_profit = prev_max_profit
        prev_max_profit = curr_max_profit
    return prev_max_profit


#22 (Medium) 213.æ‰“å®¶åŠ«èˆII
    # ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å°å·ï¼Œè®¡åˆ’å·çªƒæ²¿è¡—çš„æˆ¿å±‹ï¼Œæ¯é—´æˆ¿å†…éƒ½è—æœ‰ä¸€å®šçš„ç°é‡‘ã€‚è¿™ä¸ªåœ°æ–¹æ‰€æœ‰çš„æˆ¿å±‹éƒ½ å›´æˆä¸€åœˆ ï¼Œè¿™æ„å‘³ç€ç¬¬ä¸€ä¸ªæˆ¿å±‹å’Œæœ€åä¸€ä¸ªæˆ¿å±‹æ˜¯ç´§æŒ¨ç€çš„ã€‚åŒæ—¶ï¼Œç›¸é‚»çš„æˆ¿å±‹è£…æœ‰ç›¸äº’è¿é€šçš„é˜²ç›—ç³»ç»Ÿï¼Œå¦‚æœä¸¤é—´ç›¸é‚»çš„æˆ¿å±‹åœ¨åŒä¸€æ™šä¸Šè¢«å°å·é—¯å…¥ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æŠ¥è­¦ ã€‚
    # ç»™å®šä¸€ä¸ªä»£è¡¨æ¯ä¸ªæˆ¿å±‹å­˜æ”¾é‡‘é¢çš„éè´Ÿæ•´æ•°æ•°ç»„ï¼Œè®¡ç®—ä½  åœ¨ä¸è§¦åŠ¨è­¦æŠ¥è£…ç½®çš„æƒ…å†µä¸‹ ï¼Œèƒ½å¤Ÿå·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ã€‚
    # ç¤ºä¾‹ 1ï¼š
    # è¾“å…¥ï¼šnums = [2,3,2]
    # è¾“å‡ºï¼š3
    # è§£é‡Šï¼šä½ ä¸èƒ½å…ˆå·çªƒ 1 å·æˆ¿å±‹ï¼ˆé‡‘é¢ = 2ï¼‰ï¼Œç„¶åå·çªƒ 3 å·æˆ¿å±‹ï¼ˆé‡‘é¢ = 2ï¼‰, å› ä¸ºä»–ä»¬æ˜¯ç›¸é‚»çš„ã€‚
    # ç¤ºä¾‹ 2ï¼š
    # è¾“å…¥ï¼šnums = [1,2,3,1]
    # è¾“å‡ºï¼š4
    # è§£é‡Šï¼šä½ å¯ä»¥å…ˆå·çªƒ 1 å·æˆ¿å±‹ï¼ˆé‡‘é¢ = 1ï¼‰ï¼Œç„¶åå·çªƒ 3 å·æˆ¿å±‹ï¼ˆé‡‘é¢ = 3ï¼‰ã€‚å·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ = 1 + 3 = 4 ã€‚
    # ç¤ºä¾‹ 3ï¼š
    # è¾“å…¥ï¼šnums = [0]
    # è¾“å‡ºï¼š0
# æƒ…å†µä¸€ï¼šè€ƒè™‘ä¸åŒ…å«é¦–å°¾å…ƒç´ 
# æƒ…å†µäºŒï¼šè€ƒè™‘åŒ…å«é¦–å…ƒç´ ï¼Œä¸åŒ…å«å°¾å…ƒç´ 
# æƒ…å†µä¸‰ï¼šè€ƒè™‘åŒ…å«å°¾å…ƒç´ ï¼Œä¸åŒ…å«é¦–å…ƒç´ 
# æ³¨æ„æˆ‘è¿™é‡Œç”¨çš„æ˜¯"è€ƒè™‘"ï¼Œä¾‹å¦‚æƒ…å†µä¸‰ï¼Œè™½ç„¶æ˜¯è€ƒè™‘åŒ…å«å°¾å…ƒç´ ï¼Œä½†ä¸ä¸€å®šè¦é€‰å°¾éƒ¨å…ƒç´ ï¼ å¯¹äºæƒ…å†µä¸‰ï¼Œå–nums[1] å’Œ nums[3]å°±æ˜¯æœ€å¤§çš„ã€‚
# è€Œæƒ…å†µäºŒ å’Œ æƒ…å†µä¸‰ éƒ½åŒ…å«äº†æƒ…å†µä¸€äº†ï¼Œæ‰€ä»¥åªè€ƒè™‘æƒ…å†µäºŒå’Œæƒ…å†µä¸‰å°±å¯ä»¥äº†ã€‚
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 0:
            return 0
        if len(nums) == 1:
            return nums[0]
        
        result1 = self.robRange(nums, 0, len(nums) - 2)  # æƒ…å†µäºŒ
        result2 = self.robRange(nums, 1, len(nums) - 1)  # æƒ…å†µä¸‰
        return max(result1, result2)
    # 198.æ‰“å®¶åŠ«èˆçš„é€»è¾‘
    def robRange(self, nums: List[int], start: int, end: int) -> int:
        # Don't miss this case
        if end == start:
            return nums[start]
        
        prev_max = nums[start]
        curr_max = max(nums[start], nums[start + 1])
        
        for i in range(start + 2, end + 1):
            temp = curr_max
            curr_max = max(prev_max + nums[i], curr_max)
            prev_max = temp
        return curr_max
# # 2ç»´DP
# class Solution:
#     def rob(self, nums: List[int]) -> int:
#         if len(nums) < 3:
#             return max(nums)

#         # æƒ…å†µäºŒ:ä¸æŠ¢åŠ«ç¬¬ä¸€ä¸ªæˆ¿å±‹
#         result1 = self.robRange(nums[:-1])

#         # æƒ…å†µä¸‰:ä¸æŠ¢åŠ«æœ€åä¸€ä¸ªæˆ¿å±‹
#         result2 = self.robRange(nums[1:])

#         return max(result1, result2)

#     def robRange(self, nums):
#         dp = [[0, 0] for _ in range(len(nums))]
#         dp[0][1] = nums[0]

#         for i in range(1, len(nums)):
#             dp[i][0] = max(dp[i - 1])
#             dp[i][1] = dp[i - 1][0] + nums[i]

#         return max(dp[-1])
# # ä¼˜åŒ–ç‰ˆ
# class Solution:
#     def rob(self, nums: List[int]) -> int:
#         if not nums:  # å¦‚æœæ²¡æœ‰æˆ¿å±‹,è¿”å›0
#             return 0

#         if len(nums) == 1:  # å¦‚æœåªæœ‰ä¸€ä¸ªæˆ¿å±‹,è¿”å›è¯¥æˆ¿å±‹çš„é‡‘é¢
#             return nums[0]

#         # æƒ…å†µäºŒ:ä¸æŠ¢åŠ«ç¬¬ä¸€ä¸ªæˆ¿å±‹
#         prev_max = 0  # ä¸Šä¸€ä¸ªæˆ¿å±‹çš„æœ€å¤§é‡‘é¢
#         curr_max = 0  # å½“å‰æˆ¿å±‹çš„æœ€å¤§é‡‘é¢
#         for num in nums[1:]:
#             temp = curr_max  # ä¸´æ—¶å˜é‡ä¿å­˜å½“å‰æˆ¿å±‹çš„æœ€å¤§é‡‘é¢
#             curr_max = max(prev_max + num, curr_max)  # æ›´æ–°å½“å‰æˆ¿å±‹çš„æœ€å¤§é‡‘é¢
#             prev_max = temp  # æ›´æ–°ä¸Šä¸€ä¸ªæˆ¿å±‹çš„æœ€å¤§é‡‘é¢
#         result1 = curr_max

#         # æƒ…å†µä¸‰:ä¸æŠ¢åŠ«æœ€åä¸€ä¸ªæˆ¿å±‹
#         prev_max = 0  # ä¸Šä¸€ä¸ªæˆ¿å±‹çš„æœ€å¤§é‡‘é¢
#         curr_max = 0  # å½“å‰æˆ¿å±‹çš„æœ€å¤§é‡‘é¢
#         for num in nums[:-1]:
#             temp = curr_max  # ä¸´æ—¶å˜é‡ä¿å­˜å½“å‰æˆ¿å±‹çš„æœ€å¤§é‡‘é¢
#             curr_max = max(prev_max + num, curr_max)  # æ›´æ–°å½“å‰æˆ¿å±‹çš„æœ€å¤§é‡‘é¢
#             prev_max = temp  # æ›´æ–°ä¸Šä¸€ä¸ªæˆ¿å±‹çš„æœ€å¤§é‡‘é¢
#         result2 = curr_max
#         return max(result1, result2)


#23 (Medium) 337.æ‰“å®¶åŠ«èˆ III
    # åœ¨ä¸Šæ¬¡æ‰“åŠ«å®Œä¸€æ¡è¡—é“ä¹‹åå’Œä¸€åœˆæˆ¿å±‹åï¼Œå°å·åˆå‘ç°äº†ä¸€ä¸ªæ–°çš„å¯è¡Œçªƒçš„åœ°åŒºã€‚
    # è¿™ä¸ªåœ°åŒºåªæœ‰ä¸€ä¸ªå…¥å£ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºâ€œæ ¹â€ã€‚ é™¤äº†â€œæ ¹â€ä¹‹å¤–ï¼Œæ¯æ ‹æˆ¿å­æœ‰ä¸”åªæœ‰ä¸€ä¸ªâ€œçˆ¶â€œæˆ¿å­ä¸ä¹‹ç›¸è¿ã€‚
    # ä¸€ç•ªä¾¦å¯Ÿä¹‹åï¼Œèªæ˜çš„å°å·æ„è¯†åˆ°â€œè¿™ä¸ªåœ°æ–¹çš„æ‰€æœ‰æˆ¿å±‹çš„æ’åˆ—ç±»ä¼¼äºä¸€æ£µäºŒå‰æ ‘â€ã€‚ 
    # å¦‚æœä¸¤ä¸ªç›´æ¥ç›¸è¿çš„æˆ¿å­åœ¨åŒä¸€å¤©æ™šä¸Šè¢«æ‰“åŠ«ï¼Œæˆ¿å±‹å°†è‡ªåŠ¨æŠ¥è­¦ã€‚
    # è®¡ç®—åœ¨ä¸è§¦åŠ¨è­¦æŠ¥çš„æƒ…å†µä¸‹ï¼Œå°å·ä¸€æ™šèƒ½å¤Ÿç›—å–çš„æœ€é«˜é‡‘é¢ã€‚
# è¿™é‡Œæˆ‘ä»¬è¦æ±‚ä¸€ä¸ªèŠ‚ç‚¹ å·ä¸ä¸å·çš„ä¸¤ä¸ªçŠ¶æ€æ‰€å¾—åˆ°çš„é‡‘é’±ï¼Œé‚£ä¹ˆè¿”å›å€¼å°±æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º2çš„æ•°ç»„ã€‚
# æ‰€ä»¥dpæ•°ç»„ï¼ˆdp tableï¼‰ä»¥åŠä¸‹æ ‡çš„å«ä¹‰ï¼šä¸‹æ ‡ä¸º0è®°å½•ä¸å·è¯¥èŠ‚ç‚¹æ‰€å¾—åˆ°çš„çš„æœ€å¤§é‡‘é’±ï¼Œä¸‹æ ‡ä¸º1è®°å½•å·è¯¥èŠ‚ç‚¹æ‰€å¾—åˆ°çš„çš„æœ€å¤§é‡‘é’±ã€‚
# æ‰€ä»¥æœ¬é¢˜dpæ•°ç»„å°±æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º2çš„æ•°ç»„ï¼
# é¦–å…ˆæ˜ç¡®çš„æ˜¯ä½¿ç”¨ååºéå†ã€‚ å› ä¸ºè¦é€šè¿‡é€’å½’å‡½æ•°çš„è¿”å›å€¼æ¥åšä¸‹ä¸€æ­¥è®¡ç®—ã€‚
# é€šè¿‡é€’å½’å·¦èŠ‚ç‚¹ï¼Œå¾—åˆ°å·¦èŠ‚ç‚¹å·ä¸ä¸å·çš„é‡‘é’±ã€‚
# é€šè¿‡é€’å½’å³èŠ‚ç‚¹ï¼Œå¾—åˆ°å³èŠ‚ç‚¹å·ä¸ä¸å·çš„é‡‘é’±ã€‚
# æœ€åå½“å‰èŠ‚ç‚¹çš„çŠ¶æ€å°±æ˜¯{val0, val1}; å³ï¼š{ä¸å·å½“å‰èŠ‚ç‚¹å¾—åˆ°çš„æœ€å¤§é‡‘é’±ï¼Œå·å½“å‰èŠ‚ç‚¹å¾—åˆ°çš„æœ€å¤§é‡‘é’±}
# æš´åŠ›é€’å½’
# class Solution:
#     def rob(self, root: TreeNode) -> int:
#         if root is None:
#             return 0
#         if root.left is None and root.right  is None:
#             return root.val
#         # å·çˆ¶èŠ‚ç‚¹
#         val1 = root.val
#         if root.left:
#             val1 += self.rob(root.left.left) + self.rob(root.left.right)
#         if root.right:
#             val1 += self.rob(root.right.left) + self.rob(root.right.right)
#         # ä¸å·çˆ¶èŠ‚ç‚¹
#         val2 = self.rob(root.left) + self.rob(root.right)
#         return max(val1, val2)
# # è®°å¿†åŒ–é€’å½’
# class Solution:
#     memory = {}
#     def rob(self, root: TreeNode) -> int:
#         if root is None:
#             return 0
#         if root.left is None and root.right  is None:
#             return root.val
#         if self.memory.get(root) is not None:
#             return self.memory[root]
#         # å·çˆ¶èŠ‚ç‚¹
#         val1 = root.val
#         if root.left:
#             val1 += self.rob(root.left.left) + self.rob(root.left.right)
#         if root.right:
#             val1 += self.rob(root.right.left) + self.rob(root.right.right)
#         # ä¸å·çˆ¶èŠ‚ç‚¹
#         val2 = self.rob(root.left) + self.rob(root.right)
#         self.memory[root] = max(val1, val2)
#         return max(val1, val2)
# åŠ¨æ€è§„åˆ’
class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        # dpæ•°ç»„(dp table)ä»¥åŠä¸‹æ ‡çš„å«ä¹‰:
        # 1. ä¸‹æ ‡ä¸º 0 è®°å½• **ä¸å·è¯¥èŠ‚ç‚¹** æ‰€å¾—åˆ°çš„çš„æœ€å¤§é‡‘é’±
        # 2. ä¸‹æ ‡ä¸º 1 è®°å½• **å·è¯¥èŠ‚ç‚¹** æ‰€å¾—åˆ°çš„çš„æœ€å¤§é‡‘é’±
        dp = self.traversal(root)
        return max(dp)

    # è¦ç”¨ååºéå†, å› ä¸ºè¦é€šè¿‡é€’å½’å‡½æ•°çš„è¿”å›å€¼æ¥åšä¸‹ä¸€æ­¥è®¡ç®—
    def traversal(self, node):
        
        # é€’å½’ç»ˆæ­¢æ¡ä»¶,å°±æ˜¯é‡åˆ°äº†ç©ºèŠ‚ç‚¹,é‚£è‚¯å®šæ˜¯ä¸å·çš„
        if not node:
            return (0, 0)

        left = self.traversal(node.left)
        right = self.traversal(node.right)

        # ä¸å·å½“å‰èŠ‚ç‚¹, å·å­èŠ‚ç‚¹
        val_0 = max(left[0], left[1]) + max(right[0], right[1])

        # å·å½“å‰èŠ‚ç‚¹, ä¸å·å­èŠ‚ç‚¹
        val_1 = node.val + left[0] + right[0]
        return (val_0, val_1)


"""
4. è‚¡ç¥¨ç³»åˆ— (6)

åŠ¨æ€è§„åˆ’:ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº
åŠ¨æ€è§„åˆ’:æœ¬å‘¨æˆ‘ä»¬éƒ½è®²äº†è¿™äº›(ç³»åˆ—å…­)
åŠ¨æ€è§„åˆ’:ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºII
åŠ¨æ€è§„åˆ’:ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºIII
åŠ¨æ€è§„åˆ’:ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºIV
åŠ¨æ€è§„åˆ’:æœ€ä½³ä¹°å–è‚¡ç¥¨æ—¶æœºå«å†·å†»æœŸ
åŠ¨æ€è§„åˆ’:æœ¬å‘¨æˆ‘ä»¬éƒ½è®²äº†è¿™äº›(ç³»åˆ—ä¸ƒ)
åŠ¨æ€è§„åˆ’:ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºå«æ‰‹ç»­è´¹
åŠ¨æ€è§„åˆ’:è‚¡ç¥¨ç³»åˆ—æ€»ç»“ç¯‡
"""
#24 (Easy) 121. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº
    # ç»™å®šä¸€ä¸ªæ•°ç»„ prices ï¼Œå®ƒçš„ç¬¬ i ä¸ªå…ƒç´  prices[i] è¡¨ç¤ºä¸€æ”¯ç»™å®šè‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚
    # ä½ åªèƒ½é€‰æ‹© æŸä¸€å¤© ä¹°å…¥è¿™åªè‚¡ç¥¨ï¼Œå¹¶é€‰æ‹©åœ¨ æœªæ¥çš„æŸä¸€ä¸ªä¸åŒçš„æ—¥å­ å–å‡ºè¯¥è‚¡ç¥¨ã€‚è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚
    # è¿”å›ä½ å¯ä»¥ä»è¿™ç¬”äº¤æ˜“ä¸­è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚å¦‚æœä½ ä¸èƒ½è·å–ä»»ä½•åˆ©æ¶¦ï¼Œè¿”å› 0 ã€‚
    # ç¤ºä¾‹ 1ï¼š
    # è¾“å…¥ï¼š[7,1,5,3,6,4]
    # è¾“å‡ºï¼š5
    # è§£é‡Šï¼šåœ¨ç¬¬ 2 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 1ï¼‰çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 5 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 6ï¼‰çš„æ—¶å€™å–å‡ºï¼Œæœ€å¤§åˆ©æ¶¦ = 6-1 = 5 ã€‚æ³¨æ„åˆ©æ¶¦ä¸èƒ½æ˜¯ 7-1 = 6, å› ä¸ºå–å‡ºä»·æ ¼éœ€è¦å¤§äºä¹°å…¥ä»·æ ¼ï¼›åŒæ—¶ï¼Œä½ ä¸èƒ½åœ¨ä¹°å…¥å‰å–å‡ºè‚¡ç¥¨ã€‚
    # ç¤ºä¾‹ 2ï¼š
    # è¾“å…¥ï¼šprices = [7,6,4,3,1]
    # è¾“å‡ºï¼š0
    # è§£é‡Šï¼šåœ¨è¿™ç§æƒ…å†µä¸‹, æ²¡æœ‰äº¤æ˜“å®Œæˆ, æ‰€ä»¥æœ€å¤§åˆ©æ¶¦ä¸º 0ã€‚
# dpæ•°ç»„çš„å«ä¹‰:
# dp[i][0] è¡¨ç¤ºç¬¬iå¤©æŒæœ‰è‚¡ç¥¨æ‰€å¾—ç°é‡‘ã€‚
# dp[i][1] è¡¨ç¤ºç¬¬iå¤©ä¸æŒæœ‰è‚¡ç¥¨æ‰€å¾—æœ€å¤šç°é‡‘
# æ³¨æ„è¿™é‡Œè¯´çš„æ˜¯â€œæŒæœ‰â€,â€œæŒæœ‰â€ä¸ä»£è¡¨å°±æ˜¯å½“å¤©â€œä¹°å…¥â€!ä¹Ÿæœ‰å¯èƒ½æ˜¯æ˜¨å¤©å°±ä¹°å…¥äº†,ä»Šå¤©ä¿æŒæŒæœ‰çš„çŠ¶æ€
# å¾ˆå¤šåŒå­¦æŠŠâ€œæŒæœ‰â€å’Œâ€œä¹°å…¥â€æ²¡åŒºåˆ†æ¸…æ¥šã€‚
# å¦‚æœç¬¬iå¤©æŒæœ‰è‚¡ç¥¨å³dp[i][0]ï¼Œ é‚£ä¹ˆå¯ä»¥ç”±ä¸¤ä¸ªçŠ¶æ€æ¨å‡ºæ¥
# ç¬¬i-1å¤©å°±æŒæœ‰è‚¡ç¥¨ï¼Œé‚£ä¹ˆå°±ä¿æŒç°çŠ¶ï¼Œæ‰€å¾—ç°é‡‘å°±æ˜¯æ˜¨å¤©æŒæœ‰è‚¡ç¥¨çš„æ‰€å¾—ç°é‡‘ å³ï¼šdp[i - 1][0]
# ç¬¬iå¤©ä¹°å…¥è‚¡ç¥¨ï¼Œæ‰€å¾—ç°é‡‘å°±æ˜¯ä¹°å…¥ä»Šå¤©çš„è‚¡ç¥¨åæ‰€å¾—ç°é‡‘å³ï¼š-prices[i]
# é‚£ä¹ˆdp[i][0]åº”è¯¥é€‰æ‰€å¾—ç°é‡‘æœ€å¤§çš„ï¼Œæ‰€ä»¥dp[i][0] = max(dp[i - 1][0], -prices[i]);
# å¦‚æœç¬¬iå¤©ä¸æŒæœ‰è‚¡ç¥¨å³dp[i][1]ï¼Œ ä¹Ÿå¯ä»¥ç”±ä¸¤ä¸ªçŠ¶æ€æ¨å‡ºæ¥
# ç¬¬i-1å¤©å°±ä¸æŒæœ‰è‚¡ç¥¨ï¼Œé‚£ä¹ˆå°±ä¿æŒç°çŠ¶ï¼Œæ‰€å¾—ç°é‡‘å°±æ˜¯æ˜¨å¤©ä¸æŒæœ‰è‚¡ç¥¨çš„æ‰€å¾—ç°é‡‘ å³ï¼šdp[i - 1][1]
# ç¬¬iå¤©å–å‡ºè‚¡ç¥¨ï¼Œæ‰€å¾—ç°é‡‘å°±æ˜¯æŒ‰ç…§ä»Šå¤©è‚¡ç¥¨ä»·æ ¼å–å‡ºåæ‰€å¾—ç°é‡‘å³ï¼šprices[i] + dp[i - 1][0]
# åŒæ ·dp[i][1]å–æœ€å¤§çš„ï¼Œdp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
# è´ªå¿ƒæ³•
# class Solution:
#     def maxProfit(self, prices: List[int]) -> int:
#         low = float("inf")
#         result = 0
#         for i in range(len(prices)):
#             low = min(low, prices[i]) #å–æœ€å·¦æœ€å°ä»·æ ¼
#             result = max(result, prices[i] - low) #ç›´æ¥å–æœ€å¤§åŒºé—´åˆ©æ¶¦
#         return result
# *** åŠ¨æ€è§„åˆ’:ç‰ˆæœ¬ä¸€
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        length = len(prices)
        if len == 0:
            return 0
        dp = [[0] * 2 for _ in range(length)]
        dp[0][0] = -prices[0]
        dp[0][1] = 0
        for i in range(1, length):
            dp[i][0] = max(dp[i-1][0], -prices[i])
            dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0])
        return dp[-1][1]
# åŠ¨æ€è§„åˆ’:ç‰ˆæœ¬äºŒ
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        length = len(prices)
        dp = [[0] * 2 for _ in range(2)] #æ³¨æ„è¿™é‡Œåªå¼€è¾Ÿäº†ä¸€ä¸ª2 * 2å¤§å°çš„äºŒç»´æ•°ç»„
        dp[0][0] = -prices[0]
        dp[0][1] = 0
        for i in range(1, length):
            dp[i % 2][0] = max(dp[(i-1) % 2][0], -prices[i])
            dp[i % 2][1] = max(dp[(i-1) % 2][1], prices[i] + dp[(i-1) % 2][0])
        return dp[(length-1) % 2][1]
# åŠ¨æ€è§„åˆ’:ç‰ˆæœ¬ä¸‰
# class Solution:
#     def maxProfit(self, prices: List[int]) -> int:
#         length = len(prices)
#         dp0, dp1 = -prices[0], 0 #æ³¨æ„è¿™é‡Œåªç»´æŠ¤ä¸¤ä¸ªå¸¸é‡,å› ä¸ºdp0çš„æ›´æ–°ä¸å—dp1çš„å½±å“
#         for i in range(1, length):
#             dp1 = max(dp1, dp0 + prices[i])
#             dp0 = max(dp0, -prices[i])
#         return dp1


#25 (Medium) 122.ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºII
    # ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œå®ƒçš„ç¬¬ i ä¸ªå…ƒç´ æ˜¯ä¸€æ”¯ç»™å®šè‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚
    # è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚ä½ å¯ä»¥å°½å¯èƒ½åœ°å®Œæˆæ›´å¤šçš„äº¤æ˜“ï¼ˆå¤šæ¬¡ä¹°å–ä¸€æ”¯è‚¡ç¥¨ï¼‰ã€‚
    # æ³¨æ„ï¼šä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚
    # ç¤ºä¾‹ 1:
    # è¾“å…¥: [7,1,5,3,6,4]
    # è¾“å‡º: 7
    # è§£é‡Š: åœ¨ç¬¬ 2 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 1ï¼‰çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 3 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 5ï¼‰çš„æ—¶å€™å–å‡º, è¿™ç¬”äº¤æ˜“æ‰€èƒ½è·å¾—åˆ©æ¶¦ = 5-1 = 4ã€‚éšåï¼Œåœ¨ç¬¬ 4 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 3ï¼‰çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 5 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 6ï¼‰çš„æ—¶å€™å–å‡º, è¿™ç¬”äº¤æ˜“æ‰€èƒ½è·å¾—åˆ©æ¶¦ = 6-3 = 3 ã€‚
    # ç¤ºä¾‹ 2:
    # è¾“å…¥: [1,2,3,4,5]
    # è¾“å‡º: 4
    # è§£é‡Š: åœ¨ç¬¬ 1 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 1ï¼‰çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 5 å¤© ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 5ï¼‰çš„æ—¶å€™å–å‡º, è¿™ç¬”äº¤æ˜“æ‰€èƒ½è·å¾—åˆ©æ¶¦ = 5-1 = 4 ã€‚æ³¨æ„ä½ ä¸èƒ½åœ¨ç¬¬ 1 å¤©å’Œç¬¬ 2 å¤©æ¥è¿è´­ä¹°è‚¡ç¥¨ï¼Œä¹‹åå†å°†å®ƒä»¬å–å‡ºã€‚å› ä¸ºè¿™æ ·å±äºåŒæ—¶å‚ä¸äº†å¤šç¬”äº¤æ˜“ï¼Œä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ã€‚
    # ç¤ºä¾‹ 3:
    # è¾“å…¥: [7,6,4,3,1]
    # è¾“å‡º: 0
    # è§£é‡Š: åœ¨è¿™ç§æƒ…å†µä¸‹, æ²¡æœ‰äº¤æ˜“å®Œæˆ, æ‰€ä»¥æœ€å¤§åˆ©æ¶¦ä¸º 0ã€‚
# è¿™é‡Œé‡ç”³ä¸€ä¸‹dpæ•°ç»„çš„å«ä¹‰ï¼š
# dp[i][0] è¡¨ç¤ºç¬¬iå¤©æŒæœ‰è‚¡ç¥¨æ‰€å¾—ç°é‡‘ã€‚
# dp[i][1] è¡¨ç¤ºç¬¬iå¤©ä¸æŒæœ‰è‚¡ç¥¨æ‰€å¾—æœ€å¤šç°é‡‘
# å¦‚æœç¬¬iå¤©æŒæœ‰è‚¡ç¥¨å³dp[i][0]ï¼Œ é‚£ä¹ˆå¯ä»¥ç”±ä¸¤ä¸ªçŠ¶æ€æ¨å‡ºæ¥
# ç¬¬i-1å¤©å°±æŒæœ‰è‚¡ç¥¨ï¼Œé‚£ä¹ˆå°±ä¿æŒç°çŠ¶ï¼Œæ‰€å¾—ç°é‡‘å°±æ˜¯æ˜¨å¤©æŒæœ‰è‚¡ç¥¨çš„æ‰€å¾—ç°é‡‘ å³ï¼šdp[i - 1][0]
# ç¬¬iå¤©ä¹°å…¥è‚¡ç¥¨ï¼Œæ‰€å¾—ç°é‡‘å°±æ˜¯æ˜¨å¤©ä¸æŒæœ‰è‚¡ç¥¨çš„æ‰€å¾—ç°é‡‘å‡å» ä»Šå¤©çš„è‚¡ç¥¨ä»·æ ¼ å³ï¼šdp[i - 1][1] - prices[i]
# æ³¨æ„è¿™é‡Œå’Œ121. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº (opens new window)å”¯ä¸€ä¸åŒçš„åœ°æ–¹ï¼Œå°±æ˜¯æ¨å¯¼dp[i][0]çš„æ—¶å€™ï¼Œç¬¬iå¤©ä¹°å…¥è‚¡ç¥¨çš„æƒ…å†µã€‚
# åœ¨121. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº (opens new window)ä¸­ï¼Œå› ä¸ºè‚¡ç¥¨å…¨ç¨‹åªèƒ½ä¹°å–ä¸€æ¬¡ï¼Œæ‰€ä»¥å¦‚æœä¹°å…¥è‚¡ç¥¨ï¼Œé‚£ä¹ˆç¬¬iå¤©æŒæœ‰è‚¡ç¥¨å³dp[i][0]ä¸€å®šå°±æ˜¯ -prices[i]ã€‚
# è€Œæœ¬é¢˜ï¼Œå› ä¸ºä¸€åªè‚¡ç¥¨å¯ä»¥ä¹°å–å¤šæ¬¡ï¼Œæ‰€ä»¥å½“ç¬¬iå¤©ä¹°å…¥è‚¡ç¥¨çš„æ—¶å€™ï¼Œæ‰€æŒæœ‰çš„ç°é‡‘å¯èƒ½æœ‰ä¹‹å‰ä¹°å–è¿‡çš„åˆ©æ¶¦ã€‚
# é‚£ä¹ˆç¬¬iå¤©æŒæœ‰è‚¡ç¥¨å³dp[i][0]ï¼Œå¦‚æœæ˜¯ç¬¬iå¤©ä¹°å…¥è‚¡ç¥¨ï¼Œæ‰€å¾—ç°é‡‘å°±æ˜¯æ˜¨å¤©ä¸æŒæœ‰è‚¡ç¥¨çš„æ‰€å¾—ç°é‡‘ å‡å» ä»Šå¤©çš„è‚¡ç¥¨ä»·æ ¼ å³ï¼šdp[i - 1][1] - prices[i]ã€‚
# å†æ¥çœ‹çœ‹å¦‚æœç¬¬iå¤©ä¸æŒæœ‰è‚¡ç¥¨å³dp[i][1]çš„æƒ…å†µï¼Œ ä¾ç„¶å¯ä»¥ç”±ä¸¤ä¸ªçŠ¶æ€æ¨å‡ºæ¥
# ç¬¬i-1å¤©å°±ä¸æŒæœ‰è‚¡ç¥¨ï¼Œé‚£ä¹ˆå°±ä¿æŒç°çŠ¶ï¼Œæ‰€å¾—ç°é‡‘å°±æ˜¯æ˜¨å¤©ä¸æŒæœ‰è‚¡ç¥¨çš„æ‰€å¾—ç°é‡‘ å³ï¼šdp[i - 1][1]
# ç¬¬iå¤©å–å‡ºè‚¡ç¥¨ï¼Œæ‰€å¾—ç°é‡‘å°±æ˜¯æŒ‰ç…§ä»Šå¤©è‚¡ç¥¨ä»·æ ¼å–å‡ºåæ‰€å¾—ç°é‡‘å³ï¼šprices[i] + dp[i - 1][0]
# *** ç‰ˆæœ¬ä¸€
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        length = len(prices)
        dp = [[0] * 2 for _ in range(length)]
        dp[0][0] = -prices[0]
        dp[0][1] = 0
        for i in range(1, length):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]) #æ³¨æ„è¿™é‡Œæ˜¯å’Œ121. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºå”¯ä¸€ä¸åŒçš„åœ°æ–¹
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])
        return dp[-1][1]
# *** ç‰ˆæœ¬äºŒ
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        length = len(prices)
        dp = [[0] * 2 for _ in range(2)] #æ³¨æ„è¿™é‡Œåªå¼€è¾Ÿäº†ä¸€ä¸ª2 * 2å¤§å°çš„äºŒç»´æ•°ç»„
        dp[0][0] = -prices[0]
        dp[0][1] = 0
        for i in range(1, length):
            dp[i % 2][0] = max(dp[(i-1) % 2][0], dp[(i-1) % 2][1] - prices[i])
            dp[i % 2][1] = max(dp[(i-1) % 2][1], dp[(i-1) % 2][0] + prices[i])
        return dp[(length-1) % 2][1]


#26 (Hard) 123.ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºIII
    # ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œå®ƒçš„ç¬¬ i ä¸ªå…ƒç´ æ˜¯ä¸€æ”¯ç»™å®šçš„è‚¡ç¥¨åœ¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚
    # è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚ä½ æœ€å¤šå¯ä»¥å®Œæˆ ä¸¤ç¬” äº¤æ˜“ã€‚
    # æ³¨æ„ï¼šä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚
    # ç¤ºä¾‹ 1:
    # è¾“å…¥ï¼šprices = [3,3,5,0,0,3,1,4]
    # è¾“å‡ºï¼š6 è§£é‡Šï¼šåœ¨ç¬¬ 4 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 0ï¼‰çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 6 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 3ï¼‰çš„æ—¶å€™å–å‡ºï¼Œè¿™ç¬”äº¤æ˜“æ‰€èƒ½è·å¾—åˆ©æ¶¦ = 3-0 = 3 ã€‚éšåï¼Œåœ¨ç¬¬ 7 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 1ï¼‰çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 8 å¤© ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 4ï¼‰çš„æ—¶å€™å–å‡ºï¼Œè¿™ç¬”äº¤æ˜“æ‰€èƒ½è·å¾—åˆ©æ¶¦ = 4-1 = 3ã€‚
    # ç¤ºä¾‹ 2ï¼š
    # è¾“å…¥ï¼šprices = [1,2,3,4,5]
    # è¾“å‡ºï¼š4 è§£é‡Šï¼šåœ¨ç¬¬ 1 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 1ï¼‰çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 5 å¤© ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 5ï¼‰çš„æ—¶å€™å–å‡º, è¿™ç¬”äº¤æ˜“æ‰€èƒ½è·å¾—åˆ©æ¶¦ = 5-1 = 4ã€‚æ³¨æ„ä½ ä¸èƒ½åœ¨ç¬¬ 1 å¤©å’Œç¬¬ 2 å¤©æ¥è¿è´­ä¹°è‚¡ç¥¨ï¼Œä¹‹åå†å°†å®ƒä»¬å–å‡ºã€‚å› ä¸ºè¿™æ ·å±äºåŒæ—¶å‚ä¸äº†å¤šç¬”äº¤æ˜“ï¼Œä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ã€‚
    # ç¤ºä¾‹ 3ï¼š
    # è¾“å…¥ï¼šprices = [7,6,4,3,1]
    # è¾“å‡ºï¼š0 è§£é‡Šï¼šåœ¨è¿™ä¸ªæƒ…å†µä¸‹, æ²¡æœ‰äº¤æ˜“å®Œæˆ, æ‰€ä»¥æœ€å¤§åˆ©æ¶¦ä¸º0ã€‚
    # ç¤ºä¾‹ 4ï¼š
    # è¾“å…¥ï¼šprices = [1] è¾“å‡ºï¼š0
# ç¡®å®šdpæ•°ç»„ä»¥åŠä¸‹æ ‡çš„å«ä¹‰
# ä¸€å¤©ä¸€å…±å°±æœ‰äº”ä¸ªçŠ¶æ€,
# æ²¡æœ‰æ“ä½œ (å…¶å®æˆ‘ä»¬ä¹Ÿå¯ä»¥ä¸è®¾ç½®è¿™ä¸ªçŠ¶æ€)
# ç¬¬ä¸€æ¬¡æŒæœ‰è‚¡ç¥¨
# ç¬¬ä¸€æ¬¡ä¸æŒæœ‰è‚¡ç¥¨
# ç¬¬äºŒæ¬¡æŒæœ‰è‚¡ç¥¨
# ç¬¬äºŒæ¬¡ä¸æŒæœ‰è‚¡ç¥¨
# dp[i][j]ä¸­ iè¡¨ç¤ºç¬¬iå¤©ï¼Œjä¸º [0 - 4] äº”ä¸ªçŠ¶æ€ï¼Œdp[i][j]è¡¨ç¤ºç¬¬iå¤©çŠ¶æ€jæ‰€å‰©æœ€å¤§ç°é‡‘ã€‚
# éœ€è¦æ³¨æ„ï¼šdp[i][1]ï¼Œè¡¨ç¤ºçš„æ˜¯ç¬¬iå¤©ï¼Œä¹°å…¥è‚¡ç¥¨çš„çŠ¶æ€ï¼Œå¹¶ä¸æ˜¯è¯´ä¸€å®šè¦ç¬¬iå¤©ä¹°å…¥è‚¡ç¥¨ï¼Œè¿™æ˜¯å¾ˆå¤šåŒå­¦å®¹æ˜“é™·å…¥çš„è¯¯åŒºã€‚
# ä¾‹å¦‚ dp[i][1] ï¼Œå¹¶ä¸æ˜¯è¯´ ç¬¬iå¤©ä¸€å®šä¹°å…¥è‚¡ç¥¨ï¼Œæœ‰å¯èƒ½ ç¬¬ i-1å¤© å°±ä¹°å…¥äº†ï¼Œé‚£ä¹ˆ dp[i][1] å»¶ç»­ä¹°å…¥è‚¡ç¥¨çš„è¿™ä¸ªçŠ¶æ€ã€‚
# è¾¾åˆ°dp[i][1]çŠ¶æ€ï¼Œæœ‰ä¸¤ä¸ªå…·ä½“æ“ä½œï¼š
# æ“ä½œä¸€ï¼šç¬¬iå¤©ä¹°å…¥è‚¡ç¥¨äº†ï¼Œé‚£ä¹ˆdp[i][1] = dp[i-1][0] - prices[i]
# æ“ä½œäºŒï¼šç¬¬iå¤©æ²¡æœ‰æ“ä½œï¼Œè€Œæ˜¯æ²¿ç”¨å‰ä¸€å¤©ä¹°å…¥çš„çŠ¶æ€ï¼Œå³ï¼šdp[i][1] = dp[i - 1][1]
# é‚£ä¹ˆdp[i][1]ç©¶ç«Ÿé€‰ dp[i-1][0] - prices[i]ï¼Œè¿˜æ˜¯dp[i - 1][1]å‘¢ï¼Ÿ
# ä¸€å®šæ˜¯é€‰æœ€å¤§çš„ï¼Œæ‰€ä»¥ dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);
# åŒç†dp[i][2]ä¹Ÿæœ‰ä¸¤ä¸ªæ“ä½œï¼š
# æ“ä½œä¸€ï¼šç¬¬iå¤©å–å‡ºè‚¡ç¥¨äº†ï¼Œé‚£ä¹ˆdp[i][2] = dp[i - 1][1] + prices[i]
# æ“ä½œäºŒï¼šç¬¬iå¤©æ²¡æœ‰æ“ä½œï¼Œæ²¿ç”¨å‰ä¸€å¤©å–å‡ºè‚¡ç¥¨çš„çŠ¶æ€ï¼Œå³ï¼šdp[i][2] = dp[i - 1][2]
# æ‰€ä»¥dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])
# åŒç†å¯æ¨å‡ºå‰©ä¸‹çŠ¶æ€éƒ¨åˆ†ï¼š
# dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
# dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
# *** ç‰ˆæœ¬ä¸€
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) == 0:
            return 0
        dp = [[0] * 5 for _ in range(len(prices))]
        dp[0][1] = -prices[0]
        dp[0][3] = -prices[0]
        for i in range(1, len(prices)):
            dp[i][0] = dp[i-1][0]
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
            dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i])
            dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i])
            dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i])
        return dp[-1][4]
# ç‰ˆæœ¬äºŒ
# class Solution:
#     def maxProfit(self, prices: List[int]) -> int:
#         if len(prices) == 0:
#             return 0
#         dp = [0] * 5 
#         dp[1] = -prices[0]
#         dp[3] = -prices[0]
#         for i in range(1, len(prices)):
#             dp[1] = max(dp[1], dp[0] - prices[i])
#             dp[2] = max(dp[2], dp[1] + prices[i])
#             dp[3] = max(dp[3], dp[2] - prices[i])
#             dp[4] = max(dp[4], dp[3] + prices[i])
#         return dp[4]


#27 (Hard) 188.ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºIV
    # ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ prices ï¼Œå®ƒçš„ç¬¬ i ä¸ªå…ƒç´  prices[i] æ˜¯ä¸€æ”¯ç»™å®šçš„è‚¡ç¥¨åœ¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚
    # è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚ä½ æœ€å¤šå¯ä»¥å®Œæˆ k ç¬”äº¤æ˜“ã€‚
    # æ³¨æ„ï¼šä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚
    # ç¤ºä¾‹ 1ï¼š
    # è¾“å…¥ï¼šk = 2, prices = [2,4,1]
    # è¾“å‡ºï¼š2 è§£é‡Šï¼šåœ¨ç¬¬ 1 å¤© (è‚¡ç¥¨ä»·æ ¼ = 2) çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 2 å¤© (è‚¡ç¥¨ä»·æ ¼ = 4) çš„æ—¶å€™å–å‡ºï¼Œè¿™ç¬”äº¤æ˜“æ‰€èƒ½è·å¾—åˆ©æ¶¦ = 4-2 = 2ã€‚
    # ç¤ºä¾‹ 2ï¼š
    # è¾“å…¥ï¼šk = 2, prices = [3,2,6,5,0,3]
    # è¾“å‡ºï¼š7 è§£é‡Šï¼šåœ¨ç¬¬ 2 å¤© (è‚¡ç¥¨ä»·æ ¼ = 2) çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 3 å¤© (è‚¡ç¥¨ä»·æ ¼ = 6) çš„æ—¶å€™å–å‡º, è¿™ç¬”äº¤æ˜“æ‰€èƒ½è·å¾—åˆ©æ¶¦ = 6-2 = 4ã€‚éšåï¼Œåœ¨ç¬¬ 5 å¤© (è‚¡ç¥¨ä»·æ ¼ = 0) çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 6 å¤© (è‚¡ç¥¨ä»·æ ¼ = 3) çš„æ—¶å€™å–å‡º, è¿™ç¬”äº¤æ˜“æ‰€èƒ½è·å¾—åˆ©æ¶¦ = 3-0 = 3 ã€‚
# åœ¨åŠ¨æ€è§„åˆ’ï¼š123.ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºIII (opens new window)ä¸­ï¼Œæˆ‘æ˜¯å®šä¹‰äº†ä¸€ä¸ªäºŒç»´dpæ•°ç»„ï¼Œæœ¬é¢˜å…¶å®ä¾ç„¶å¯ä»¥ç”¨ä¸€ä¸ªäºŒç»´dpæ•°ç»„ã€‚
# ä½¿ç”¨äºŒç»´æ•°ç»„ dp[i][j] ï¼šç¬¬iå¤©çš„çŠ¶æ€ä¸ºjï¼Œæ‰€å‰©ä¸‹çš„æœ€å¤§ç°é‡‘æ˜¯dp[i][j]
# jçš„çŠ¶æ€è¡¨ç¤ºä¸ºï¼š
# 0 è¡¨ç¤ºä¸æ“ä½œ
# 1 ç¬¬ä¸€æ¬¡ä¹°å…¥
# 2 ç¬¬ä¸€æ¬¡å–å‡º
# 3 ç¬¬äºŒæ¬¡ä¹°å…¥
# 4 ç¬¬äºŒæ¬¡å–å‡º
# .....
# å¤§å®¶åº”è¯¥å‘ç°è§„å¾‹äº†å§ ï¼Œé™¤äº†0ä»¥å¤–ï¼Œå¶æ•°å°±æ˜¯å–å‡ºï¼Œå¥‡æ•°å°±æ˜¯ä¹°å…¥ã€‚
# é¢˜ç›®è¦æ±‚æ˜¯è‡³å¤šæœ‰Kç¬”äº¤æ˜“ï¼Œé‚£ä¹ˆjçš„èŒƒå›´å°±å®šä¹‰ä¸º 2 * k + 1 å°±å¯ä»¥äº†ã€‚
# è¿˜è¦å¼ºè°ƒä¸€ä¸‹ï¼šdp[i][1]ï¼Œè¡¨ç¤ºçš„æ˜¯ç¬¬iå¤©ï¼Œä¹°å…¥è‚¡ç¥¨çš„çŠ¶æ€ï¼Œå¹¶ä¸æ˜¯è¯´ä¸€å®šè¦ç¬¬iå¤©ä¹°å…¥è‚¡ç¥¨ï¼Œè¿™æ˜¯å¾ˆå¤šåŒå­¦å®¹æ˜“é™·å…¥çš„è¯¯åŒºã€‚
# è¾¾åˆ°dp[i][1]çŠ¶æ€ï¼Œæœ‰ä¸¤ä¸ªå…·ä½“æ“ä½œï¼š
# æ“ä½œä¸€ï¼šç¬¬iå¤©ä¹°å…¥è‚¡ç¥¨äº†ï¼Œé‚£ä¹ˆdp[i][1] = dp[i - 1][0] - prices[i]
# æ“ä½œäºŒï¼šç¬¬iå¤©æ²¡æœ‰æ“ä½œï¼Œè€Œæ˜¯æ²¿ç”¨å‰ä¸€å¤©ä¹°å…¥çš„çŠ¶æ€ï¼Œå³ï¼šdp[i][1] = dp[i - 1][1]
# é€‰æœ€å¤§çš„ï¼Œæ‰€ä»¥ dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1]);
# åŒç†dp[i][2]ä¹Ÿæœ‰ä¸¤ä¸ªæ“ä½œï¼š
# æ“ä½œä¸€ï¼šç¬¬iå¤©å–å‡ºè‚¡ç¥¨äº†ï¼Œé‚£ä¹ˆdp[i][2] = dp[i - 1][1] + prices[i]
# æ“ä½œäºŒï¼šç¬¬iå¤©æ²¡æœ‰æ“ä½œï¼Œæ²¿ç”¨å‰ä¸€å¤©å–å‡ºè‚¡ç¥¨çš„çŠ¶æ€ï¼Œå³ï¼šdp[i][2] = dp[i - 1][2]
# æ‰€ä»¥dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])
# *** ç‰ˆæœ¬ä¸€ 2D
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if len(prices) == 0:
            return 0
        dp = [[0] * (2*k+1) for _ in range(len(prices))]
        for j in range(1, 2*k, 2):
            dp[0][j] = -prices[0]
        for i in range(1, len(prices)):
            for j in range(0, 2*k-1, 2):
                dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j] - prices[i])
                dp[i][j+2] = max(dp[i-1][j+2], dp[i-1][j+1] + prices[i])
        return dp[-1][2*k]
# ç‰ˆæœ¬äºŒ 1D
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if len(prices) == 0: return 0
        dp = [0] * (2*k + 1)
        for i in range(1,2*k,2):
            dp[i] = -prices[0]
        for i in range(1,len(prices)):
            for j in range(1,2*k + 1):
                if j % 2:
                    dp[j] = max(dp[j],dp[j-1]-prices[i])
                else:
                    dp[j] = max(dp[j],dp[j-1]+prices[i])
        return dp[2*k]


#28 ??? (Medium) 309.æœ€ä½³ä¹°å–è‚¡ç¥¨æ—¶æœºå«å†·å†»æœŸ
    # ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œå…¶ä¸­ç¬¬ i ä¸ªå…ƒç´ ä»£è¡¨äº†ç¬¬ i å¤©çš„è‚¡ç¥¨ä»·æ ¼ ã€‚
    # è®¾è®¡ä¸€ä¸ªç®—æ³•è®¡ç®—å‡ºæœ€å¤§åˆ©æ¶¦ã€‚åœ¨æ»¡è¶³ä»¥ä¸‹çº¦æŸæ¡ä»¶ä¸‹ï¼Œä½ å¯ä»¥å°½å¯èƒ½åœ°å®Œæˆæ›´å¤šçš„äº¤æ˜“ï¼ˆå¤šæ¬¡ä¹°å–ä¸€æ”¯è‚¡ç¥¨ï¼‰:
    # ä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚
    # å–å‡ºè‚¡ç¥¨åï¼Œä½ æ— æ³•åœ¨ç¬¬äºŒå¤©ä¹°å…¥è‚¡ç¥¨ (å³å†·å†»æœŸä¸º 1 å¤©)ã€‚
    # ç¤ºä¾‹:
    # è¾“å…¥: [1,2,3,0,2]
    # è¾“å‡º: 3
    # è§£é‡Š: å¯¹åº”çš„äº¤æ˜“çŠ¶æ€ä¸º: [ä¹°å…¥, å–å‡º, å†·å†»æœŸ, ä¹°å…¥, å–å‡º]
# dp[i][j]ï¼Œç¬¬iå¤©çŠ¶æ€ä¸ºjï¼Œæ‰€å‰©çš„æœ€å¤šç°é‡‘ä¸ºdp[i][j]ã€‚
# å…¶å®æœ¬é¢˜å¾ˆå¤šåŒå­¦æçš„æ¯”è¾ƒæ‡µï¼Œæ˜¯å› ä¸ºå‡ºç°å†·å†»æœŸä¹‹åï¼ŒçŠ¶æ€å…¶å®æ˜¯æ¯”è¾ƒå¤æ‚åº¦ï¼Œä¾‹å¦‚ä»Šå¤©ä¹°å…¥è‚¡ç¥¨ã€ä»Šå¤©å–å‡ºè‚¡ç¥¨ã€ä»Šå¤©æ˜¯å†·å†»æœŸï¼Œéƒ½æ˜¯ä¸èƒ½æ“ä½œè‚¡ç¥¨çš„ã€‚
# å…·ä½“å¯ä»¥åŒºåˆ†å‡ºå¦‚ä¸‹å››ä¸ªçŠ¶æ€ï¼š
# çŠ¶æ€ä¸€ï¼šæŒæœ‰è‚¡ç¥¨çŠ¶æ€ï¼ˆä»Šå¤©ä¹°å…¥è‚¡ç¥¨ï¼Œæˆ–è€…æ˜¯ä¹‹å‰å°±ä¹°å…¥äº†è‚¡ç¥¨ç„¶åæ²¡æœ‰æ“ä½œï¼Œä¸€ç›´æŒæœ‰ï¼‰
# ä¸æŒæœ‰è‚¡ç¥¨çŠ¶æ€ï¼Œè¿™é‡Œå°±æœ‰ä¸¤ç§å–å‡ºè‚¡ç¥¨çŠ¶æ€
# çŠ¶æ€äºŒï¼šä¿æŒå–å‡ºè‚¡ç¥¨çš„çŠ¶æ€ï¼ˆä¸¤å¤©å‰å°±å–å‡ºäº†è‚¡ç¥¨ï¼Œåº¦è¿‡ä¸€å¤©å†·å†»æœŸã€‚æˆ–è€…æ˜¯å‰ä¸€å¤©å°±æ˜¯å–å‡ºè‚¡ç¥¨çŠ¶æ€ï¼Œä¸€ç›´æ²¡æ“ä½œï¼‰
# çŠ¶æ€ä¸‰ï¼šä»Šå¤©å–å‡ºè‚¡ç¥¨
# çŠ¶æ€å››ï¼šä»Šå¤©ä¸ºå†·å†»æœŸçŠ¶æ€ï¼Œä½†å†·å†»æœŸçŠ¶æ€ä¸å¯æŒç»­ï¼Œåªæœ‰ä¸€å¤©ï¼
# è¾¾åˆ°ä¹°å…¥è‚¡ç¥¨çŠ¶æ€ï¼ˆçŠ¶æ€ä¸€ï¼‰å³ï¼šdp[i][0]ï¼Œæœ‰ä¸¤ä¸ªå…·ä½“æ“ä½œï¼š
# æ“ä½œä¸€ï¼šå‰ä¸€å¤©å°±æ˜¯æŒæœ‰è‚¡ç¥¨çŠ¶æ€ï¼ˆçŠ¶æ€ä¸€ï¼‰ï¼Œdp[i][0] = dp[i - 1][0]
# æ“ä½œäºŒï¼šä»Šå¤©ä¹°å…¥äº†ï¼Œæœ‰ä¸¤ç§æƒ…å†µ
# å‰ä¸€å¤©æ˜¯å†·å†»æœŸï¼ˆçŠ¶æ€å››ï¼‰ï¼Œdp[i - 1][3] - prices[i]
# å‰ä¸€å¤©æ˜¯ä¿æŒå–å‡ºè‚¡ç¥¨çš„çŠ¶æ€ï¼ˆçŠ¶æ€äºŒï¼‰ï¼Œdp[i - 1][1] - prices[i]
# é‚£ä¹ˆdp[i][0] = max(dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]);
# è¾¾åˆ°ä¿æŒå–å‡ºè‚¡ç¥¨çŠ¶æ€ï¼ˆçŠ¶æ€äºŒï¼‰å³ï¼šdp[i][1]ï¼Œæœ‰ä¸¤ä¸ªå…·ä½“æ“ä½œï¼š
# æ“ä½œä¸€ï¼šå‰ä¸€å¤©å°±æ˜¯çŠ¶æ€äºŒ
# æ“ä½œäºŒï¼šå‰ä¸€å¤©æ˜¯å†·å†»æœŸï¼ˆçŠ¶æ€å››ï¼‰
# dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
# è¾¾åˆ°ä»Šå¤©å°±å–å‡ºè‚¡ç¥¨çŠ¶æ€ï¼ˆçŠ¶æ€ä¸‰ï¼‰ï¼Œå³ï¼šdp[i][2] ï¼Œåªæœ‰ä¸€ä¸ªæ“ä½œï¼š
# æ˜¨å¤©ä¸€å®šæ˜¯æŒæœ‰è‚¡ç¥¨çŠ¶æ€ï¼ˆçŠ¶æ€ä¸€ï¼‰ï¼Œä»Šå¤©å–å‡º
# å³ï¼šdp[i][2] = dp[i - 1][0] + prices[i];
# è¾¾åˆ°å†·å†»æœŸçŠ¶æ€ï¼ˆçŠ¶æ€å››ï¼‰ï¼Œå³ï¼šdp[i][3]ï¼Œåªæœ‰ä¸€ä¸ªæ“ä½œï¼š
# æ˜¨å¤©å–å‡ºäº†è‚¡ç¥¨ï¼ˆçŠ¶æ€ä¸‰ï¼‰
# dp[i][3] = dp[i - 1][2];
# ç‰ˆæœ¬ä¸€
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0:
            return 0
        dp = [[0] * 4 for _ in range(n)]  # åˆ›å»ºåŠ¨æ€è§„åˆ’æ•°ç»„,4ä¸ªçŠ¶æ€åˆ†åˆ«è¡¨ç¤ºæŒæœ‰è‚¡ç¥¨ã€ä¸æŒæœ‰è‚¡ç¥¨ä¸”å¤„äºå†·å†»æœŸã€ä¸æŒæœ‰è‚¡ç¥¨ä¸”ä¸å¤„äºå†·å†»æœŸã€ä¸æŒæœ‰è‚¡ç¥¨ä¸”å½“å¤©å–å‡ºåå¤„äºå†·å†»æœŸ
        dp[0][0] = -prices[0]  # åˆå§‹çŠ¶æ€:ç¬¬ä¸€å¤©æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦ä¸ºä¹°å…¥è‚¡ç¥¨çš„ä»·æ ¼
        for i in range(1, n):
            dp[i][0] = max(dp[i-1][0], max(dp[i-1][3], dp[i-1][1]) - prices[i])  # å½“å‰æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦ç­‰äºå‰ä¸€å¤©æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦æˆ–è€…å‰ä¸€å¤©ä¸æŒæœ‰è‚¡ç¥¨ä¸”ä¸å¤„äºå†·å†»æœŸçš„æœ€å¤§åˆ©æ¶¦å‡å»å½“å‰è‚¡ç¥¨çš„ä»·æ ¼
            dp[i][1] = max(dp[i-1][1], dp[i-1][3])  # å½“å‰ä¸æŒæœ‰è‚¡ç¥¨ä¸”å¤„äºå†·å†»æœŸçš„æœ€å¤§åˆ©æ¶¦ç­‰äºå‰ä¸€å¤©æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦åŠ ä¸Šå½“å‰è‚¡ç¥¨çš„ä»·æ ¼
            dp[i][2] = dp[i-1][0] + prices[i]  # å½“å‰ä¸æŒæœ‰è‚¡ç¥¨ä¸”ä¸å¤„äºå†·å†»æœŸçš„æœ€å¤§åˆ©æ¶¦ç­‰äºå‰ä¸€å¤©ä¸æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦æˆ–è€…å‰ä¸€å¤©å¤„äºå†·å†»æœŸçš„æœ€å¤§åˆ©æ¶¦
            dp[i][3] = dp[i-1][2]  # å½“å‰ä¸æŒæœ‰è‚¡ç¥¨ä¸”å½“å¤©å–å‡ºåå¤„äºå†·å†»æœŸçš„æœ€å¤§åˆ©æ¶¦ç­‰äºå‰ä¸€å¤©ä¸æŒæœ‰è‚¡ç¥¨ä¸”ä¸å¤„äºå†·å†»æœŸçš„æœ€å¤§åˆ©æ¶¦
        return max(dp[n-1][3], dp[n-1][1], dp[n-1][2])  # è¿”å›æœ€åä¸€å¤©ä¸æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦
# ä¼˜åŒ–
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0:
            return 0
        dp = [[0] * 4 for _ in range(2)]  # åˆ›å»ºåŠ¨æ€è§„åˆ’æ•°ç»„,4ä¸ªçŠ¶æ€åˆ†åˆ«è¡¨ç¤ºæŒæœ‰è‚¡ç¥¨ã€ä¸æŒæœ‰è‚¡ç¥¨ä¸”å¤„äºå†·å†»æœŸã€ä¸æŒæœ‰è‚¡ç¥¨ä¸”ä¸å¤„äºå†·å†»æœŸã€ä¸æŒæœ‰è‚¡ç¥¨ä¸”å½“å¤©å–å‡ºåå¤„äºå†·å†»æœŸ
        dp[0][0] = -prices[0]  # åˆå§‹çŠ¶æ€:ç¬¬ä¸€å¤©æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦ä¸ºä¹°å…¥è‚¡ç¥¨çš„ä»·æ ¼
        for i in range(1, n):
            dp[i%2][0] = max(dp[((i-1)%2)%2][0], max(dp[(i-1)%2][3], dp[(i-1)%2][1]) - prices[i])  # å½“å‰æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦ç­‰äºå‰ä¸€å¤©æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦æˆ–è€…å‰ä¸€å¤©ä¸æŒæœ‰è‚¡ç¥¨ä¸”ä¸å¤„äºå†·å†»æœŸçš„æœ€å¤§åˆ©æ¶¦å‡å»å½“å‰è‚¡ç¥¨çš„ä»·æ ¼
            dp[i%2][1] = max(dp[(i-1)%2][1], dp[(i-1)%2][3])  # å½“å‰ä¸æŒæœ‰è‚¡ç¥¨ä¸”å¤„äºå†·å†»æœŸçš„æœ€å¤§åˆ©æ¶¦ç­‰äºå‰ä¸€å¤©æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦åŠ ä¸Šå½“å‰è‚¡ç¥¨çš„ä»·æ ¼
            dp[i%2][2] = dp[(i-1)%2][0] + prices[i]  # å½“å‰ä¸æŒæœ‰è‚¡ç¥¨ä¸”ä¸å¤„äºå†·å†»æœŸçš„æœ€å¤§åˆ©æ¶¦ç­‰äºå‰ä¸€å¤©ä¸æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦æˆ–è€…å‰ä¸€å¤©å¤„äºå†·å†»æœŸçš„æœ€å¤§åˆ©æ¶¦
            dp[i%2][3] = dp[(i-1)%2][2]  # å½“å‰ä¸æŒæœ‰è‚¡ç¥¨ä¸”å½“å¤©å–å‡ºåå¤„äºå†·å†»æœŸçš„æœ€å¤§åˆ©æ¶¦ç­‰äºå‰ä¸€å¤©ä¸æŒæœ‰è‚¡ç¥¨ä¸”ä¸å¤„äºå†·å†»æœŸçš„æœ€å¤§åˆ©æ¶¦
        return max(dp[(n-1)%2][3], dp[(n-1)%2][1], dp[(n-1)%2][2])  # è¿”å›æœ€åä¸€å¤©ä¸æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦
# ç‰ˆæœ¬äºŒ
# class Solution:
#     def maxProfit(self, prices: List[int]) -> int:
#         n = len(prices)
#         if n < 2:
#             return 0

#         # å®šä¹‰ä¸‰ç§çŠ¶æ€çš„åŠ¨æ€è§„åˆ’æ•°ç»„
#         dp = [[0] * 3 for _ in range(n)]
#         dp[0][0] = -prices[0]  # æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦
#         dp[0][1] = 0           # ä¸æŒæœ‰è‚¡ç¥¨,ä¸”å¤„äºå†·å†»æœŸçš„æœ€å¤§åˆ©æ¶¦
#         dp[0][2] = 0           # ä¸æŒæœ‰è‚¡ç¥¨,ä¸å¤„äºå†·å†»æœŸçš„æœ€å¤§åˆ©æ¶¦

#         for i in range(1, n):
#             # å½“å‰æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦ç­‰äºå‰ä¸€å¤©æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦æˆ–è€…å‰ä¸€å¤©ä¸æŒæœ‰è‚¡ç¥¨ä¸”ä¸å¤„äºå†·å†»æœŸçš„æœ€å¤§åˆ©æ¶¦å‡å»å½“å‰è‚¡ç¥¨çš„ä»·æ ¼
#             dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i])
#             # å½“å‰ä¸æŒæœ‰è‚¡ç¥¨ä¸”å¤„äºå†·å†»æœŸçš„æœ€å¤§åˆ©æ¶¦ç­‰äºå‰ä¸€å¤©æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦åŠ ä¸Šå½“å‰è‚¡ç¥¨çš„ä»·æ ¼
#             dp[i][1] = dp[i-1][0] + prices[i]
#             # å½“å‰ä¸æŒæœ‰è‚¡ç¥¨ä¸”ä¸å¤„äºå†·å†»æœŸçš„æœ€å¤§åˆ©æ¶¦ç­‰äºå‰ä¸€å¤©ä¸æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦æˆ–è€…å‰ä¸€å¤©å¤„äºå†·å†»æœŸçš„æœ€å¤§åˆ©æ¶¦
#             dp[i][2] = max(dp[i-1][2], dp[i-1][1])

#         # è¿”å›æœ€åä¸€å¤©ä¸æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦
#         return max(dp[-1][1], dp[-1][2])


#29 (Medium) 714.ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºå«æ‰‹ç»­è´¹
    # ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ pricesï¼Œå…¶ä¸­ç¬¬ i ä¸ªå…ƒç´ ä»£è¡¨äº†ç¬¬ i å¤©çš„è‚¡ç¥¨ä»·æ ¼ ï¼›éè´Ÿæ•´æ•° fee ä»£è¡¨äº†äº¤æ˜“è‚¡ç¥¨çš„æ‰‹ç»­è´¹ç”¨ã€‚
    # ä½ å¯ä»¥æ— é™æ¬¡åœ°å®Œæˆäº¤æ˜“ï¼Œä½†æ˜¯ä½ æ¯ç¬”äº¤æ˜“éƒ½éœ€è¦ä»˜æ‰‹ç»­è´¹ã€‚å¦‚æœä½ å·²ç»è´­ä¹°äº†ä¸€ä¸ªè‚¡ç¥¨ï¼Œåœ¨å–å‡ºå®ƒä¹‹å‰ä½ å°±ä¸èƒ½å†ç»§ç»­è´­ä¹°è‚¡ç¥¨äº†ã€‚
    # è¿”å›è·å¾—åˆ©æ¶¦çš„æœ€å¤§å€¼ã€‚
    # æ³¨æ„ï¼šè¿™é‡Œçš„ä¸€ç¬”äº¤æ˜“æŒ‡ä¹°å…¥æŒæœ‰å¹¶å–å‡ºè‚¡ç¥¨çš„æ•´ä¸ªè¿‡ç¨‹ï¼Œæ¯ç¬”äº¤æ˜“ä½ åªéœ€è¦ä¸ºæ”¯ä»˜ä¸€æ¬¡æ‰‹ç»­è´¹ã€‚
    # ç¤ºä¾‹ 1:
    # è¾“å…¥: prices = [1, 3, 2, 8, 4, 9], fee = 2
    # è¾“å‡º: 8
    # è§£é‡Š: èƒ½å¤Ÿè¾¾åˆ°çš„æœ€å¤§åˆ©æ¶¦:
    # åœ¨æ­¤å¤„ä¹°å…¥ prices[0] = 1
    # åœ¨æ­¤å¤„å–å‡º prices[3] = 8
    # åœ¨æ­¤å¤„ä¹°å…¥ prices[4] = 4
    # åœ¨æ­¤å¤„å–å‡º prices[5] = 9
    # æ€»åˆ©æ¶¦: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
# dp[i][0] è¡¨ç¤ºç¬¬iå¤©æŒæœ‰è‚¡ç¥¨æ‰€çœæœ€å¤šç°é‡‘ã€‚ dp[i][1] è¡¨ç¤ºç¬¬iå¤©ä¸æŒæœ‰è‚¡ç¥¨æ‰€å¾—æœ€å¤šç°é‡‘
# å¦‚æœç¬¬iå¤©æŒæœ‰è‚¡ç¥¨å³dp[i][0]ï¼Œ é‚£ä¹ˆå¯ä»¥ç”±ä¸¤ä¸ªçŠ¶æ€æ¨å‡ºæ¥
# ç¬¬i-1å¤©å°±æŒæœ‰è‚¡ç¥¨ï¼Œé‚£ä¹ˆå°±ä¿æŒç°çŠ¶ï¼Œæ‰€å¾—ç°é‡‘å°±æ˜¯æ˜¨å¤©æŒæœ‰è‚¡ç¥¨çš„æ‰€å¾—ç°é‡‘ å³ï¼šdp[i - 1][0]
# ç¬¬iå¤©ä¹°å…¥è‚¡ç¥¨ï¼Œæ‰€å¾—ç°é‡‘å°±æ˜¯æ˜¨å¤©ä¸æŒæœ‰è‚¡ç¥¨çš„æ‰€å¾—ç°é‡‘å‡å» ä»Šå¤©çš„è‚¡ç¥¨ä»·æ ¼ å³ï¼šdp[i - 1][1] - prices[i]
# æ‰€ä»¥ï¼šdp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
# åœ¨æ¥çœ‹çœ‹å¦‚æœç¬¬iå¤©ä¸æŒæœ‰è‚¡ç¥¨å³dp[i][1]çš„æƒ…å†µï¼Œ ä¾ç„¶å¯ä»¥ç”±ä¸¤ä¸ªçŠ¶æ€æ¨å‡ºæ¥
# ç¬¬i-1å¤©å°±ä¸æŒæœ‰è‚¡ç¥¨ï¼Œé‚£ä¹ˆå°±ä¿æŒç°çŠ¶ï¼Œæ‰€å¾—ç°é‡‘å°±æ˜¯æ˜¨å¤©ä¸æŒæœ‰è‚¡ç¥¨çš„æ‰€å¾—ç°é‡‘ å³ï¼šdp[i - 1][1]
# ç¬¬iå¤©å–å‡ºè‚¡ç¥¨ï¼Œæ‰€å¾—ç°é‡‘å°±æ˜¯æŒ‰ç…§ä»Šå¤©è‚¡ç¥¨ä»·æ ¼å–å‡ºåæ‰€å¾—ç°é‡‘ï¼Œæ³¨æ„è¿™é‡Œéœ€è¦æœ‰æ‰‹ç»­è´¹äº†å³ï¼šdp[i - 1][0] + prices[i] - fee
# æ‰€ä»¥ï¼šdp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
# æ³¨æ„:è¿™é‡Œçš„ä¸€ç¬”äº¤æ˜“æŒ‡ä¹°å…¥æŒæœ‰å¹¶å–å‡ºè‚¡ç¥¨çš„æ•´ä¸ªè¿‡ç¨‹,æ¯ç¬”äº¤æ˜“ä½ åªéœ€è¦ä¸ºæ”¯ä»˜ä¸€æ¬¡æ‰‹ç»­è´¹ã€‚
# å–å‡ºçš„æ—¶åˆ»æ‰éœ€è¦äº¤fee
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        n = len(prices)
        dp = [[0] * 2 for _ in range(n)]
        dp[0][0] = -prices[0] #æŒè‚¡ç¥¨
        for i in range(1, n):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee)
        return max(dp[-1][0], dp[-1][1])


"""
5. å­åºåˆ—ç³»åˆ— (12)

åŠ¨æ€è§„åˆ’:æœ€é•¿é€’å¢å­åºåˆ—
åŠ¨æ€è§„åˆ’:æœ€é•¿è¿ç»­é€’å¢åºåˆ—
åŠ¨æ€è§„åˆ’:æœ€é•¿é‡å¤å­æ•°ç»„
åŠ¨æ€è§„åˆ’:æœ€é•¿å…¬å…±å­åºåˆ—
åŠ¨æ€è§„åˆ’:ä¸ç›¸äº¤çš„çº¿
åŠ¨æ€è§„åˆ’:æœ€å¤§å­åºå’Œ
åŠ¨æ€è§„åˆ’:åˆ¤æ–­å­åºåˆ—
åŠ¨æ€è§„åˆ’:ä¸åŒçš„å­åºåˆ—
åŠ¨æ€è§„åˆ’:ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ é™¤æ“ä½œ
åŠ¨æ€è§„åˆ’:ç¼–è¾‘è·ç¦»
ä¸ºäº†ç»æ€ç¼–è¾‘è·ç¦»,æˆ‘åšäº†ä¸‰æ­¥é“ºå«,ä½ éƒ½çŸ¥é“ä¹ˆï¼Ÿ
åŠ¨æ€è§„åˆ’:å›æ–‡å­ä¸²
åŠ¨æ€è§„åˆ’:æœ€é•¿å›æ–‡å­åºåˆ—
"""
#30 (Medium) 300.æœ€é•¿é€’å¢å­åºåˆ— (ä¸è¿ç»­)
    # ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾åˆ°å…¶ä¸­æœ€é•¿ä¸¥æ ¼é€’å¢å­åºåˆ—çš„é•¿åº¦ã€‚
    # å­åºåˆ—æ˜¯ç”±æ•°ç»„æ´¾ç”Ÿè€Œæ¥çš„åºåˆ—ï¼Œåˆ é™¤ï¼ˆæˆ–ä¸åˆ é™¤ï¼‰æ•°ç»„ä¸­çš„å…ƒç´ è€Œä¸æ”¹å˜å…¶ä½™å…ƒç´ çš„é¡ºåºã€‚ä¾‹å¦‚ï¼Œ[3,6,2,7] æ˜¯æ•°ç»„ [0,3,1,6,2,2,7] çš„å­åºåˆ—ã€‚
    # ç¤ºä¾‹ 1ï¼š
    # è¾“å…¥ï¼šnums = [10,9,2,5,3,7,101,18]
    # è¾“å‡ºï¼š4
    # è§£é‡Šï¼šæœ€é•¿é€’å¢å­åºåˆ—æ˜¯ [2,3,7,101]ï¼Œå› æ­¤é•¿åº¦ä¸º 4 ã€‚
    # ç¤ºä¾‹ 2ï¼š
    # è¾“å…¥ï¼šnums = [0,1,0,3,2,3]
    # è¾“å‡ºï¼š4
    # ç¤ºä¾‹ 3ï¼š
    # è¾“å…¥ï¼šnums = [7,7,7,7,7,7,7]
    # è¾“å‡ºï¼š1
# å­åºåˆ—æ˜¯ç”±æ•°ç»„æ´¾ç”Ÿè€Œæ¥çš„åºåˆ—ï¼Œåˆ é™¤ï¼ˆæˆ–ä¸åˆ é™¤ï¼‰æ•°ç»„ä¸­çš„å…ƒç´ è€Œä¸æ”¹å˜å…¶ä½™å…ƒç´ çš„é¡ºåº
# dp[i]è¡¨ç¤ºiä¹‹å‰åŒ…æ‹¬içš„ä»¥nums[i]ç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦
# ä¸ºä»€ä¹ˆä¸€å®šè¡¨ç¤º â€œä»¥nums[i]ç»“å°¾çš„æœ€é•¿é€’å¢å­åºâ€ ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨ åš é€’å¢æ¯”è¾ƒçš„æ—¶å€™ï¼Œå¦‚æœæ¯”è¾ƒ nums[j] å’Œ nums[i] çš„å¤§å°ï¼Œ
# é‚£ä¹ˆä¸¤ä¸ªé€’å¢å­åºåˆ—ä¸€å®šåˆ†åˆ«ä»¥nums[j]ä¸ºç»“å°¾ å’Œ nums[i]ä¸ºç»“å°¾ï¼Œ è¦ä¸ç„¶è¿™ä¸ªæ¯”è¾ƒå°±æ²¡æœ‰æ„ä¹‰äº†ï¼Œä¸æ˜¯å°¾éƒ¨å…ƒç´ çš„æ¯”è¾ƒé‚£ä¹ˆ å¦‚ä½•ç®—é€’å¢å‘¢ã€‚
# ä½ç½®içš„æœ€é•¿å‡åºå­åºåˆ—ç­‰äºjä»0åˆ°i-1å„ä¸ªä½ç½®çš„æœ€é•¿å‡åºå­åºåˆ— + 1 çš„æœ€å¤§å€¼ã€‚
# æ‰€ä»¥ï¼šif (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1)
# æ³¨æ„è¿™é‡Œä¸æ˜¯è¦dp[i] ä¸ dp[j] + 1è¿›è¡Œæ¯”è¾ƒï¼Œè€Œæ˜¯æˆ‘ä»¬è¦å–dp[j] + 1çš„æœ€å¤§å€¼ã€‚
# DP
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if len(nums) <= 1:
            return len(nums)
        # dp[i]è¡¨ç¤ºiä¹‹å‰åŒ…æ‹¬içš„ä»¥nums[i]ç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦
        dp = [1] * len(nums)
        result = 1
        for i in range(1, len(nums)):
            for j in range(0, i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
            result = max(result, dp[i]) #å–é•¿çš„å­åºåˆ—
        return result
# è´ªå¿ƒ
# class Solution:
#     def lengthOfLIS(self, nums: List[int]) -> int:
#         if len(nums) <= 1:
#             return len(nums)
        
#         tails = [nums[0]]  # å­˜å‚¨é€’å¢å­åºåˆ—çš„å°¾éƒ¨å…ƒç´ 
#         for num in nums[1:]:
#             if num > tails[-1]:
#                 tails.append(num)  # å¦‚æœå½“å‰å…ƒç´ å¤§äºé€’å¢å­åºåˆ—çš„æœ€åä¸€ä¸ªå…ƒç´ ,ç›´æ¥åŠ å…¥åˆ°å­åºåˆ—æœ«å°¾
#             else:
#                 # ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾æ‰¾åˆ°å½“å‰å…ƒç´ åœ¨é€’å¢å­åºåˆ—ä¸­çš„ä½ç½®,å¹¶æ›¿æ¢å¯¹åº”ä½ç½®çš„å…ƒç´ 
#                 left, right = 0, len(tails) - 1
#                 while left < right:
#                     mid = (left + right) // 2
#                     if tails[mid] < num:
#                         left = mid + 1
#                     else:
#                         right = mid
#                 tails[left] = num
#         return len(tails)  # è¿”å›é€’å¢å­åºåˆ—çš„é•¿åº¦


#31 (Easy) 674.æœ€é•¿è¿ç»­é€’å¢åºåˆ— (è¿ç»­)
    # ç»™å®šä¸€ä¸ªæœªç»æ’åºçš„æ•´æ•°æ•°ç»„ï¼Œæ‰¾åˆ°æœ€é•¿ä¸” è¿ç»­é€’å¢çš„å­åºåˆ—ï¼Œå¹¶è¿”å›è¯¥åºåˆ—çš„é•¿åº¦ã€‚
    # è¿ç»­é€’å¢çš„å­åºåˆ— å¯ä»¥ç”±ä¸¤ä¸ªä¸‹æ ‡ l å’Œ rï¼ˆl < rï¼‰ç¡®å®šï¼Œå¦‚æœå¯¹äºæ¯ä¸ª l <= i < rï¼Œéƒ½æœ‰ nums[i] < nums[i + 1] ï¼Œé‚£ä¹ˆå­åºåˆ— [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] å°±æ˜¯è¿ç»­é€’å¢å­åºåˆ—ã€‚
    # ç¤ºä¾‹ 1ï¼š
    # è¾“å…¥ï¼šnums = [1,3,5,4,7]
    # è¾“å‡ºï¼š3
    # è§£é‡Šï¼šæœ€é•¿è¿ç»­é€’å¢åºåˆ—æ˜¯ [1,3,5], é•¿åº¦ä¸º3ã€‚å°½ç®¡ [1,3,5,7] ä¹Ÿæ˜¯å‡åºçš„å­åºåˆ—, ä½†å®ƒä¸æ˜¯è¿ç»­çš„ï¼Œå› ä¸º 5 å’Œ 7 åœ¨åŸæ•°ç»„é‡Œè¢« 4 éš”å¼€ã€‚
    # ç¤ºä¾‹ 2ï¼š
    # è¾“å…¥ï¼šnums = [2,2,2,2,2]
    # è¾“å‡ºï¼š1
    # è§£é‡Šï¼šæœ€é•¿è¿ç»­é€’å¢åºåˆ—æ˜¯ [2], é•¿åº¦ä¸º1ã€‚
# dp[i]ï¼šä»¥ä¸‹æ ‡iä¸ºç»“å°¾çš„è¿ç»­é€’å¢çš„å­åºåˆ—é•¿åº¦ä¸ºdp[i]ã€‚
# æ³¨æ„è¿™é‡Œçš„å®šä¹‰ï¼Œä¸€å®šæ˜¯ä»¥ä¸‹æ ‡iä¸ºç»“å°¾ï¼Œå¹¶ä¸æ˜¯è¯´ä¸€å®šä»¥ä¸‹æ ‡0ä¸ºèµ·å§‹ä½ç½®ã€‚
# å¦‚æœ nums[i] > nums[i - 1]ï¼Œé‚£ä¹ˆä»¥ i ä¸ºç»“å°¾çš„è¿ç»­é€’å¢çš„å­åºåˆ—é•¿åº¦ ä¸€å®šç­‰äº ä»¥i - 1ä¸ºç»“å°¾çš„è¿ç»­é€’å¢çš„å­åºåˆ—é•¿åº¦ + 1 ã€‚
# å³ï¼šdp[i] = dp[i - 1] + 1;
# æ¦‚æ‹¬æ¥è¯´ï¼šä¸è¿ç»­é€’å¢å­åºåˆ—çš„è·Ÿå‰0-i ä¸ªçŠ¶æ€æœ‰å…³ï¼Œè¿ç»­é€’å¢çš„å­åºåˆ—åªè·Ÿå‰ä¸€ä¸ªçŠ¶æ€æœ‰å…³
# DP
class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        if len(nums) == 0:
            return 0
        result = 1
        # dp[i]ï¼šä»¥ä¸‹æ ‡iä¸ºç»“å°¾çš„è¿ç»­é€’å¢çš„å­åºåˆ—é•¿åº¦ä¸ºdp[i]ã€‚
        dp = [1] * len(nums)
        for i in range(len(nums)-1):
            if nums[i+1] > nums[i]: #è¿ç»­è®°å½•
                dp[i+1] = dp[i] + 1
            result = max(result, dp[i+1])
        return result
# DP(ä¼˜åŒ–ç‰ˆ)
# class Solution:
#     def findLengthOfLCIS(self, nums: List[int]) -> int:
#         if not nums:
#             return 0

#         max_length = 1
#         current_length = 1

#         for i in range(1, len(nums)):
#             if nums[i] > nums[i - 1]:
#                 current_length += 1
#                 max_length = max(max_length, current_length)
#             else:
#                 current_length = 1

#         return max_length
# # è´ªå¿ƒ
# class Solution:
#     def findLengthOfLCIS(self, nums: List[int]) -> int:
#         if len(nums) == 0:
#             return 0
#         result = 1 #è¿ç»­å­åºåˆ—æœ€å°‘ä¹Ÿæ˜¯1
#         count = 1
#         for i in range(len(nums)-1):
#             if nums[i+1] > nums[i]: #è¿ç»­è®°å½•
#                 count += 1
#             else: #ä¸è¿ç»­,countä»å¤´å¼€å§‹
#                 count = 1
#             result = max(result, count)
#         return result


#X32 *** (Medium) 718.æœ€é•¿é‡å¤å­æ•°ç»„ (è¿ç»­)
# ä¸¤ä¸ªæ•´æ•°æ•°ç»„
    # ç»™ä¸¤ä¸ªæ•´æ•°æ•°ç»„ A å’Œ B ï¼Œè¿”å›ä¸¤ä¸ªæ•°ç»„ä¸­å…¬å…±çš„ã€é•¿åº¦æœ€é•¿çš„å­æ•°ç»„sub arrayçš„é•¿åº¦ã€‚
    # ç¤ºä¾‹ï¼š
    # è¾“å…¥ï¼š
    # A: [1,2,3,2,1]
    # B: [3,2,1,4,7]
    # è¾“å‡ºï¼š3
    # è§£é‡Šï¼šé•¿åº¦æœ€é•¿çš„å…¬å…±å­æ•°ç»„æ˜¯ [3, 2, 1] ã€‚
# dp[i][j] ï¼šä»¥ä¸‹æ ‡i - 1ä¸ºç»“å°¾çš„Aï¼Œå’Œä»¥ä¸‹æ ‡j - 1ä¸ºç»“å°¾çš„Bï¼Œæœ€é•¿é‡å¤å­æ•°ç»„é•¿åº¦ä¸ºdp[i][j]ã€‚ 
# ï¼ˆç‰¹åˆ«æ³¨æ„ï¼š â€œä»¥ä¸‹æ ‡i - 1ä¸ºç»“å°¾çš„Aâ€ æ ‡æ˜ä¸€å®šæ˜¯ ä»¥A[i-1]ä¸ºç»“å°¾çš„å­—ç¬¦ä¸² ï¼‰
# æ­¤æ—¶ç»†å¿ƒçš„åŒå­¦åº”è¯¥å‘ç°ï¼Œé‚£dp[0][0]æ˜¯ä»€ä¹ˆå«ä¹‰å‘¢ï¼Ÿæ€»ä¸èƒ½æ˜¯ä»¥ä¸‹æ ‡-1ä¸ºç»“å°¾çš„Aæ•°ç»„å§ã€‚
# å…¶å®dp[i][j]çš„å®šä¹‰ä¹Ÿå°±å†³å®šç€ï¼Œæˆ‘ä»¬åœ¨éå†dp[i][j]çš„æ—¶å€™i å’Œ jéƒ½è¦ä»1å¼€å§‹ã€‚
# é‚£æœ‰åŒå­¦é—®äº†ï¼Œæˆ‘å°±å®šä¹‰dp[i][j]ä¸º ä»¥ä¸‹æ ‡iä¸ºç»“å°¾çš„Aï¼Œå’Œä»¥ä¸‹æ ‡j ä¸ºç»“å°¾çš„Bï¼Œæœ€é•¿é‡å¤å­æ•°ç»„é•¿åº¦ã€‚ä¸è¡Œä¹ˆï¼Ÿ
# è¡Œå€’æ˜¯è¡Œï¼ ä½†å®ç°èµ·æ¥å°±éº»çƒ¦ä¸€ç‚¹ï¼Œéœ€è¦å•ç‹¬å¤„ç†åˆå§‹åŒ–éƒ¨åˆ†ï¼Œåœ¨æœ¬é¢˜è§£ä¸‹é¢çš„æ‹“å±•å†…å®¹é‡Œï¼Œæˆ‘ç»™å‡ºäº† ç¬¬äºŒç§ 
# dpæ•°ç»„çš„å®šä¹‰æ–¹å¼æ‰€å¯¹åº”çš„ä»£ç å’Œè®²è§£ï¼Œå¤§å®¶æ¯”è¾ƒä¸€ä¸‹å°±äº†è§£äº†ã€‚
# æ ¹æ®dp[i][j]çš„å®šä¹‰ï¼Œdp[i][j]çš„çŠ¶æ€åªèƒ½ç”±dp[i - 1][j - 1]æ¨å¯¼å‡ºæ¥ã€‚
# å³å½“A[i - 1] å’ŒB[j - 1]ç›¸ç­‰çš„æ—¶å€™ï¼Œdp[i][j] = dp[i - 1][j - 1] + 1;
# æ³¨æ„é¢˜ç›®ä¸­è¯´çš„å­æ•°ç»„,å…¶å®å°±æ˜¯è¿ç»­å­åºåˆ—ã€‚
# 2ç»´DP
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        # åˆ›å»ºä¸€ä¸ªäºŒç»´æ•°ç»„ dp,ç”¨äºå­˜å‚¨æœ€é•¿å…¬å…±å­æ•°ç»„çš„é•¿åº¦
        # dp[i][j] ï¼šä»¥ä¸‹æ ‡i - 1ä¸ºç»“å°¾çš„Aï¼Œå’Œä»¥ä¸‹æ ‡j - 1ä¸ºç»“å°¾çš„Bï¼Œæœ€é•¿é‡å¤å­æ•°ç»„é•¿åº¦ä¸ºdp[i][j]
        dp = [[0] * (len(nums2) + 1) for _ in range(len(nums1) + 1)]
        # è®°å½•æœ€é•¿å…¬å…±å­æ•°ç»„çš„é•¿åº¦
        result = 0

        # éå†æ•°ç»„ nums1
        for i in range(1, len(nums1) + 1):
            # éå†æ•°ç»„ nums2
            for j in range(1, len(nums2) + 1):
                # å¦‚æœ nums1[i-1] å’Œ nums2[j-1] ç›¸ç­‰
                if nums1[i - 1] == nums2[j - 1]:
                    # åœ¨å½“å‰ä½ç½®ä¸Šçš„æœ€é•¿å…¬å…±å­æ•°ç»„é•¿åº¦ä¸ºå‰ä¸€ä¸ªä½ç½®ä¸Šçš„é•¿åº¦åŠ ä¸€
                    dp[i][j] = dp[i - 1][j - 1] + 1
                # æ›´æ–°æœ€é•¿å…¬å…±å­æ•°ç»„çš„é•¿åº¦
                if dp[i][j] > result:
                    result = dp[i][j]

        # è¿”å›æœ€é•¿å…¬å…±å­æ•°ç»„çš„é•¿åº¦
        return result
# 1ç»´DPï¼Œå†…å±‚éå†éœ€è¦ä»åå‘å‰
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        dp = [0] * (len(nums2) + 1)
        result = 0

        for i in range(1, len(nums1) + 1):
            # for j in range(1, len(nums2) + 1):
            for j in range(len(nums2), 0, -1):
                if nums1[i - 1] == nums2[j - 1]:
                    dp[j] = dp[j - 1] + 1
                else:
                    dp[j] = 0 #æ³¨æ„è¿™é‡Œä¸ç›¸ç­‰çš„æ—¶å€™è¦æœ‰èµ‹0çš„æ“ä½œ
                result = max(result, dp[j])

        # è¿”å›æœ€é•¿å…¬å…±å­æ•°ç»„çš„é•¿åº¦
        return result
# *** 1ç»´DP ç”¨prev, curræŒ‡é’ˆï¼Œå†…å±‚éå†å°±ä¸ç”¨ä»åå‘å‰äº†
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        # åˆ›å»ºä¸€ä¸ªä¸€ç»´æ•°ç»„ dp,ç”¨äºå­˜å‚¨æœ€é•¿å…¬å…±å­æ•°ç»„çš„é•¿åº¦
        dp = [0] * (len(nums2) + 1)
        # è®°å½•æœ€é•¿å…¬å…±å­æ•°ç»„çš„é•¿åº¦
        result = 0

        # éå†æ•°ç»„ nums1
        for i in range(1, len(nums1) + 1):
            # ç”¨äºä¿å­˜ä¸Šä¸€ä¸ªä½ç½®çš„å€¼
            prev = 0
            # éå†æ•°ç»„ nums2
            for j in range(1, len(nums2) + 1):
                # ä¿å­˜å½“å‰ä½ç½®çš„å€¼,å› ä¸ºä¼šåœ¨åé¢è¢«æ›´æ–°
                current = dp[j]
                # å¦‚æœ nums1[i-1] å’Œ nums2[j-1] ç›¸ç­‰
                if nums1[i - 1] == nums2[j - 1]:
                    # åœ¨å½“å‰ä½ç½®ä¸Šçš„æœ€é•¿å…¬å…±å­æ•°ç»„é•¿åº¦ä¸ºä¸Šä¸€ä¸ªä½ç½®çš„é•¿åº¦åŠ ä¸€
                    dp[j] = prev + 1
                    # æ›´æ–°æœ€é•¿å…¬å…±å­æ•°ç»„çš„é•¿åº¦
                    if dp[j] > result:
                        result = dp[j]
                else:
                    # å¦‚æœä¸ç›¸ç­‰,å°†å½“å‰ä½ç½®çš„å€¼ç½®ä¸ºé›¶
                    dp[j] = 0
                # æ›´æ–° prev å˜é‡ä¸ºå½“å‰ä½ç½®çš„å€¼,ä¾›ä¸‹ä¸€æ¬¡è¿­ä»£ä½¿ç”¨
                prev = current

        # è¿”å›æœ€é•¿å…¬å…±å­æ•°ç»„çš„é•¿åº¦
        return result
# 2ç»´DP æ‰©å±•
# class Solution:
#     def findLength(self, nums1: List[int], nums2: List[int]) -> int:
#         # åˆ›å»ºä¸€ä¸ªäºŒç»´æ•°ç»„ dp,ç”¨äºå­˜å‚¨æœ€é•¿å…¬å…±å­æ•°ç»„çš„é•¿åº¦
#         dp = [[0] * (len(nums2) + 1) for _ in range(len(nums1) + 1)]
#         # è®°å½•æœ€é•¿å…¬å…±å­æ•°ç»„çš„é•¿åº¦
#         result = 0

#         # å¯¹ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—è¿›è¡Œåˆå§‹åŒ–
#         for i in range(len(nums1)):
#             if nums1[i] == nums2[0]:
#                 dp[i + 1][1] = 1
#         for j in range(len(nums2)):
#             if nums1[0] == nums2[j]:
#                 dp[1][j + 1] = 1

#         # å¡«å……dpæ•°ç»„
#         for i in range(1, len(nums1) + 1):
#             for j in range(1, len(nums2) + 1):
#                 if nums1[i - 1] == nums2[j - 1]:
#                     # å¦‚æœ nums1[i-1] å’Œ nums2[j-1] ç›¸ç­‰,åˆ™å½“å‰ä½ç½®çš„æœ€é•¿å…¬å…±å­æ•°ç»„é•¿åº¦ä¸ºå·¦ä¸Šè§’ä½ç½®çš„å€¼åŠ ä¸€
#                     dp[i][j] = dp[i - 1][j - 1] + 1
#                 if dp[i][j] > result:
#                     # æ›´æ–°æœ€é•¿å…¬å…±å­æ•°ç»„çš„é•¿åº¦
#                     result = dp[i][j]

#         # è¿”å›æœ€é•¿å…¬å…±å­æ•°ç»„çš„é•¿åº¦
#         return result


#X33 (Medium) 1143.æœ€é•¿å…¬å…±å­åºåˆ— (ä¸è¿ç»­)
# ä¸¤ä¸ªå­—ç¬¦ä¸²
    # ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² text1 å’Œ text2ï¼Œè¿”å›è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦ã€‚
    # ä¸€ä¸ªå­—ç¬¦ä¸²çš„ å­åºåˆ— æ˜¯æŒ‡è¿™æ ·ä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ï¼šå®ƒæ˜¯ç”±åŸå­—ç¬¦ä¸²åœ¨ä¸æ”¹å˜å­—ç¬¦çš„ç›¸å¯¹é¡ºåºçš„æƒ…å†µä¸‹åˆ é™¤æŸäº›å­—ç¬¦ï¼ˆä¹Ÿå¯ä»¥ä¸åˆ é™¤ä»»ä½•å­—ç¬¦ï¼‰
    # åç»„æˆçš„æ–°å­—ç¬¦ä¸²ã€‚
    # ä¾‹å¦‚ï¼Œ"ace" æ˜¯ "abcde" çš„å­åºåˆ—ï¼Œä½† "aec" ä¸æ˜¯ "abcde" çš„å­åºåˆ—ã€‚ä¸¤ä¸ªå­—ç¬¦ä¸²çš„ã€Œå…¬å…±å­åºåˆ—ã€
    # æ˜¯è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²æ‰€å…±åŒæ‹¥æœ‰çš„å­åºåˆ—ã€‚
    # è‹¥è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²æ²¡æœ‰å…¬å…±å­åºåˆ—ï¼Œåˆ™è¿”å› 0ã€‚
    # ç¤ºä¾‹ 1:
    # è¾“å…¥ï¼štext1 = "abcde", text2 = "ace"
    # è¾“å‡ºï¼š3
    # è§£é‡Šï¼šæœ€é•¿å…¬å…±å­åºåˆ—æ˜¯ "ace"ï¼Œå®ƒçš„é•¿åº¦ä¸º 3ã€‚
    # ç¤ºä¾‹ 2:
    # è¾“å…¥ï¼štext1 = "abc", text2 = "abc"
    # è¾“å‡ºï¼š3
    # è§£é‡Šï¼šæœ€é•¿å…¬å…±å­åºåˆ—æ˜¯ "abc"ï¼Œå®ƒçš„é•¿åº¦ä¸º 3ã€‚
    # ç¤ºä¾‹ 3:
    # è¾“å…¥ï¼štext1 = "abc", text2 = "def"
    # è¾“å‡ºï¼š0
    # è§£é‡Šï¼šä¸¤ä¸ªå­—ç¬¦ä¸²æ²¡æœ‰å…¬å…±å­åºåˆ—ï¼Œè¿”å› 0ã€‚
# æœ¬é¢˜å’ŒåŠ¨æ€è§„åˆ’:718. æœ€é•¿é‡å¤å­æ•°ç»„ åŒºåˆ«åœ¨äºè¿™é‡Œä¸è¦æ±‚æ˜¯è¿ç»­çš„äº†,
# ä½†è¦æœ‰ç›¸å¯¹é¡ºåº,å³:"ace" æ˜¯ "abcde" çš„å­åºåˆ—,ä½† "aec" ä¸æ˜¯ "abcde" çš„å­åºåˆ—ã€‚
# dp[i][j]ï¼šé•¿åº¦ä¸º[0, i - 1]çš„å­—ç¬¦ä¸²text1ä¸é•¿åº¦ä¸º[0, j - 1]çš„å­—ç¬¦ä¸²text2çš„æœ€é•¿å…¬å…±å­åºåˆ—ä¸ºdp[i][j]
# æœ‰åŒå­¦ä¼šé—®ï¼šä¸ºä»€ä¹ˆè¦å®šä¹‰é•¿åº¦ä¸º[0, i - 1]çš„å­—ç¬¦ä¸²text1ï¼Œå®šä¹‰ä¸ºé•¿åº¦ä¸º[0, i]çš„å­—ç¬¦ä¸²text1ä¸é¦™ä¹ˆï¼Ÿ
# è¿™æ ·å®šä¹‰æ˜¯ä¸ºäº†åé¢ä»£ç å®ç°æ–¹ä¾¿ï¼Œå¦‚æœéè¦å®šä¹‰ä¸ºé•¿åº¦ä¸º[0, i]çš„å­—ç¬¦ä¸²text1ä¹Ÿå¯ä»¥ï¼Œ
# æˆ‘åœ¨ åŠ¨æ€è§„åˆ’ï¼š718. æœ€é•¿é‡å¤å­æ•°ç»„ä¸­çš„ã€Œæ‹“å±•ã€é‡Œ è¯¦ç»†è®²è§£äº†åŒºåˆ«æ‰€åœ¨ï¼Œå…¶å®å°±æ˜¯ç®€åŒ–äº†dpæ•°ç»„ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—çš„åˆå§‹åŒ–é€»è¾‘ã€‚

# ä¸»è¦å°±æ˜¯ä¸¤å¤§æƒ…å†µï¼š text1[i - 1] ä¸ text2[j - 1]ç›¸åŒï¼Œtext1[i - 1] ä¸ text2[j - 1]ä¸ç›¸åŒ
# å¦‚æœtext1[i - 1] ä¸ text2[j - 1]ç›¸åŒï¼Œé‚£ä¹ˆæ‰¾åˆ°äº†ä¸€ä¸ªå…¬å…±å…ƒç´ ï¼Œæ‰€ä»¥dp[i][j] = dp[i - 1][j - 1] + 1;
# å¦‚æœtext1[i - 1] ä¸ text2[j - 1]ä¸ç›¸åŒï¼Œé‚£å°±çœ‹çœ‹text1[0, i - 2]ä¸text2[0, j - 1]çš„æœ€é•¿å…¬å…±å­åºåˆ— å’Œ text1[0, i - 1]ä¸text2[0, j - 2]çš„æœ€é•¿å…¬å…±å­åºåˆ—ï¼Œå–æœ€å¤§çš„ã€‚
# å³ï¼šdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
# 2ç»´DP
# class Solution:
#     def longestCommonSubsequence(self, text1: str, text2: str) -> int:
#         # åˆ›å»ºä¸€ä¸ªäºŒç»´æ•°ç»„ dp,ç”¨äºå­˜å‚¨æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦
#         dp = [[0] * (len(text2) + 1) for _ in range(len(text1) + 1)]
        
#         # éå† text1 å’Œ text2,å¡«å…… dp æ•°ç»„
#         for i in range(1, len(text1) + 1):
#             for j in range(1, len(text2) + 1):
#                 if text1[i - 1] == text2[j - 1]:
#                     # å¦‚æœ text1[i-1] å’Œ text2[j-1] ç›¸ç­‰,åˆ™å½“å‰ä½ç½®çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦ä¸ºå·¦ä¸Šè§’ä½ç½®çš„å€¼åŠ ä¸€
#                     dp[i][j] = dp[i - 1][j - 1] + 1
#                 else:
#                     # å¦‚æœ text1[i-1] å’Œ text2[j-1] ä¸ç›¸ç­‰,åˆ™å½“å‰ä½ç½®çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦ä¸ºä¸Šæ–¹æˆ–å·¦æ–¹çš„è¾ƒå¤§å€¼
#                     dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
#         # è¿”å›æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦
#         return dp[len(text1)][len(text2)]
# 1ç»´DP
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        # dp[i][j]ï¼šé•¿åº¦ä¸º[0, i - 1]çš„å­—ç¬¦ä¸²text1ä¸é•¿åº¦ä¸º[0, j - 1]çš„å­—ç¬¦ä¸²text2çš„æœ€é•¿å…¬å…±å­åºåˆ—ä¸ºdp[i][j]
        dp = [0] * (n + 1)  # åˆå§‹åŒ–ä¸€ç»´DPæ•°ç»„
        
        for i in range(1, m + 1):
            prev = 0  # ä¿å­˜ä¸Šä¸€ä¸ªä½ç½®çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦
            for j in range(1, n + 1):
                curr = dp[j]  # ä¿å­˜å½“å‰ä½ç½®çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦
                if text1[i - 1] == text2[j - 1]:
                    # å¦‚æœå½“å‰å­—ç¬¦ç›¸ç­‰,åˆ™æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦åŠ ä¸€
                    dp[j] = prev + 1
                else:
                    # å¦‚æœå½“å‰å­—ç¬¦ä¸ç›¸ç­‰,åˆ™é€‰æ‹©ä¿ç•™å‰ä¸€ä¸ªä½ç½®çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦ä¸­çš„è¾ƒå¤§å€¼
                    # è¿™é‡Œdp[j]å¯¹åº”dp[i - 1][j], dp[j-1]å¯¹åº”dp[i][j - 1]
                    dp[j] = max(dp[j], dp[j - 1]) 
                prev = curr  # æ›´æ–°ä¸Šä¸€ä¸ªä½ç½®çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦
        
        return dp[n]  # è¿”å›æœ€åä¸€ä¸ªä½ç½®çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦ä½œä¸ºç»“æœ

# Longest Common Subsequence
    # Given two strings, find the length of their longest common subsequence (LCS). 
    # A subsequence is a sequence of characters that can be derived from a string by 
    # deleting zero or more elements, without changing the order of the remaining elements.
    # Example:
    # Input: s1 = 'acabac', s2 = 'aebab'
    # Output: 3
def longest_common_subsequence(s1: str, s2: str) -> int:
    # Base case: Set the last row and last column to 0 by
    # initializing the entire DP table with 0s.
    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]
    # Populate the DP table.
    for i in range(len(s1) - 1, -1, -1):
        for j in range(len(s2) - 1, -1, -1):
            # If the characters match, the length of the LCS at
            # 'dp[i][j]' is  1 + the LCS length of the remaining
            # substrings.
            if s1[i] == s2[j]:
                dp[i][j] = 1 + dp[i + 1][j + 1]
            # If the characters don't match, the LCS length at
            # 'dp[i][j]' can be found by either:
            # 1. Excluding the current character of s1.
            # 2. Excluding the current character of s2.
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])
    return dp[0][0]

def longest_common_subsequence_optimized(s1: str, s2: str) -> int:
    # Initialize 'prev_row' as the DP values of the last row.
    prev_row = [0] * (len(s2) + 1)
    for i in range(len(s1) - 1, -1, -1):
        # Set the last cell of 'curr_row' to 0 to set the base case for 
        # this row. This is done by initializing the entire row to 0.
        curr_row = [0] * (len(s2) + 1)
        for j in range(len(s2) - 1, -1, -1):
            # If the characters match, the length of the LCS at
            # 'curr_row[j]' is 1 + the LCS length of the remaining
            # substrings ('prev_row[j + 1]').
            if s1[i] == s2[j]:
                curr_row[j] = 1 + prev_row[j + 1]
            # If the characters don't match, the LCS length at
            # 'curr_row[j]' can be found by either:
            # 1. Excluding the current character of s1 ('prev_row[j]').
            # 2. Excluding the current character of s2 
            # ('curr_row[j + 1]').
            else:
                curr_row[j] = max(prev_row[j], curr_row[j + 1])
        # Update 'prev_row' with 'curr_row' values for the next 
        # iteration.
        prev_row = curr_row
    return prev_row[0]


#34 (Medium) 1035.ä¸ç›¸äº¤çš„çº¿ (ä¸è¿ç»­)
    # æˆ‘ä»¬åœ¨ä¸¤æ¡ç‹¬ç«‹çš„æ°´å¹³çº¿ä¸ŠæŒ‰ç»™å®šçš„é¡ºåºå†™ä¸‹ A å’Œ B ä¸­çš„æ•´æ•°ã€‚
    # ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ç»˜åˆ¶ä¸€äº›è¿æ¥ä¸¤ä¸ªæ•°å­— A[i] å’Œ B[j] çš„ç›´çº¿ï¼Œåªè¦ A[i] == B[j]ï¼Œä¸”æˆ‘ä»¬ç»˜åˆ¶çš„ç›´çº¿ä¸ä¸ä»»ä½•å…¶ä»–è¿çº¿ï¼ˆéæ°´å¹³çº¿ï¼‰ç›¸äº¤ã€‚
    # ä»¥è¿™ç§æ–¹æ³•ç»˜åˆ¶çº¿æ¡ï¼Œå¹¶è¿”å›æˆ‘ä»¬å¯ä»¥ç»˜åˆ¶çš„æœ€å¤§è¿çº¿æ•°ã€‚
# æœ¬é¢˜è¯´æ˜¯æ±‚ç»˜åˆ¶çš„æœ€å¤§è¿çº¿æ•°ï¼Œå…¶å®å°±æ˜¯æ±‚ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦ï¼
class Solution:
    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:
        dp = [[0] * (len(B)+1) for _ in range(len(A)+1)]
        for i in range(1, len(A)+1):
            for j in range(1, len(B)+1):
                if A[i-1] == B[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        return dp[-1][-1]


#35 (Medium) 53.æœ€å¤§å­åºå’Œ (è¿ç»­)
    # ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾åˆ°ä¸€ä¸ªå…·æœ‰æœ€å¤§å’Œçš„è¿ç»­å­æ•°ç»„ï¼ˆå­æ•°ç»„æœ€å°‘åŒ…å«ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œè¿”å›å…¶æœ€å¤§å’Œã€‚
    # ç¤ºä¾‹:
    # è¾“å…¥: [-2,1,-3,4,-1,2,1,-5,4]
    # è¾“å‡º: 6
    # è§£é‡Š: è¿ç»­å­æ•°ç»„ [4,-1,2,1] çš„å’Œæœ€å¤§ï¼Œä¸º 6ã€‚
# dp[i]ï¼šåŒ…æ‹¬ä¸‹æ ‡iï¼ˆä»¥nums[i]ä¸ºç»“å°¾ï¼‰çš„æœ€å¤§è¿ç»­å­åºåˆ—å’Œä¸ºdp[i]ã€‚
# dp[i]åªæœ‰ä¸¤ä¸ªæ–¹å‘å¯ä»¥æ¨å‡ºæ¥ï¼š
# dp[i - 1] + nums[i]ï¼Œå³ï¼šnums[i]åŠ å…¥å½“å‰è¿ç»­å­åºåˆ—å’Œ
# nums[i]ï¼Œå³ï¼šä»å¤´å¼€å§‹è®¡ç®—å½“å‰è¿ç»­å­åºåˆ—å’Œ
# ä¸€å®šæ˜¯å–æœ€å¤§çš„ï¼Œæ‰€ä»¥dp[i] = max(dp[i - 1] + nums[i], nums[i]);
# ä»é€’æ¨å…¬å¼å¯ä»¥çœ‹å‡ºæ¥dp[i]æ˜¯ä¾èµ–äºdp[i - 1]çš„çŠ¶æ€ï¼Œdp[0]å°±æ˜¯é€’æ¨å…¬å¼çš„åŸºç¡€ã€‚
# dp[0]åº”è¯¥æ˜¯å¤šå°‘å‘¢?
# æ ¹æ®dp[i]çš„å®šä¹‰ï¼Œå¾ˆæ˜æ˜¾dp[0]åº”ä¸ºnums[0]å³dp[0] = nums[0]ã€‚
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # dp[i]ï¼šåŒ…æ‹¬ä¸‹æ ‡iï¼ˆä»¥nums[i]ä¸ºç»“å°¾ï¼‰ï¼Œæ‰€ä»¥é•¿åº¦ä¸ºlen(nums)
        dp = [0] * len(nums)
        dp[0] = nums[0]
        result = dp[0]
        for i in range(1, len(nums)):
            dp[i] = max(dp[i-1] + nums[i], nums[i]) #çŠ¶æ€è½¬ç§»å…¬å¼
            result = max(result, dp[i]) #result ä¿å­˜dp[i]çš„æœ€å¤§å€¼
        return result


#36 (Easy) 392.åˆ¤æ–­å­åºåˆ—
    # ç»™å®šå­—ç¬¦ä¸² s å’Œ t ï¼Œåˆ¤æ–­ s æ˜¯å¦ä¸º t çš„å­åºåˆ—ã€‚
    # å­—ç¬¦ä¸²çš„ä¸€ä¸ªå­åºåˆ—æ˜¯åŸå§‹å­—ç¬¦ä¸²åˆ é™¤ä¸€äº›ï¼ˆä¹Ÿå¯ä»¥ä¸åˆ é™¤ï¼‰å­—ç¬¦è€Œä¸æ”¹å˜å‰©ä½™å­—ç¬¦ç›¸å¯¹ä½ç½®å½¢æˆçš„æ–°å­—ç¬¦ä¸²ã€‚ï¼ˆä¾‹å¦‚ï¼Œ"ace"æ˜¯"abcde"çš„ä¸€ä¸ªå­åºåˆ—ï¼Œè€Œ"aec"ä¸æ˜¯ï¼‰ã€‚
    # ç¤ºä¾‹ 1ï¼š
    # è¾“å…¥ï¼šs = "abc", t = "ahbgdc"
    # è¾“å‡ºï¼štrue
    # ç¤ºä¾‹ 2ï¼š
    # è¾“å…¥ï¼šs = "axc", t = "ahbgdc"
    # è¾“å‡ºï¼šfalse
# dp[i][j] è¡¨ç¤ºä»¥ä¸‹æ ‡i-1ä¸ºç»“å°¾çš„å­—ç¬¦ä¸²sï¼Œå’Œä»¥ä¸‹æ ‡j-1ä¸ºç»“å°¾çš„å­—ç¬¦ä¸²tï¼Œç›¸åŒå­åºåˆ—çš„é•¿åº¦ä¸ºdp[i][j]ã€‚
# if (s[i - 1] == t[j - 1])ï¼Œé‚£ä¹ˆdp[i][j] = dp[i - 1][j - 1] + 1;ï¼Œå› ä¸ºæ‰¾åˆ°äº†ä¸€ä¸ªç›¸åŒçš„å­—ç¬¦ï¼Œç›¸åŒå­åºåˆ—é•¿åº¦è‡ªç„¶è¦åœ¨dp[i-1][j-1]çš„åŸºç¡€ä¸ŠåŠ 1ï¼ˆå¦‚æœä¸ç†è§£ï¼Œåœ¨å›çœ‹ä¸€ä¸‹dp[i][j]çš„å®šä¹‰ï¼‰
# if (s[i - 1] != t[j - 1])ï¼Œæ­¤æ—¶ç›¸å½“äºtè¦åˆ é™¤å…ƒç´ ï¼Œtå¦‚æœæŠŠå½“å‰å…ƒç´ t[j - 1]åˆ é™¤ï¼Œé‚£ä¹ˆdp[i][j] çš„æ•°å€¼å°±æ˜¯ çœ‹s[i - 1]ä¸ t[j - 2]çš„æ¯”è¾ƒç»“æœäº†ï¼Œå³ï¼šdp[i][j] = dp[i][j - 1];
# å…¶å®è¿™é‡Œ å¤§å®¶å¯ä»¥å‘ç°å’Œ 1143.æœ€é•¿å…¬å…±å­åºåˆ— (opens new window)çš„é€’æ¨å…¬å¼åŸºæœ¬é‚£å°±æ˜¯ä¸€æ ·çš„ï¼ŒåŒºåˆ«å°±æ˜¯ æœ¬é¢˜ å¦‚æœåˆ å…ƒç´ ä¸€å®šæ˜¯å­—ç¬¦ä¸²tï¼Œè€Œ 1143.æœ€é•¿å…¬å…±å­åºåˆ— æ˜¯ä¸¤ä¸ªå­—ç¬¦ä¸²éƒ½å¯ä»¥åˆ å…ƒç´ ã€‚
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        # dp[i][j]å¯¹åº”çš„æ˜¯i-1å’Œj-1ï¼Œæ‰€ä»¥è¦åˆ°i+1ï¼Œj+1
        dp = [[0] * (len(t)+1) for _ in range(len(s)+1)]
        for i in range(1, len(s)+1):
            for j in range(1, len(t)+1):
                if s[i-1] == t[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = dp[i][j-1]
        if dp[-1][-1] == len(s):
            return True
        return False


#37 *** (Hard) 115.ä¸åŒçš„å­åºåˆ—
    # ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² s å’Œä¸€ä¸ªå­—ç¬¦ä¸² t ï¼Œè®¡ç®—åœ¨ s çš„å­åºåˆ—ä¸­ t å‡ºç°çš„ä¸ªæ•°ã€‚
    # å­—ç¬¦ä¸²çš„ä¸€ä¸ª å­åºåˆ— æ˜¯æŒ‡ï¼Œé€šè¿‡åˆ é™¤ä¸€äº›ï¼ˆä¹Ÿå¯ä»¥ä¸åˆ é™¤ï¼‰å­—ç¬¦ä¸”ä¸å¹²æ‰°å‰©ä½™å­—ç¬¦ç›¸å¯¹ä½ç½®æ‰€ç»„æˆçš„æ–°å­—ç¬¦ä¸²ã€‚ï¼ˆä¾‹å¦‚ï¼Œ"ACE" æ˜¯ "ABCDE" çš„ä¸€ä¸ªå­åºåˆ—ï¼Œè€Œ "AEC" ä¸æ˜¯ï¼‰
    # é¢˜ç›®æ•°æ®ä¿è¯ç­”æ¡ˆç¬¦åˆ 32 ä½å¸¦ç¬¦å·æ•´æ•°èŒƒå›´ã€‚
# è¿™é“é¢˜ç›®å¦‚æœä¸æ˜¯å­åºåˆ—,è€Œæ˜¯è¦æ±‚è¿ç»­åºåˆ—çš„,é‚£å°±å¯ä»¥è€ƒè™‘ç”¨KMPã€‚
# dp[i][j]ï¼šä»¥i-1ä¸ºç»“å°¾çš„så­åºåˆ—ä¸­å‡ºç°ä»¥j-1ä¸ºç»“å°¾çš„tçš„ä¸ªæ•°ä¸ºdp[i][j]ã€‚
# è¿™ä¸€ç±»é—®é¢˜ï¼ŒåŸºæœ¬æ˜¯è¦åˆ†æä¸¤ç§æƒ…å†µ
# s[i - 1] ä¸ t[j - 1]ç›¸ç­‰
# s[i - 1] ä¸ t[j - 1] ä¸ç›¸ç­‰
# å½“s[i - 1] ä¸ t[j - 1]ç›¸ç­‰æ—¶ï¼Œdp[i][j]å¯ä»¥æœ‰ä¸¤éƒ¨åˆ†ç»„æˆã€‚
# ä¸€éƒ¨åˆ†æ˜¯ç”¨s[i - 1]æ¥åŒ¹é…ï¼Œé‚£ä¹ˆä¸ªæ•°ä¸ºdp[i - 1][j - 1]ã€‚å³ä¸éœ€è¦è€ƒè™‘å½“å‰så­ä¸²å’Œtå­ä¸²çš„æœ€åä¸€ä½å­—æ¯ï¼Œæ‰€ä»¥åªéœ€è¦ dp[i-1][j-1]ã€‚
# ä¸€éƒ¨åˆ†æ˜¯ä¸ç”¨s[i - 1]æ¥åŒ¹é…ï¼Œä¸ªæ•°ä¸ºdp[i - 1][j]ã€‚
# è¿™é‡Œå¯èƒ½æœ‰å½•å‹ä¸æ˜ç™½äº†ï¼Œä¸ºä»€ä¹ˆè¿˜è¦è€ƒè™‘ ä¸ç”¨s[i - 1]æ¥åŒ¹é…ï¼Œéƒ½ç›¸åŒäº†æŒ‡å®šè¦åŒ¹é…å•Šã€‚
# ä¾‹å¦‚ï¼š sï¼šbagg å’Œ tï¼šbag ï¼Œs[3] å’Œ t[2]æ˜¯ç›¸åŒçš„ï¼Œä½†æ˜¯å­—ç¬¦ä¸²sä¹Ÿå¯ä»¥ä¸ç”¨s[3]æ¥åŒ¹é…ï¼Œå³ç”¨s[0]s[1]s[2]ç»„æˆçš„bagã€‚
# å½“ç„¶ä¹Ÿå¯ä»¥ç”¨s[3]æ¥åŒ¹é…ï¼Œå³ï¼šs[0]s[1]s[3]ç»„æˆçš„bagã€‚
# æ‰€ä»¥å½“s[i - 1] ä¸ t[j - 1]ç›¸ç­‰æ—¶ï¼Œdp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
# å½“s[i - 1] ä¸ t[j - 1]ä¸ç›¸ç­‰æ—¶ï¼Œdp[i][j]åªæœ‰ä¸€éƒ¨åˆ†ç»„æˆï¼Œä¸ç”¨s[i - 1]æ¥åŒ¹é…ï¼ˆå°±æ˜¯æ¨¡æ‹Ÿåœ¨sä¸­åˆ é™¤è¿™ä¸ªå…ƒç´ ï¼‰ï¼Œå³ï¼šdp[i - 1][j]
# æ‰€ä»¥é€’æ¨å…¬å¼ä¸ºï¼šdp[i][j] = dp[i - 1][j];
# è¿™é‡Œå¯èƒ½æœ‰å½•å‹è¿˜ç–‘æƒ‘ï¼Œä¸ºä»€ä¹ˆåªè€ƒè™‘ â€œä¸ç”¨s[i - 1]æ¥åŒ¹é…â€ è¿™ç§æƒ…å†µï¼Œ ä¸è€ƒè™‘ â€œä¸ç”¨t[j - 1]æ¥åŒ¹é…â€ çš„æƒ…å†µå‘¢ã€‚
# è¿™é‡Œå¤§å®¶è¦æ˜ç¡®ï¼Œæˆ‘ä»¬æ±‚çš„æ˜¯ s ä¸­æœ‰å¤šå°‘ä¸ª tï¼Œè€Œä¸æ˜¯ æ±‚tä¸­æœ‰å¤šå°‘ä¸ªsï¼Œæ‰€ä»¥åªè€ƒè™‘ sä¸­åˆ é™¤å…ƒç´ çš„æƒ…å†µï¼Œå³ ä¸ç”¨s[i - 1]æ¥åŒ¹é… çš„æƒ…å†µã€‚
    
# æ¯æ¬¡å½“åˆå§‹åŒ–çš„æ—¶å€™ï¼Œéƒ½è¦å›é¡¾ä¸€ä¸‹dp[i][j]çš„å®šä¹‰ï¼Œä¸è¦å‡­æ„Ÿè§‰åˆå§‹åŒ–ã€‚
# dp[i][0]è¡¨ç¤ºä»€ä¹ˆå‘¢ï¼Ÿ
# dp[i][0] è¡¨ç¤ºï¼šä»¥i-1ä¸ºç»“å°¾çš„så¯ä»¥éšä¾¿åˆ é™¤å…ƒç´ ï¼Œå‡ºç°ç©ºå­—ç¬¦ä¸²çš„ä¸ªæ•°ã€‚
# é‚£ä¹ˆdp[i][0]ä¸€å®šéƒ½æ˜¯1ï¼Œå› ä¸ºä¹Ÿå°±æ˜¯æŠŠä»¥i-1ä¸ºç»“å°¾çš„sï¼Œåˆ é™¤æ‰€æœ‰å…ƒç´ ï¼Œå‡ºç°ç©ºå­—ç¬¦ä¸²çš„ä¸ªæ•°å°±æ˜¯1ã€‚
# å†æ¥çœ‹dp[0][j]ï¼Œdp[0][j]ï¼šç©ºå­—ç¬¦ä¸²så¯ä»¥éšä¾¿åˆ é™¤å…ƒç´ ï¼Œå‡ºç°ä»¥j-1ä¸ºç»“å°¾çš„å­—ç¬¦ä¸²tçš„ä¸ªæ•°ã€‚
# é‚£ä¹ˆdp[0][j]ä¸€å®šéƒ½æ˜¯0ï¼Œså¦‚è®ºå¦‚ä½•ä¹Ÿå˜æˆä¸äº†tã€‚
# æœ€åå°±è¦çœ‹ä¸€ä¸ªç‰¹æ®Šä½ç½®äº†ï¼Œå³ï¼šdp[0][0] åº”è¯¥æ˜¯å¤šå°‘ã€‚
# dp[0][0]åº”è¯¥æ˜¯1ï¼Œç©ºå­—ç¬¦ä¸²sï¼Œå¯ä»¥åˆ é™¤0ä¸ªå…ƒç´ ï¼Œå˜æˆç©ºå­—ç¬¦ä¸²tã€‚
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        # dp[i][j]å¯¹åº”çš„æ˜¯i-1å’Œj-1ï¼Œæ‰€ä»¥è¦åˆ°i+1ï¼Œj+1
        dp = [[0] * (len(t)+1) for _ in range(len(s)+1)]
        for i in range(len(s)):
            dp[i][0] = 1
        for j in range(1, len(t)):
            dp[0][j] = 0
        for i in range(1, len(s)+1):
            for j in range(1, len(t)+1):
                if s[i-1] == t[j-1]:
                    # å½“s[i - 1] ä¸ t[j - 1]ç›¸ç­‰æ—¶,dp[i][j]å¯ä»¥æœ‰ä¸¤éƒ¨åˆ†ç»„æˆã€‚
                    # ä¸€éƒ¨åˆ†æ˜¯ç”¨s[i - 1]æ¥åŒ¹é…,é‚£ä¹ˆä¸ªæ•°ä¸ºdp[i - 1][j - 1]ã€‚
                    # å³ä¸éœ€è¦è€ƒè™‘å½“å‰så­ä¸²å’Œtå­ä¸²çš„æœ€åä¸€ä½å­—æ¯,æ‰€ä»¥åªéœ€è¦ dp[i-1][j-1]ã€‚
                    # ä¸€éƒ¨åˆ†æ˜¯ä¸ç”¨s[i - 1]æ¥åŒ¹é…,ä¸ªæ•°ä¸ºdp[i - 1][j]ã€‚
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
                else:
                    # å½“s[i - 1] ä¸ t[j - 1]ä¸ç›¸ç­‰æ—¶,dp[i][j]åªæœ‰ä¸€éƒ¨åˆ†ç»„æˆ,
                    # ä¸ç”¨s[i - 1]æ¥åŒ¹é…(å°±æ˜¯æ¨¡æ‹Ÿåœ¨sä¸­åˆ é™¤è¿™ä¸ªå…ƒç´ ),å³:dp[i - 1][j]
                    dp[i][j] = dp[i-1][j]
        return dp[-1][-1]

class SolutionDP2:
    """
    æ—¢ç„¶dp[i]åªç”¨åˆ°dp[i - 1]çš„çŠ¶æ€,
    æˆ‘ä»¬å¯ä»¥é€šè¿‡ç¼“å­˜dp[i - 1]çš„çŠ¶æ€æ¥å¯¹dpè¿›è¡Œå‹ç¼©,
    å‡å°‘ç©ºé—´å¤æ‚åº¦ã€‚
    (åŸç†ç­‰åŒåŒäºæ»šåŠ¨æ•°ç»„)
    """
    
    def numDistinct(self, s: str, t: str) -> int:
        n1, n2 = len(s), len(t)
        if n1 < n2:
            return 0

        dp = [0 for _ in range(n2 + 1)]
        dp[0] = 1

        for i in range(1, n1 + 1):
            # å¿…é¡»æ·±æ‹·è´
            # ä¸ç„¶prev[i]å’Œdp[i]æ˜¯åŒä¸€ä¸ªåœ°å€çš„å¼•ç”¨
            prev = dp.copy()
            # å‰ªæ,ä¿è¯sçš„é•¿åº¦å¤§äºç­‰äºt
            # å› ä¸ºå¯¹äºä»»æ„i,i > n1, dp[i] = 0
            # æ²¡å¿…è¦è·Ÿæ–°çŠ¶æ€ã€‚ 
            end = i if i < n2 else n2
            for j in range(1, end + 1):
                if s[i - 1] == t[j - 1]:
                    dp[j] = prev[j - 1] + prev[j]
                else:
                    dp[j] = prev[j]
        return dp[-1]


#38 (Medium) 583.ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ é™¤æ“ä½œ
    # ç»™å®šä¸¤ä¸ªå•è¯ word1 å’Œ word2ï¼Œæ‰¾åˆ°ä½¿å¾— word1 å’Œ word2 ç›¸åŒæ‰€éœ€çš„æœ€å°æ­¥æ•°ï¼Œæ¯æ­¥å¯ä»¥åˆ é™¤ä»»æ„ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­çš„ä¸€ä¸ªå­—ç¬¦ã€‚
    # ç¤ºä¾‹ï¼š
    # è¾“å…¥: "sea", "eat"
    # è¾“å‡º: 2
    # è§£é‡Š: ç¬¬ä¸€æ­¥å°†"sea"å˜ä¸º"ea"ï¼Œç¬¬äºŒæ­¥å°†"eat"å˜ä¸º"ea"
# dp[i][j]ï¼šä»¥i-1ä¸ºç»“å°¾çš„å­—ç¬¦ä¸²word1ï¼Œå’Œä»¥j-1ä½ç»“å°¾çš„å­—ç¬¦ä¸²word2ï¼Œæƒ³è¦è¾¾åˆ°ç›¸ç­‰ï¼Œæ‰€éœ€è¦åˆ é™¤å…ƒç´ çš„æœ€å°‘æ¬¡æ•°ã€‚
# å½“word1[i - 1] ä¸ word2[j - 1]ç›¸åŒçš„æ—¶å€™
# å½“word1[i - 1] ä¸ word2[j - 1]ä¸ç›¸åŒçš„æ—¶å€™
# å½“word1[i - 1] ä¸ word2[j - 1]ç›¸åŒçš„æ—¶å€™ï¼Œdp[i][j] = dp[i - 1][j - 1];
# å½“word1[i - 1] ä¸ word2[j - 1]ä¸ç›¸åŒçš„æ—¶å€™ï¼Œæœ‰ä¸‰ç§æƒ…å†µï¼š
# æƒ…å†µä¸€ï¼šåˆ word1[i - 1]ï¼Œæœ€å°‘æ“ä½œæ¬¡æ•°ä¸ºdp[i - 1][j] + 1
# æƒ…å†µäºŒï¼šåˆ word2[j - 1]ï¼Œæœ€å°‘æ“ä½œæ¬¡æ•°ä¸ºdp[i][j - 1] + 1
# æƒ…å†µä¸‰ï¼šåŒæ—¶åˆ word1[i - 1]å’Œword2[j - 1]ï¼Œæ“ä½œçš„æœ€å°‘æ¬¡æ•°ä¸ºdp[i - 1][j - 1] + 2
# é‚£æœ€åå½“ç„¶æ˜¯å–æœ€å°å€¼ï¼Œæ‰€ä»¥å½“word1[i - 1] ä¸ word2[j - 1]ä¸ç›¸åŒçš„æ—¶å€™ï¼Œé€’æ¨å…¬å¼ï¼šdp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});
# å› ä¸º dp[i][j - 1] + 1 = dp[i - 1][j - 1] + 2ï¼Œæ‰€ä»¥é€’æ¨å…¬å¼å¯ç®€åŒ–ä¸ºï¼šdp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);

# ä»é€’æ¨å…¬å¼ä¸­ï¼Œå¯ä»¥çœ‹å‡ºæ¥ï¼Œdp[i][0] å’Œ dp[0][j]æ˜¯ä¸€å®šè¦åˆå§‹åŒ–çš„ã€‚
# dp[i][0]ï¼šword2ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œä»¥i-1ä¸ºç»“å°¾çš„å­—ç¬¦ä¸²word1è¦åˆ é™¤å¤šå°‘ä¸ªå…ƒç´ ï¼Œæ‰èƒ½å’Œword2ç›¸åŒå‘¢ï¼Œå¾ˆæ˜æ˜¾dp[i][0] = iã€‚
# dp[0][j]çš„è¯åŒç†

# ??? è¿™é‡Œå¯èƒ½ä¸å°‘å½•å‹æœ‰ç‚¹è¿·ç³Šï¼Œä»å­—é¢ä¸Šç†è§£ å°±æ˜¯ å½“ åŒæ—¶åˆ word1[i - 1]å’Œword2[j - 1]ï¼Œdp[i][j-1] æœ¬æ¥å°±ä¸è€ƒè™‘ word2[j - 1]äº†ï¼Œé‚£ä¹ˆæˆ‘åœ¨åˆ  word1[i - 1]ï¼Œæ˜¯ä¸æ˜¯å°±è¾¾åˆ°ä¸¤ä¸ªå…ƒç´ éƒ½åˆ é™¤çš„æ•ˆæœï¼Œå³ dp[i][j-1] + 1ã€‚
# åŠ¨æ€è§„åˆ’ä¸€
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        # dp[i][j]å¯¹åº”çš„æ˜¯i-1å’Œj-1ï¼Œæ‰€ä»¥è¦åˆ°i+1ï¼Œj+1
        dp = [[0] * (len(word2)+1) for _ in range(len(word1)+1)]
        for i in range(len(word1)+1):
            dp[i][0] = i
        for j in range(len(word2)+1):
            dp[0][j] = j
        for i in range(1, len(word1)+1):
            for j in range(1, len(word2)+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    # å› ä¸º dp[i][j - 1] + 1 = dp[i - 1][j - 1] + 2,
                    # æ‰€ä»¥é€’æ¨å…¬å¼å¯ç®€åŒ–ä¸º:dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);
                    # è¿™é‡Œå¯èƒ½ä¸å°‘å½•å‹æœ‰ç‚¹è¿·ç³Š,ä»å­—é¢ä¸Šç†è§£ å°±æ˜¯ å½“ åŒæ—¶åˆ word1[i - 1]å’Œword2[j - 1],
                    # dp[i][j-1] æœ¬æ¥å°±ä¸è€ƒè™‘ word2[j - 1]äº†,é‚£ä¹ˆæˆ‘åœ¨åˆ  word1[i - 1],
                    # æ˜¯ä¸æ˜¯å°±è¾¾åˆ°ä¸¤ä¸ªå…ƒç´ éƒ½åˆ é™¤çš„æ•ˆæœ,å³ dp[i][j-1] + 1ã€‚
                    dp[i][j] = min(dp[i-1][j-1] + 2, dp[i-1][j] + 1, dp[i][j-1] + 1)
                    # dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1)
        return dp[-1][-1]
# åŠ¨æ€è§„åˆ’äºŒ
    # æœ¬é¢˜å’ŒåŠ¨æ€è§„åˆ’:1143.æœ€é•¿å…¬å…±å­åºåˆ— åŸºæœ¬ç›¸åŒ,
    # åªè¦æ±‚å‡ºä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦å³å¯,é‚£ä¹ˆé™¤äº†æœ€é•¿å…¬å…±å­åºåˆ—ä¹‹å¤–çš„å­—ç¬¦éƒ½æ˜¯å¿…é¡»åˆ é™¤çš„,
    # æœ€åç”¨ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æ€»é•¿åº¦å‡å»ä¸¤ä¸ªæœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦å°±æ˜¯åˆ é™¤çš„æœ€å°‘æ­¥æ•°ã€‚
class Solution:
    def minDistance(self, text1: str, text2: str) -> int:
        # åˆ›å»ºä¸€ä¸ªäºŒç»´æ•°ç»„ dp,ç”¨äºå­˜å‚¨æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦
        # dp[i][j]å¯¹åº”çš„æ˜¯i-1å’Œj-1ï¼Œæ‰€ä»¥è¦åˆ°i+1ï¼Œj+1
        dp = [[0] * (len(text2) + 1) for _ in range(len(text1) + 1)]
        
        # éå† text1 å’Œ text2,å¡«å…… dp æ•°ç»„
        for i in range(1, len(text1) + 1):
            for j in range(1, len(text2) + 1):
                if text1[i - 1] == text2[j - 1]:
                    # å¦‚æœ text1[i-1] å’Œ text2[j-1] ç›¸ç­‰,åˆ™å½“å‰ä½ç½®çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦ä¸ºå·¦ä¸Šè§’ä½ç½®çš„å€¼åŠ ä¸€
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    # å¦‚æœ text1[i-1] å’Œ text2[j-1] ä¸ç›¸ç­‰,åˆ™å½“å‰ä½ç½®çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦ä¸ºä¸Šæ–¹æˆ–å·¦æ–¹çš„è¾ƒå¤§å€¼
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        # è¿”å›æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦
        return len(text1)+len(text2)-dp[len(text1)][len(text2)]*2


#39 (Medium) 72.ç¼–è¾‘è·ç¦»
    # ç»™ä½ ä¸¤ä¸ªå•è¯ word1 å’Œ word2ï¼Œè¯·ä½ è®¡ç®—å‡ºå°† word1 è½¬æ¢æˆ word2 æ‰€ä½¿ç”¨çš„æœ€å°‘æ“ä½œæ•° ã€‚
    # ä½ å¯ä»¥å¯¹ä¸€ä¸ªå•è¯è¿›è¡Œå¦‚ä¸‹ä¸‰ç§æ“ä½œï¼š
    # æ’å…¥ä¸€ä¸ªå­—ç¬¦
    # åˆ é™¤ä¸€ä¸ªå­—ç¬¦
    # æ›¿æ¢ä¸€ä¸ªå­—ç¬¦
    # ç¤ºä¾‹ 1ï¼š
    # è¾“å…¥ï¼šword1 = "horse", word2 = "ros"
    # è¾“å‡ºï¼š3
    # è§£é‡Šï¼š horse -> rorse (å°† 'h' æ›¿æ¢ä¸º 'r') rorse -> rose (åˆ é™¤ 'r') rose -> ros (åˆ é™¤ 'e')
    # ç¤ºä¾‹ 2ï¼š
    # è¾“å…¥ï¼šword1 = "intention", word2 = "execution"
    # è¾“å‡ºï¼š5
    # è§£é‡Šï¼š intention -> inention (åˆ é™¤ 't') inention -> enention (å°† 'i' æ›¿æ¢ä¸º 'e') enention -> exention (å°† 'n' æ›¿æ¢ä¸º 'x') exention -> exection (å°† 'n' æ›¿æ¢ä¸º 'c') exection -> execution (æ’å…¥ 'u')
# dp[i][j] è¡¨ç¤ºä»¥ä¸‹æ ‡i-1ä¸ºç»“å°¾çš„å­—ç¬¦ä¸²word1ï¼Œå’Œä»¥ä¸‹æ ‡j-1ä¸ºç»“å°¾çš„å­—ç¬¦ä¸²word2ï¼Œæœ€è¿‘ç¼–è¾‘è·ç¦»ä¸ºdp[i][j]ã€‚
"""
    if (word1[i - 1] == word2[j - 1])
        ä¸æ“ä½œ
    if (word1[i - 1] != word2[j - 1])
        å¢
        åˆ 
        æ¢
"""
# if (word1[i - 1] == word2[j - 1]) é‚£ä¹ˆè¯´æ˜ä¸ç”¨ä»»ä½•ç¼–è¾‘ï¼Œdp[i][j] å°±åº”è¯¥æ˜¯ dp[i - 1][j - 1]ï¼Œå³dp[i][j] = dp[i - 1][j - 1];
# if (word1[i - 1] != word2[j - 1])ï¼Œæ­¤æ—¶å°±éœ€è¦ç¼–è¾‘äº†ï¼Œå¦‚ä½•ç¼–è¾‘å‘¢ï¼Ÿ
# æ“ä½œä¸€ï¼šword1åˆ é™¤ä¸€ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆå°±æ˜¯ä»¥ä¸‹æ ‡i - 2ä¸ºç»“å°¾çš„word1 ä¸ j-1ä¸ºç»“å°¾çš„word2çš„æœ€è¿‘ç¼–è¾‘è·ç¦» å†åŠ ä¸Šä¸€ä¸ªæ“ä½œã€‚
# å³ dp[i][j] = dp[i - 1][j] + 1;
# æ“ä½œäºŒï¼šword2åˆ é™¤ä¸€ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆå°±æ˜¯ä»¥ä¸‹æ ‡i - 1ä¸ºç»“å°¾çš„word1 ä¸ j-2ä¸ºç»“å°¾çš„word2çš„æœ€è¿‘ç¼–è¾‘è·ç¦» å†åŠ ä¸Šä¸€ä¸ªæ“ä½œã€‚
# å³ dp[i][j] = dp[i][j - 1] + 1;
# è¿™é‡Œæœ‰åŒå­¦å‘ç°äº†ï¼Œæ€ä¹ˆéƒ½æ˜¯åˆ é™¤å…ƒç´ ï¼Œæ·»åŠ å…ƒç´ å»å“ªäº†ã€‚
# æ“ä½œä¸‰ï¼šæ›¿æ¢å…ƒç´ ï¼Œword1æ›¿æ¢word1[i - 1]ï¼Œä½¿å…¶ä¸word2[j - 1]ç›¸åŒï¼Œæ­¤æ—¶ä¸ç”¨å¢åˆ åŠ å…ƒç´ ã€‚
# å¯ä»¥å›é¡¾ä¸€ä¸‹ï¼Œif (word1[i - 1] == word2[j - 1])çš„æ—¶å€™æˆ‘ä»¬çš„æ“ä½œ æ˜¯ dp[i][j] = dp[i - 1][j - 1] å¯¹å§ã€‚
# é‚£ä¹ˆåªéœ€è¦ä¸€æ¬¡æ›¿æ¢çš„æ“ä½œï¼Œå°±å¯ä»¥è®© word1[i - 1] å’Œ word2[j - 1] ç›¸åŒã€‚
# æ‰€ä»¥ dp[i][j] = dp[i - 1][j - 1] + 1;
# ç»¼ä¸Šï¼Œå½“ if (word1[i - 1] != word2[j - 1]) æ—¶å–æœ€å°çš„ï¼Œå³ï¼šdp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        # dp[i][j]å¯¹åº”çš„æ˜¯i-1å’Œj-1ï¼Œæ‰€ä»¥è¦åˆ°i+1ï¼Œj+1
        dp = [[0] * (len(word2)+1) for _ in range(len(word1)+1)]
        for i in range(len(word1)+1):
            dp[i][0] = i
        for j in range(len(word2)+1):
            dp[0][j] = j
        for i in range(1, len(word1)+1):
            for j in range(1, len(word2)+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    # if (word1[i - 1] != word2[j - 1])
                    # æ“ä½œä¸€:word1åˆ é™¤ä¸€ä¸ªå…ƒç´  å³ dp[i][j] = dp[i - 1][j] + 1
                    # æ“ä½œäºŒ:word2åˆ é™¤ä¸€ä¸ªå…ƒç´  å³ dp[i][j] = dp[i][j - 1] + 1
                    # æ“ä½œä¸‰:æ›¿æ¢å…ƒç´ ,word1æ›¿æ¢word1[i - 1],ä½¿å…¶ä¸word2[j - 1]ç›¸åŒ
                    # æ­¤æ—¶ä¸ç”¨å¢åˆ åŠ å…ƒç´ ã€‚å³ dp[i][j] = dp[i - 1][j - 1] + 1
                    # ç»¼åˆä¸‰ç§æ“ä½œ,å–æœ€å°å°±æ˜¯
                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1
        return dp[-1][-1]


#X40 (Medium) 647.å›æ–‡å­ä¸² (è¿ç»­)
# ä¸€ä¸ªå­—ç¬¦ä¸²
    # ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä½ çš„ä»»åŠ¡æ˜¯è®¡ç®—è¿™ä¸ªå­—ç¬¦ä¸²ä¸­æœ‰å¤šå°‘ä¸ªå›æ–‡å­ä¸²ã€‚
    # å…·æœ‰ä¸åŒå¼€å§‹ä½ç½®æˆ–ç»“æŸä½ç½®çš„å­ä¸²ï¼Œå³ä½¿æ˜¯ç”±ç›¸åŒçš„å­—ç¬¦ç»„æˆï¼Œä¹Ÿä¼šè¢«è§†ä½œä¸åŒçš„å­ä¸²ã€‚
    # ç¤ºä¾‹ 1ï¼š
    # è¾“å…¥ï¼š"abc"
    # è¾“å‡ºï¼š3
    # è§£é‡Šï¼šä¸‰ä¸ªå›æ–‡å­ä¸²: "a", "b", "c"
    # ç¤ºä¾‹ 2ï¼š
    # è¾“å…¥ï¼š"aaa"
    # è¾“å‡ºï¼š6
    # è§£é‡Šï¼š6ä¸ªå›æ–‡å­ä¸²: "a", "a", "a", "aa", "aa", "aaa"
# å›æ–‡å­ä¸²æ˜¯è¦è¿ç»­çš„,å›æ–‡å­åºåˆ—å¯ä¸æ˜¯è¿ç»­çš„!
# 647.å›æ–‡å­ä¸²
# 5.æœ€é•¿å›æ–‡å­ä¸²
# å¸ƒå°”ç±»å‹çš„dp[i][j]ï¼šè¡¨ç¤ºåŒºé—´èŒƒå›´[i,j] ï¼ˆæ³¨æ„æ˜¯å·¦é—­å³é—­ï¼‰çš„å­ä¸²æ˜¯å¦æ˜¯å›æ–‡å­ä¸²ï¼Œå¦‚æœæ˜¯dp[i][j]ä¸ºtrueï¼Œå¦åˆ™ä¸ºfalseã€‚
# åœ¨ç¡®å®šé€’æ¨å…¬å¼æ—¶ï¼Œå°±è¦åˆ†æå¦‚ä¸‹å‡ ç§æƒ…å†µã€‚
# æ•´ä½“ä¸Šæ˜¯ä¸¤ç§ï¼Œå°±æ˜¯s[i]ä¸s[j]ç›¸ç­‰ï¼Œs[i]ä¸s[j]ä¸ç›¸ç­‰è¿™ä¸¤ç§ã€‚
# å½“s[i]ä¸s[j]ä¸ç›¸ç­‰ï¼Œé‚£æ²¡å•¥å¥½è¯´çš„äº†ï¼Œdp[i][j]ä¸€å®šæ˜¯falseã€‚
# å½“s[i]ä¸s[j]ç›¸ç­‰æ—¶ï¼Œè¿™å°±å¤æ‚ä¸€äº›äº†ï¼Œæœ‰å¦‚ä¸‹ä¸‰ç§æƒ…å†µ
# æƒ…å†µä¸€ï¼šä¸‹æ ‡i ä¸ jç›¸åŒï¼ŒåŒä¸€ä¸ªå­—ç¬¦ä¾‹å¦‚aï¼Œå½“ç„¶æ˜¯å›æ–‡å­ä¸²
# æƒ…å†µäºŒï¼šä¸‹æ ‡i ä¸ jç›¸å·®ä¸º1ï¼Œä¾‹å¦‚aaï¼Œä¹Ÿæ˜¯å›æ–‡å­ä¸²
# æƒ…å†µä¸‰ï¼šä¸‹æ ‡ï¼ši ä¸ jç›¸å·®å¤§äº1çš„æ—¶å€™ï¼Œä¾‹å¦‚cabacï¼Œæ­¤æ—¶s[i]ä¸s[j]å·²ç»ç›¸åŒäº†ï¼Œæˆ‘ä»¬çœ‹iåˆ°jåŒºé—´æ˜¯ä¸æ˜¯å›æ–‡å­ä¸²å°±çœ‹abaæ˜¯ä¸æ˜¯å›æ–‡å°±å¯ä»¥äº†ï¼Œé‚£ä¹ˆabaçš„åŒºé—´å°±æ˜¯ i+1 ä¸ j-1åŒºé—´ï¼Œè¿™ä¸ªåŒºé—´æ˜¯ä¸æ˜¯å›æ–‡å°±çœ‹dp[i + 1][j - 1]æ˜¯å¦ä¸ºtrueã€‚

# éå†é¡ºåºå¯æœ‰æœ‰ç‚¹è®²ç©¶äº†ã€‚
# é¦–å…ˆä»é€’æ¨å…¬å¼ä¸­å¯ä»¥çœ‹å‡ºï¼Œæƒ…å†µä¸‰æ˜¯æ ¹æ®dp[i + 1][j - 1]æ˜¯å¦ä¸ºtrueï¼Œåœ¨å¯¹dp[i][j]è¿›è¡Œèµ‹å€¼trueçš„ã€‚
# dp[i + 1][j - 1] åœ¨ dp[i][j]çš„å·¦ä¸‹è§’
# å¦‚æœè¿™çŸ©é˜µæ˜¯ä»ä¸Šåˆ°ä¸‹ï¼Œä»å·¦åˆ°å³éå†ï¼Œé‚£ä¹ˆä¼šç”¨åˆ°æ²¡æœ‰è®¡ç®—è¿‡çš„dp[i + 1][j - 1]ï¼Œä¹Ÿå°±æ˜¯æ ¹æ®ä¸ç¡®å®šæ˜¯ä¸æ˜¯å›æ–‡çš„åŒºé—´[i+1,j-1]ï¼Œæ¥åˆ¤æ–­äº†[i,j]æ˜¯ä¸æ˜¯å›æ–‡ï¼Œé‚£ç»“æœä¸€å®šæ˜¯ä¸å¯¹çš„ã€‚
# æ‰€ä»¥ä¸€å®šè¦ä»ä¸‹åˆ°ä¸Šï¼Œä»å·¦åˆ°å³éå†ï¼Œè¿™æ ·ä¿è¯dp[i + 1][j - 1]éƒ½æ˜¯ç»è¿‡è®¡ç®—çš„ã€‚
# æœ‰çš„ä»£ç å®ç°æ˜¯ä¼˜å…ˆéå†åˆ—ï¼Œç„¶åéå†è¡Œï¼Œå…¶å®ä¹Ÿæ˜¯ä¸€ä¸ªé“ç†ï¼Œéƒ½æ˜¯ä¸ºäº†ä¿è¯dp[i + 1][j - 1]éƒ½æ˜¯ç»è¿‡è®¡ç®—çš„ã€‚
# åŠ¨æ€è§„åˆ’
class Solution:
    def countSubstrings(self, s: str) -> int:
        dp = [[False] * len(s) for _ in range(len(s))]
        result = 0
        for i in range(len(s)-1, -1, -1): #æ³¨æ„éå†é¡ºåº
            for j in range(i, len(s)):
                if s[i] == s[j]:
                    if j - i <= 1: #æƒ…å†µä¸€ å’Œ æƒ…å†µäºŒ
                        result += 1
                        dp[i][j] = True
                    elif dp[i+1][j-1]: #æƒ…å†µä¸‰
                        result += 1
                        dp[i][j] = True
        return result
# åŠ¨æ€è§„åˆ’:ç®€æ´ç‰ˆ
# class Solution:
#     def countSubstrings(self, s: str) -> int:
#         dp = [[False] * len(s) for _ in range(len(s))]
#         result = 0
#         for i in range(len(s)-1, -1, -1): #æ³¨æ„éå†é¡ºåº
#             for j in range(i, len(s)):
#                 if s[i] == s[j] and (j - i <= 1 or dp[i+1][j-1]): 
#                     result += 1
#                     dp[i][j] = True
#         return result
# åŒæŒ‡é’ˆæ³•
# åŠ¨æ€è§„åˆ’çš„ç©ºé—´å¤æ‚åº¦æ˜¯åé«˜çš„ï¼Œæˆ‘ä»¬å†çœ‹ä¸€ä¸‹åŒæŒ‡é’ˆæ³•ã€‚
# é¦–å…ˆç¡®å®šå›æ–‡ä¸²ï¼Œå°±æ˜¯æ‰¾ä¸­å¿ƒç„¶åå‘ä¸¤è¾¹æ‰©æ•£çœ‹æ˜¯ä¸æ˜¯å¯¹ç§°çš„å°±å¯ä»¥äº†ã€‚
# åœ¨éå†ä¸­å¿ƒç‚¹çš„æ—¶å€™ï¼Œè¦æ³¨æ„ä¸­å¿ƒç‚¹æœ‰ä¸¤ç§æƒ…å†µã€‚
# ä¸€ä¸ªå…ƒç´ å¯ä»¥ä½œä¸ºä¸­å¿ƒç‚¹ï¼Œä¸¤ä¸ªå…ƒç´ ä¹Ÿå¯ä»¥ä½œä¸ºä¸­å¿ƒç‚¹ã€‚
# é‚£ä¹ˆæœ‰äººåŒå­¦é—®äº†ï¼Œä¸‰ä¸ªå…ƒç´ è¿˜å¯ä»¥åšä¸­å¿ƒç‚¹å‘¢ã€‚å…¶å®ä¸‰ä¸ªå…ƒç´ å°±å¯ä»¥ç”±ä¸€ä¸ªå…ƒç´ å·¦å³æ·»åŠ å…ƒç´ å¾—åˆ°ï¼Œå››ä¸ªå…ƒç´ åˆ™å¯ä»¥ç”±ä¸¤ä¸ªå…ƒç´ å·¦å³æ·»åŠ å…ƒç´ å¾—åˆ°ã€‚
# æ‰€ä»¥æˆ‘ä»¬åœ¨è®¡ç®—çš„æ—¶å€™ï¼Œè¦æ³¨æ„ä¸€ä¸ªå…ƒç´ ä¸ºä¸­å¿ƒç‚¹å’Œä¸¤ä¸ªå…ƒç´ ä¸ºä¸­å¿ƒç‚¹çš„æƒ…å†µã€‚
# è¿™ä¸¤ç§æƒ…å†µå¯ä»¥æ”¾åœ¨ä¸€èµ·è®¡ç®—ï¼Œä½†åˆ†åˆ«è®¡ç®—æ€è·¯æ›´æ¸…æ™°ï¼Œæˆ‘å€¾å‘äºåˆ†åˆ«è®¡ç®—ï¼Œä»£ç å¦‚ä¸‹
class Solution:
    def countSubstrings(self, s: str) -> int:
        result = 0
        for i in range(len(s)):
            result += self.extend(s, i, i, len(s)) #ä»¥iä¸ºä¸­å¿ƒ
            result += self.extend(s, i, i+1, len(s)) #ä»¥iå’Œi+1ä¸ºä¸­å¿ƒ
        return result
    
    def extend(self, s, i, j, n):
        res = 0
        while i >= 0 and j < n and s[i] == s[j]:
            i -= 1
            j += 1
            res += 1
        return res

# Longest Palindrome in a String
    # Return the longest palindromic substring within a given string.
    # Example:
    # Input: s = 'abccbaba'
    # Output: 'abccba'
def longest_palindrome_in_a_string(s: str) -> str:
    n = len(s)
    if n == 0:
        return ""
    dp = [[False] * n for _ in range(n)]
    max_len = 1
    start_index = 0
    # Base case: a single character is always a palindrome.
    for i in range(n):
        dp[i][i] = True
    # Base case: a substring of length two is a palindrome if both  
    # characters are the same.
    for i in range(n - 1):
        if s[i] == s[i + 1]:
            dp[i][i + 1] = True
            max_len = 2
            start_index = i
    # Find palindromic substrings of length 3 or greater.
    for substring_len in range(3, n + 1):
        # Iterate through each substring of length 'substring_len'.
        for i in range(n - substring_len + 1):
            j = i + substring_len - 1
            # If the first and last characters are the same, and the 
            # inner substring is a palindrome, then the current 
            # substring is a palindrome.
            if s[i] == s[j] and dp[i + 1][j - 1]:
                dp[i][j] = True
                max_len = substring_len
                start_index = i
    return s[start_index : start_index + max_len]

def longest_palindrome_in_a_string_expanding(s: str) -> str:
    n = len(s)
    start, max_len = 0, 0
    for center in range(n):
        # Check for odd-length palindromes.
        odd_start, odd_length = expand_palindrome(center, center, s)
        if odd_length > max_len:
            start = odd_start
            max_len = odd_length
        # Check for even-length palindromes.
        if center < n - 1 and s[center] == s[center + 1]:
            even_start, even_length = expand_palindrome(center, center + 1, s)
            if even_length > max_len:
                start = even_start
                max_len = even_length
    return s[start : start + max_len]

# Expands outward from the center of a base case to identify the start 
# index and length of the longest palindrome that extends from this 
# base case.
def expand_palindrome(left: int, right: int, s: str) -> Tuple[int, int]:
    while left > 0 and right < len(s) - 1 and s[left - 1] == s[right + 1]:
        left -= 1
        right += 1
    return left, right - left + 1


#X41 (Medium) 516.æœ€é•¿å›æ–‡å­åºåˆ— (ä¸è¿ç»­)
# ä¸€ä¸ªå­—ç¬¦ä¸²
    # ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œæ‰¾åˆ°å…¶ä¸­æœ€é•¿çš„å›æ–‡å­åºåˆ—ï¼Œå¹¶è¿”å›è¯¥åºåˆ—çš„é•¿åº¦ã€‚å¯ä»¥å‡è®¾ s çš„æœ€å¤§é•¿åº¦ä¸º 1000 ã€‚
    # ç¤ºä¾‹ 1: è¾“å…¥: "bbbab" è¾“å‡º: 4 ä¸€ä¸ªå¯èƒ½çš„æœ€é•¿å›æ–‡å­åºåˆ—ä¸º "bbbb"ã€‚
    # ç¤ºä¾‹ 2: è¾“å…¥:"cbbd" è¾“å‡º: 2 ä¸€ä¸ªå¯èƒ½çš„æœ€é•¿å›æ–‡å­åºåˆ—ä¸º "bb"ã€‚
# å›æ–‡å­ä¸²æ˜¯è¦è¿ç»­çš„ï¼Œå›æ–‡å­åºåˆ—å¯ä¸æ˜¯è¿ç»­çš„ï¼ å›æ–‡å­ä¸²ï¼Œå›æ–‡å­åºåˆ—éƒ½æ˜¯åŠ¨æ€è§„åˆ’ç»å…¸é¢˜ç›®ã€‚
# æ€è·¯å…¶å®æ˜¯å·®ä¸å¤šçš„ï¼Œä½†æœ¬é¢˜è¦æ¯”æ±‚å›æ–‡å­ä¸²ç®€å•ä¸€ç‚¹ï¼Œå› ä¸ºæƒ…å†µå°‘äº†ä¸€ç‚¹ã€‚
# dp[i][j]ï¼šå­—ç¬¦ä¸²såœ¨[i, j]èŒƒå›´å†…æœ€é•¿çš„å›æ–‡å­åºåˆ—çš„é•¿åº¦ä¸ºdp[i][j]ã€‚
# åœ¨åˆ¤æ–­å›æ–‡å­ä¸²çš„é¢˜ç›®ä¸­ï¼Œå…³é”®é€»è¾‘å°±æ˜¯çœ‹s[i]ä¸s[j]æ˜¯å¦ç›¸åŒã€‚
# å¦‚æœs[i]ä¸s[j]ç›¸åŒï¼Œé‚£ä¹ˆdp[i][j] = dp[i + 1][j - 1] + 2;
# å¦‚æœs[i]ä¸s[j]ä¸ç›¸åŒï¼Œè¯´æ˜s[i]å’Œs[j]çš„åŒæ—¶åŠ å…¥ å¹¶ä¸èƒ½å¢åŠ [i,j]åŒºé—´å›æ–‡å­åºåˆ—çš„é•¿åº¦ï¼Œé‚£ä¹ˆåˆ†åˆ«åŠ å…¥s[i]ã€s[j]çœ‹çœ‹å“ªä¸€ä¸ªå¯ä»¥ç»„æˆæœ€é•¿çš„å›æ–‡å­åºåˆ—ã€‚
# åŠ å…¥s[j]çš„å›æ–‡å­åºåˆ—é•¿åº¦ä¸ºdp[i + 1][j]ã€‚
# åŠ å…¥s[i]çš„å›æ–‡å­åºåˆ—é•¿åº¦ä¸ºdp[i][j - 1]ã€‚
# é‚£ä¹ˆdp[i][j]ä¸€å®šæ˜¯å–æœ€å¤§çš„ï¼Œå³ï¼šdp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);

# é¦–å…ˆè¦è€ƒè™‘å½“i å’Œj ç›¸åŒçš„æƒ…å†µï¼Œä»é€’æ¨å…¬å¼ï¼šdp[i][j] = dp[i + 1][j - 1] + 2; å¯ä»¥çœ‹å‡º é€’æ¨å…¬å¼æ˜¯è®¡ç®—ä¸åˆ° i å’Œjç›¸åŒæ—¶å€™çš„æƒ…å†µã€‚
# æ‰€ä»¥éœ€è¦æ‰‹åŠ¨åˆå§‹åŒ–ä¸€ä¸‹ï¼Œå½“iä¸jç›¸åŒï¼Œé‚£ä¹ˆdp[i][j]ä¸€å®šæ˜¯ç­‰äº1çš„ï¼Œå³ï¼šä¸€ä¸ªå­—ç¬¦çš„å›æ–‡å­åºåˆ—é•¿åº¦å°±æ˜¯1ã€‚
# å…¶ä»–æƒ…å†µdp[i][j]åˆå§‹ä¸º0å°±è¡Œï¼Œè¿™æ ·é€’æ¨å…¬å¼ï¼šdp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); ä¸­dp[i][j]æ‰ä¸ä¼šè¢«åˆå§‹å€¼è¦†ç›–

# ä»é€’å½’å…¬å¼ä¸­ï¼Œå¯ä»¥çœ‹å‡ºï¼Œdp[i][j] ä¾èµ–äº dp[i + 1][j - 1] ï¼Œdp[i + 1][j] å’Œ dp[i][j - 1]ï¼Œ
# æ‰€ä»¥éå†içš„æ—¶å€™ä¸€å®šè¦ä»ä¸‹åˆ°ä¸Šéå†ï¼Œè¿™æ ·æ‰èƒ½ä¿è¯ä¸‹ä¸€è¡Œçš„æ•°æ®æ˜¯ç»è¿‡è®¡ç®—çš„ã€‚
# jçš„è¯ï¼Œå¯ä»¥æ­£å¸¸ä»å·¦å‘å³éå†ã€‚
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        dp = [[0] * len(s) for _ in range(len(s))]
        for i in range(len(s)):
            dp[i][i] = 1
        for i in range(len(s)-1, -1, -1):
            for j in range(i+1, len(s)):
                if s[i] == s[j]:
                    dp[i][j] = dp[i+1][j-1] + 2
                else:
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])
        return dp[0][-1] #æ³¨æ„æœ€ç»ˆçŠ¶æ€çš„ä½ç½®ï¼Œå› ä¸ºæ˜¯ä»ä¸‹å¾€ä¸Šï¼Œæ‰€ä»¥æœ€ååœ¨å³ä¸Šè§’

def longest_palindrome_in_a_string(s: str) -> str:
    n = len(s)
    if n == 0:
        return ""
    dp = [[False] * n for _ in range(n)]
    max_len = 1
    start_index = 0
    # Base case: a single character is always a palindrome.
    for i in range(n):
        dp[i][i] = True
    # Base case: a substring of length two is a palindrome if both  
    # characters are the same.
    for i in range(n - 1):
        if s[i] == s[i + 1]:
            dp[i][i + 1] = True
            max_len = 2
            start_index = i
    # Find palindromic substrings of length 3 or greater.
    for substring_len in range(3, n + 1):
        # Iterate through each substring of length 'substring_len'.
        for i in range(n - substring_len + 1):
            j = i + substring_len - 1
            # If the first and last characters are the same, and the 
            # inner substring is a palindrome, then the current 
            # substring is a palindrome.
            if s[i] == s[j] and dp[i + 1][j - 1]:
                dp[i][j] = True
                max_len = substring_len
                start_index = i
    return s[start_index : start_index + max_len]

def longest_palindrome_in_a_string_expanding(s: str) -> str:
    n = len(s)
    start, max_len = 0, 0
    for center in range(n):
        # Check for odd-length palindromes.
        odd_start, odd_length = expand_palindrome(center, center, s)
        if odd_length > max_len:
            start = odd_start
            max_len = odd_length
        # Check for even-length palindromes.
        if center < n - 1 and s[center] == s[center + 1]:
            even_start, even_length = expand_palindrome(center, center + 1, s)
            if even_length > max_len:
                start = even_start
                max_len = even_length
    return s[start : start + max_len]

# Expands outward from the center of a base case to identify the start 
# index and length of the longest palindrome that extends from this 
# base case.
def expand_palindrome(left: int, right: int, s: str) -> Tuple[int, int]:
    while left > 0 and right < len(s) - 1 and s[left - 1] == s[right + 1]:
        left -= 1
        right += 1
    return left, right - left + 1


# ByteByteGo 101
#X42 Minimum Coin Combination
    # You are given an array of coin values and a target amount of money.
    # Return the minimum number of coins needed to total the target amount. If this isn't possible, return â€1. 
    # You may assume there's an unlimited supply of each coin.
    # Example 1:
    # Input: coins = [1, 2, 3], target = 5
    # Output: 2
    # Explanation: Use one 2-dollar coin and one 3-dollar coin to make 5 dollars.
    # Example 2:
    # Input: coins = [2, 4], target = 5
    # Output: -1
from typing import List

def min_coin_combination_bottom_up(coins: List[int], target: int) -> int:
    # The DP array will store the minimum number of coins needed for 
    # each amount. Set each element to a large number initially.
    dp = [float('inf')] * (target + 1)
    # Base case: if the target is 0, then 0 coins are needed.
    dp[0] = 0
    # Update the DP array for all target amounts greater than 0.
    
    for t in range(1, target + 1):
        for coin in coins:
            if coin <= t:
                dp[t] = min(dp[t], 1 + dp[t - coin])
    return dp[target] if dp[target] != float('inf') else -1


#X43 Matrix Pathways
    # You are positioned at the top-left corner of a m Ã— n matrix, and can only move 
    # downward or rightward through the matrix. Determine the number of unique pathways 
    # you can take to reach the bottom-right corner of the matrix.
def matrix_pathways(m: int, n: int) -> int:
    # Base cases: Set all cells in row 0 and column 0 to 1. We can
    # do this by initializing all cells in the DP table to 1.
    dp = [[1] * n for _ in range(m)]
    # Fill in the rest of the DP table.
    for r in range(1, m):
        for c in range(1, n):
            # Paths to current cell = paths from above + paths from 
            # left.
            dp[r][c] = dp[r - 1][c] + dp[r][c - 1]
    return dp[m - 1][n - 1]

def matrix_pathways_optimized(m: int, n: int) -> int:
    # Initialize 'prev_row' as the DP values of row 0, which are all 1s.
    prev_row = [1] * n
    # Iterate through the matrix starting from row 1.
    for r in range(1, m):
        # Set the first cell of 'curr_row' to 1. This is done by 
        # setting the entire row to 1.
        curr_row = [1] * n
        for c in range(1, n):
            # The number of unique paths to the current cell is the sum 
            # of the paths from the cell above it ('prev_row[c]') and 
            # the cell to the left ('curr_row[c - 1]').
            curr_row[c] = prev_row[c] + curr_row[c - 1]
        # Update 'prev_row' with 'curr_row' values for the next 
        # iteration.
        prev_row = curr_row
    # The last element in 'prev_row' stores the result for the 
    # bottom-right cell.
    return prev_row[n - 1]


#X44 Maximum Subarray Sum
    # Given an array of integers, return the sum of the subarray with the largest sum.
    # Example:
    # Input: nums = [3, 1, -6, 2, -1, 4, -9]
    # Output: 5
    # Explanation: subarray [2, -1, 4] has the largest sum of 5.
    # Constraints:
    # The input array contains at least one element.
from typing import List

def maximum_subarray_sum_dp(nums: List[int]) -> int:
    n = len(nums)
    if n == 0:
        return 0
    dp = [0] * n
    # Base case: the maximum subarray sum of an array with just one
    # element is that element.
    dp[0] = nums[0]
    max_sum = dp[0]
    # Populate the rest of the DP array.
    for i in range(1, n):
        # Determine the maximum subarray sum ending at the current 
        # index.
        dp[i] = max(dp[i - 1] + nums[i], nums[i])
        max_sum = max(max_sum, dp[i])
    return max_sum

def maximum_subarray_sum_dp_optimized(nums: List[int]) -> int:
    n = len(nums)
    if n == 0:
        return 0
    current_sum = nums[0]
    max_sum = nums[0]
    for i in range(1, n):
        current_sum = max(nums[i], current_sum + nums[i])
        max_sum = max(max_sum, current_sum)
    return max_sum


#X45 Largest Square in a Matrix
    # Determine the area of the largest square of 1's in a binary matrix.
from typing import List

def largest_square_in_a_matrix(matrix: List[List[int]]) -> int:
    if not matrix:
        return 0
    m, n = len(matrix), len(matrix[0])
    dp = [[0] * n for _ in range(m)]
    max_len = 0
    # Base case: If a cell in row 0 is 1, the largest square ending there has a
    # length of 1.
    for j in range(n):
        if matrix[0][j] == 1:
            dp[0][j] = 1
            max_len = 1
    # Base case: If a cell in column 0 is 1, the largest square ending there has
    # a length of 1.
    for i in range(m):
        if matrix[i][0] == 1:
            dp[i][0] = 1
            max_len = 1
    # Populate the rest of the DP table.
    for i in range(1, m):
        for j in range(1, n):
            if matrix[i][j] == 1:
                # The length of the largest square ending here is determined by 
                # the smallest square ending at the neighboring cells (left, 
                # top-left, top), plus 1 to include this cell.
                dp[i][j] = 1 + min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1])
            max_len = max(max_len, dp[i][j])
    return max_len ** 2

def largest_square_in_a_matrix_optimized(matrix: List[List[int]]) -> int:
    if not matrix:
        return 0
    m, n = len(matrix), len(matrix[0])
    prev_row = [0] * n
    max_len = 0
    # Iterate through the matrix.
    for i in range(m):
        curr_row = [0] * n
        for j in range(n):
            # Base cases: if weâ€™re in row 0 or column 0, the largest square ending
            # here has a length of 1. This can be set by using the value in the
            # input matrix.
            if i == 0 or j == 0:
                curr_row[j] = matrix[i][j]
            else:
                if matrix[i][j] == 1:
                      # curr_row[j] = 1 + min(left, top-left, top)
                    curr_row[j] = 1 + min(curr_row[j - 1], prev_row[j - 1], prev_row[j])
            max_len = max(max_len, curr_row[j])
        # Update 'prev_row' with 'curr_row' values for the next iteration.
        prev_row, curr_row = curr_row, [0] * n
    return max_len ** 2


#45 (Medium) 1062. Longest Repeating Substring
    # Given a string s, return the length of the longest repeating substrings. If no repeating substring exists, return 0.
    # Example 1:
    # Input: s = "abcd"
    # Output: 0
    # Explanation: There is no repeating substring.
    # Example 2:
    # Input: s = "abbaba"
    # Output: 2
    # Explanation: The longest repeating substrings are "ab" and "ba", each of which occurs twice.
    # Example 3:
    # Input: s = "aabcaabdaab"
    # Output: 3
    # Explanation: The longest repeating substring is "aab", which occurs 3 times.
# Approach 5: Dynamic Programming
# Time complexity: O(n^2)
# Space complexity: O(n^2)
class Solution:
    def longestRepeatingSubstring(self, s: str) -> int:
        length = len(s)
        dp = [[0] * (length + 1) for _ in range(length + 1)]
        max_length = 0

        # Populate the DP array
        for i in range(1, length + 1):
            for j in range(i + 1, length + 1):
                # Check if the characters match and
                # update the DP value
                if s[i - 1] == s[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                    # Update max_length
                    max_length = max(max_length, dp[i][j])
        return max_length