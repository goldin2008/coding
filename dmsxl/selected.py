"""
Week 1 数组 & 字符串基础
具体：刷完数组与字符串相关的基础题；可衡量：完成 10 题, 每题记录解题时间与思路；可达成：每天利用 1 小时；相关：打好基础, 对后续题型铺垫；时限：本周内完成。
* 1. Two Sum 
* 344. Reverse String
242. Valid Anagram
88. Merge Sorted Array
14. Longest Common Prefix
49. Group Anagrams
* 3. Longest Substring Without Repeating Characters
238. Product of Array Except Self
* 11. Container With Most Water
* 15. 3Sum
* 125. Valid Palindrome
* 209. Minimum Size Subarray Sum
* 283. Move Zeroes
* 42. Trapping Rain Water


Week 2 链表
具体：完成链表基本操作题；可衡量：每题记录关键指针操作与边界处理；可达成：每天 1 小时分散完成；相关：链表题是面试高频考点；时限：本周内完成所有链表题。
* 206. Reverse Linked List
* 141. Linked List Cycle
* 234. Palindrome Linked List
21. Merge Two Sorted Lists
* 160. Intersection of Two Linked Lists
83. Remove Duplicates from Sorted List
* 19. Remove Nth Node From End of List
2. Add Two Numbers
* 142. Linked List Cycle II
86. Partition List
138. Copy List with Random Pointer
328. Odd Even Linked List
445. Add Two Numbers II
* 23. Merge k Sorted Lists


Week 3 栈与队列
具体：刷完所有与栈、队列相关的题；可衡量：每题记录思路和时间；可达成：每天 1 小时；相关：掌握括号匹配、表达式求值等基础应用；时限：本周内完成。
    核心题目
* 20 Valid Parentheses (Easy, Facebook/Amazon/Microsoft)
* 155 Min Stack (Medium, Amazon/Microsoft/Bloomberg)
* 232 Implement Queue using Stacks (Easy, Microsoft/Amazon)
* 1047 Remove All Adjacent Duplicates In String (Easy, Facebook/Amazon)
394 Decode String (Medium, Facebook/Google)
1249 Remove Minimum Invalid Parentheses (Medium, Facebook)
856 Score of Parentheses (Medium, Facebook)
* 225 Implement Stack using Queues (Easy, Microsoft)
682 Baseball Game (Easy, Amazon)
71 Simplify Path (Medium, Facebook/Microsoft)
    Optional Problems
* 224 Basic Calculator (Hard, Facebook/Google)
636 Exclusive Time of Functions (Medium, Facebook)
341 Flatten Nested List Iterator (Medium, Facebook/Google)
* 150 Evaluate Reverse Polish Notation (Medium, Microsoft/Amazon)
739 Daily Temperatures (Medium, Amazon/Google)
84 Largest Rectangle in Histogram (Hard, Amazon/Microsoft)
901 Online Stock Span (Medium, Amazon/Microsoft)
946 Validate Stack Sequences (Medium, Google/Amazon)


Week 4 树的基础(遍历)
具体：完成二叉树遍历及相关基础题；可衡量：题目完成数及遍历方式掌握情况；可达成：每天 1 小时；相关：树结构常考, 需熟悉递归与迭代实现；时限：一周内完成所有题目。
    核心题目 (14道)
    Easy Level (5道)
* 94. Binary Tree Inorder Traversal
100. Same Tree
* 101. Symmetric Tree
* 104. Maximum Depth of Binary Tree
* 257. Binary Tree Paths
    Medium Level (8道)
* 102. Binary Tree Level Order Traversal
* 110. Balanced Binary Tree
* 112. Path Sum
* 144. Binary Tree Preorder Traversal
* 145. Binary Tree Postorder Traversal
* 199. Binary Tree Right Side View
* 226. Invert Binary Tree
543. Diameter of Binary Tree
    Hard Level (1道)
* 124. Binary Tree Maximum Path Sum
    选做题目 (8道)
    Medium Level (6道)
* 98. Validate Binary Search Tree
103. Binary Tree Zigzag Level Order Traversal
* 105. Construct Binary Tree from Preorder and Inorder Traversal
* 116. Populating Next Right Pointers in Each Node
* 235. Lowest Common Ancestor of a Binary Search Tree
* 617. Merge Two Binary Trees
    Hard Level (2道)
* 236. Lowest Common Ancestor of a Binary Tree
* 297. Serialize and Deserialize Binary Tree


Week 5 树进阶 & 递归
具体：攻克树的高级题及递归回溯相关题；可衡量：每题思路与递归终止条件清晰；可达成：保持每天 1 小时练习；相关：提升解决复杂问题的能力；时限：本周内完成所有目标。
    核心题目 (14道)
    Easy Level (5道)
* 111. Minimum Depth of Binary Tree
* 404. Sum of Left Leaves
* 501. Find Mode in Binary Search Tree
572. Subtree of Another Tree
606. Construct String from Binary Tree
    Medium Level (8道)
95. Unique Binary Search Trees II
* 113. Path Sum II
129. Sum Root to Leaf Numbers
* 222. Count Complete Tree Nodes
* 230. Kth Smallest Element in a BST
* 450. Delete Node in a BST
* 513. Find Bottom Left Tree Value
* 669. Trim a Binary Search Tree
    Hard Level (1道)
* 337. House Robber III
    选做题目 (8道)
    Medium Level (6道)
96. Unique Binary Search Trees
173. Binary Search Tree Iterator
250. Count Univalue Subtrees
508. Most Frequent Subtree Sum
* 538. Convert BST to Greater Tree
652. Find Duplicate Subtrees
    Hard Level (2道)
687. Longest Univalue Path
968. Binary Tree Camera


Week 6 图 & 搜索算法
具体: 完成图的遍历与搜索相关题;可衡量:题目数量、BFS/DFS 实现情况；可达成：每天 1 小时；相关：图论为综合应用, 重点在遍历与标记；时限：本周内完成所有题目。
    核心题目 (14道)
    Easy Level (5道)
* 1971. Find if Path Exists in Graph
733. Flood Fill
* 841. Keys and Rooms
547. Number of Provinces
690. Employee Importance
    Medium Level (8道)
* 200. Number of Islands
* 207. Course Schedule
210. Course Schedule II
* 417. Pacific Atlantic Water Flow
994. Rotting Oranges
* 130. Surrounded Regions
* 785. Is Graph Bipartite?
886. Possible Bipartition
    Hard Level (1道)
332. Reconstruct Itinerary
    选做题目 (8道)
    Medium Level (6道)
* 133. Clone Graph
* 695. Max Area of Island
721. Accounts Merge
743. Network Delay Time
802. Find Eventual Safe States
947. Most Stones Removed with Same Row or Column
    Hard Level (2道)
399. Evaluate Division
778. Swim in Rising Water


Week 7 回溯算法
具体：熟练掌握回溯算法解决排列、组合问题；可衡量：每题记录递归树、剪枝策略；可达成：每天 1 小时；相关：回溯思路是面试常考题型；时限：本周内完成所有回溯题。
    核心题目 (14道)
    Easy Level (5道)
401. Binary Watch
257. Binary Tree Paths
784. Letter Case Permutation
1079. Letter Tile Possibilities
690. Employee Importance
    Medium Level (8道)
* 17. Letter Combinations of a Phone Number
* 39. Combination Sum
* 40. Combination Sum II
* 46. Permutations
* 47. Permutations II
* 77. Combinations
* 78. Subsets
* 90. Subsets II
    Hard Level (1道)
* 51. N-Queens
    选做题目 (8道)
    Medium Level (6道)
79. Word Search
* 93. Restore IP Addresses
* 131. Palindrome Partitioning
* 216. Combination Sum III
* 491. Non-decreasing Subsequences
526. Beautiful Arrangement
    Hard Level (2道)
* 37. Sudoku Solver
* 52. N-Queens II


Week 8 动态规划(DP)基础
具体：完成 DP 基础题, 理解状态转移及子问题分解；可衡量：题目数量与思路总结；可达成：每天 1 小时；相关：DP 为面试重点, 打好基础很关键；时限：本周内完成所有 DP 基础题。
    核心题目 (14道)
    Easy Level (5道)
* 70. Climbing Stairs
* 121. Best Time to Buy and Sell Stock
* 198. House Robber
* 509. Fibonacci Number
* 746. Min Cost Climbing Stairs
    Medium Level (8道)
* 62. Unique Paths
* 63. Unique Paths II
64. Minimum Path Sum
91. Decode Ways
* 300. Longest Increasing Subsequence
* 322. Coin Change
* 416. Partition Equal Subset Sum
* 647. Palindromic Substrings
    Hard Level (1道)
* 1143. Longest Common Subsequence
    选做题目 (8道)
    Medium Level (6道)
120. Triangle
* 139. Word Break
* 213. House Robber II
* 279. Perfect Squares
* 309. Best Time to Buy and Sell Stock with Cooldown
* 518. Coin Change II
    Hard Level (2道)
* 72. Edit Distance
312. Burst Balloons


Week 9 动态规划(DP)进阶
具体：攻克 DP 难题, 强化状态转移及空间优化技巧；可衡量：题目完成数与正确率、思路清晰；可达成：每天 1 小时；相关：提升 DP 解决复杂问题的能力；时限：本周内完成所有高级 DP 题。


Week 10 贪心算法 & 双指针
具体：解决贪心与双指针相关题, 掌握题型技巧；可衡量：完成题目数量与正确率；可达成：每天 1 小时；相关：这些题型锻炼思路简化和边界判断能力；时限：本周内完成所有目标题。


Week 11 二分搜索 & 综合题型
具体：刷完二分搜索及综合题, 强化边界处理与思维拓展；可衡量：题目完成数与总结归纳情况；可达成：每天 1 小时；相关：二分及综合题考验算法综合实力；时限：本周内完成所有目标题。


Week 12 10 题＋模拟面试
具体：回顾前 11 周所有重点题目, 针对错题进行重新攻克, 并安排 2 次全真模拟面试；可衡量：复做 10 道经典题及模拟面试次数；可达成：合理安排复盘时间；相关：全面检测知识盲区、提升实战能力；时限：本周内完成所有复习与模拟。



(quick sort, merge sort)
    148. Sort List
    56. Merge Intervals
    * 27. Remove elements

    179. Largest Number
    75. Sort Colors
    215. Kth Largest Element (可以用堆的解法替代)
    4. Median of Two Sorted Arrays

 
Linked List
    206. Reverse Linked List
    876. Middle of the Linked List

    160. Intersection of Two Linked Lists
    141. Linked List Cycle (Linked List Cycle II)
    92. Reverse Linked List II
    328. Odd Even Linked List


Queue
    225. Implement Stack using Queues
    346. Moving Average from Data Stream
    281. Zigzag Iterator
    54. Spiral Matrix

    1429. First Unique Number
    362. Design Hit Counter


Stack
    155. Min Stack (follow up716 Max Stack)
    232. Implement Queue using Stacks
    150. Evaluate Reverse Polish Notation
    224. Basic Calculator II (I, II, III, IV)
    20. Valid Parentheses
    
    1472. Design Browser History
    1209. Remove All Adjacent Duplicates in String II
    1249. Minimum Remove to Make Valid Parentheses
    735. Asteroid Collision


Hashmap/ Hashset
    1. Two Sum
    146. LRU Cache (Python中可以使用OrderedDict来代替)
    128. Longest Consecutive Sequence
    73. Set Matrix Zeroes
    49. Group Anagrams

    380. Insert Delete GetRandom O(1)
    350. Intersection of Two Arrays II
    299. Bulls and Cows
    348 Design Tic-Tac-Toe


Heap / Priority Queue
    973. K Closest Points
    347. Top k Largest Elements
    23. Merge K Sorted Lists
    88. Merge Sorted Arrays
    692. Top K Frequent Words
    378. Kth Smallest Element in a Sorted Matrix (Stack)

    264. Ugly Number II
    1086. High Five 
    295. Find Median from Data Stream (标准解法是双heap,但是SortedDict会非常容易)
    
    767. Reorganize String
    1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit (这个题用单调双端队列、TreeMap、双heap都可以)
    895. Maximum Frequency


Binary Search
    34. Find First and Last Position of Element in Sorted Array
    33. Search in Rotated Sorted Array
    1095. Find in Mountain Array
    162. Find Peak Element
    278. First Bad Version
    74. Search a 2D Matrix
    240. Search a 2D Matrix II
    
    69. Sqrt(x)
    540. Single Element in a Sorted Array
    644. Maximum Average Subarray II
    528. Random Pick with Weight
 
    1300. Sum of Mutated Array Closest to Target
    1060. Missing Element in Sorted Array
    1062. Longest Repeating Substring
    1891. Cutting Ribbons
    410. Split Array Largest Sum (与1891类似)


双指针(2 Pointer)
    409. Longest Palindrome
    125. Valid Palindrome (I、II)
    5. Longest Palindromic Substring
    647. Palindromic Substrings

    1. Two Sum (这里使用的是先排序的双指针算法,不同于hashmap做法)
    167. Two Sum II - Input array is sorted
    15. 3Sum
    16. 3Sum Closest
    18. 4Sum
    454. 4Sum II
    277. Find the Celebrity
    11. Container With Most Water
    186 Reverse Words in a String II
    
    283. Move Zeroes
    26. Remove Duplicate Numbers in Array
    395. Longest Substring with At Least K Repeating Characters
    340. Longest Substring with At Most K Distinct Characters
    424. Longest Repeating Character Replacement
    76. Minimum Window Substring
    3. Longest Substring Without Repeating Characters
    1004 Max Consecutive Ones III
    1658 Minimum Operations to Reduce X to Zero


BFS
    102 Binary Tree Level Order Traversal
    103 Binary Tree Zigzag Level Order Traversal
    297 Serialize and Deserialize Binary Tree (很好的BFS和双指针结合的题)
    314 Binary Tree Vertical Order Traversal

    200. Number of Islands
    133. Clone Graph
    127. Word Ladder
    490. The Maze
    323. Connected Component in Undirected Graph
    130. Surrounded Regions
    752. Open the Lock
    815. Bus Routes
    1091. Shortest Path in Binary Matrix
    542. 01 Matrix
    1293. Shortest Path in a Grid with Obstacles Elimination
    417. Pacific Atlantic Water Flow

    207 Course Schedule (I, II)
    444 Sequence Reconstruction
    269 Alien Dictionary
    310 Minimum Height Trees
    366 Find Leaves of Binary Tree


DFS
    543 Diameter of Binary Tree (分治)
    124 Binary Tree Maximum Path Sum (分治)
    226 Invert Binary Tree (分治)
    101 Symmetric Tree (回溯 or 分治)
    951 Flip Equivalent Binary Trees (分治)
    236 Lowest Common Ancestor of a Binary Tree (相似题: 235、1650) (回溯 or 分治)
    105 Construct Binary Tree from Preorder and Inorder Traversal (分治)
    104 Maximum Depth of Binary Tree (回溯 or 分治)
    987 Vertical Order Traversal of a Binary Tree
    1485 Clone Binary Tree With Random Pointer
    572 Subtree of Another Tree (分治)
    863 All Nodes Distance K in Binary Tree
    1110 Delete Nodes And Return Forest (分治)


BST
    230 Kth Smallest element in a BST
    98 Validate Binary Search Tree
    270 Cloest Binary Search Tree Value
    235 Lowest Common Ancestor of a Binary Search Tree
    669 Trim a Binary Search Tree (分治)
    700 Search in a Binary Search Tree
    108 Convert Sorted Array to Binary Search Tree (分治)
    333 Largest BST Subtree (与98类似) (分治)
    285 Inorder Successor in BST (I, II)


基于图的DFS
    341 Flatten Nested List Iterator (339 364)
    394 Decode String
    51 N-Queens (I II基本相同)
    291 Word Pattern II (I为简单的Hashmap题)
    126 Word Ladder II (I为BFS题目)
    93 Restore IP Addresses
    22 Generate Parentheses
    856 Score of Parentheses
    301 Remove Invalid Parentheses
    37 Sodoku Solver
    212 Word Search II (I, II)
    1087 Brace Expansion
    399 Evaluate Division
    1274 Number of Ships in a Rectangle
    1376 Time Needed to Inform All Employees
    694 Number of Distinct Islands
    131 Palindrome Partitioning


基于排列组合的DFS:
    17 Letter Combinations of a Phone Number
    39 Combination Sum(I, II, III相似,  IV为动态规划题目)
    78 Subsets (I, II 重点在于如何去重)
    46 Permutation (I, II 重点在于如何去重)
    77 Combinations (I, II 重点在于如何去重)
    698 Partition to K Equal Sum Subsets
    526 Beautiful Arrangement (similar to 46)


DFS + Memoization Search
    139 Word Break II
    72 Edit Distance
    377 Combination Sum IV
    1235 Maximum Profit in Job Scheduling
    1335 Minimum Difficulty of a Job Schedule
    1216 Valid Palindrome III
    97 Interleaving String
    472 Concatenated Words
    403 Frog Jump
    329 Longest Increasing Path in a Matrix


Prefix Sum
    53 Maximum Subarray
    1423 Maximum Points You Can Obtain from Cards
    1031 Maximum Sum of Two Non-Overlapping Subarrays
    523 Continuous Subarray Sum
    304 Range Sum Query 2D - Immutable


Union Find
    721 Accounts Merge
    547 Number of Provinces
    737 Sentence Similarity II
    305 Number of Islands II


Trie
    208 Implement Trie (Prefix Tree)
    211 Design Add and Search Words Data Structure
    1268 Search Suggestions System
    212 Word Search II
    1166 Design File System


Monotone Stack / Queue
    85 Maximum Rectangle
    84 Largest Rectangle in Histogram
    907 Sum of Subarray Minimums (与84类似)
    739 Daily Temperatures
    901 Online Stock Span
    503 Next Greater Element II
    239 Sliding Window Maximum (唯一的单调队列题)


Sweep Line
    253 Meeting Room II(Meeting Room I也可以使用)
    1094 Car Pooling
    218 The Skyline Problem
    759 Employee Free Time

 
TreeMap
    729 My Calendar I
    981 Time Based Key-Value Store
    846 Hand of Straights
    218 The Skyline Problem
    480. Sliding Window Median (这个题用TreeMap超级方便)
    318 Count of Smaller Numbers After Self (这个题线段树、二分索引树、TreeMap都可以)


Dynamic Programming(part 1)
    674 Longest Continuous Increasing Subsequence (接龙型dp)
    62 Unique Paths II
    70 Climbing Stairs
    64 Minimum Path Sum
    368 Largest Divisible Subset (接龙型dp)
    300 Longest Increasing Subsequence (接龙型dp)
    354 Russian Doll Envelopes (接龙型dp,  300的2D版)
    256 Paint House
    121 Best Time to Buy and Sell Stock
    55 Jump Game
    45 Jump Game II
    132 Palindrome Partitioning II


DP 2 
    312 Burst Balloons (区间型dp)
    1143 Longest Common Subsequence (前缀型dp)
    1062 Longest Repeating Substring (dp方法与longest common substring一致)
    718 Maximum Length of Repeated Subarray (和1062本质上一样)
    174 Dungeon Game
    115 Distinct Subsequences
    72 Edit Distance
    91 Decode Ways
    639 Decode Ways II
    712 Minimum ASCII Delete Sum for Two Strings
    221 Maximal Square
    1277 Count Square Submatrices with All Ones (可以使用221一样的解法)


DP 3
    198 House Robber
    213 House Robber II
    740 Delete and Earn
    87 Scramble String
    1140 Stone Game II
    322 Coin Change
    518 Coin Change II (01背包型)
    1048 Longest String Chain
    44 Wildcard Matching
    10 Regular Expression Matching
    32 Longest Valid Parentheses
    1235 Maximum Profit in Job Scheduling (DP + binary search)
    1043 Partition Array for Maximum Sum
    926 Flip String to Monotone Increasing
"""
#1 (Medium) 1387. Sort Integers by The Power Value
    # The power of an integer x is defined as the number of steps needed to transform x into 1 using the following steps:
    # if x is even then x = x / 2
    # if x is odd then x = 3 * x + 1
    # For example, the power of x = 3 is 7 because 3 needs 7 steps to become 1 (3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1).
    # Given three integers lo, hi and k. The task is to sort all integers in the interval [lo, hi] by the power value in ascending order, if two or more integers have the same power value sort them by ascending order.
    # Return the kth integer in the range [lo, hi] sorted by the power value.
    # Notice that for any integer x (lo <= x <= hi) it is guaranteed that x will transform into 1 using these steps and that the power of x is will fit in a 32-bit signed integer.
# Example 1:
# Input: lo = 12, hi = 15, k = 2
# Output: 13
# Explanation: The power of 12 is 9 (12 --> 6 --> 3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1)
# The power of 13 is 9
# The power of 14 is 17
# The power of 15 is 17
# The interval sorted by the power value [12,13,14,15]. For k = 2 answer is the second element which is 13.
# Notice that 12 and 13 have the same power value and we sorted them in ascending order. Same for 14 and 15.
# Example 2:
# Input: lo = 7, hi = 11, k = 4
# Output: 7
# Explanation: The power array corresponding to the interval [7, 8, 9, 10, 11] is [16, 3, 19, 6, 14].
# The interval sorted by power is [8, 10, 11, 7, 9].
# The fourth number in the sorted array is 7.
def getKth(lo: int, hi: int, k: int) -> int:
    memo = {}
    
    def get_power(x):
        if x == 1:
            return 0
        if x in memo:
            return memo[x]
        if x % 2 == 0:
            memo[x] = 1 + get_power(x // 2)
        else:
            memo[x] = 1 + get_power(3 * x + 1)
        return memo[x]  # Ensure this is outside the if-else blocks
    
    numbers = []
    for num in range(lo, hi + 1):
        power = get_power(num)
        numbers.append((power, num))
    
    numbers.sort()
    return numbers[k-1][1]


# X07_binary_tree.py
#19 (Easy) 111.二叉树的最小深度
    # 给定一个二叉树, 找出其最小深度。
    # 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
# 需要注意的是, 只有当左右孩子都为空的时候, 才说明遍历到最低点了。如果其中一个孩子不为空则不是最低点
# 递归法(版本一)后序遍历 postorder ???
class Solution:
    def minDepth(self, root):
        return self.getDepth(root)

    def getDepth(self, node):
        if node is None:
            return 0
        leftDepth = self.getDepth(node.left)  # 左
        rightDepth = self.getDepth(node.right)  # 右
        
        # 当一个左子树为空, 右不为空, 这时并不是最低点
        if node.left is None and node.right is not None:
            return 1 + rightDepth
        
        # 当一个右子树为空, 左不为空, 这时并不是最低点
        if node.left is not None and node.right is None:
            return 1 + leftDepth
        
        # The current node's depth is calculated after its children's depths are computed
        result = 1 + min(leftDepth, rightDepth) # 中 
        return result

#21 (Easy) 110.平衡二叉树
    # 给定一个二叉树, 判断它是否是高度平衡的二叉树。
    # 本题中, 一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。
    # 示例 1:
    # 给定二叉树 [3,9,20,null,null,15,7]
    # 返回 true 。
    # 示例 2:
    # 给定二叉树 [1,2,2,3,3,null,null,4,4]
    # 返回 false 。
"""
求深度可以从上到下去查 所以需要**前序遍历 Preorder**(中左右), 而高度只能从下到上去查, 所以只能**后序遍历 Postorder**(左右中)
都知道回溯法其实就是递归, 但是很少人用迭代的方式去实现回溯算法！
因为对于回溯算法已经是非常复杂的递归了, 如果再用迭代的话, 就是自己给自己找麻烦, 效率也并不一定高。
讲了这么多二叉树题目的迭代法, 有的同学会疑惑, 迭代法中究竟什么时候用队列, 什么时候用栈？
如果是模拟前中后序遍历就用栈, 如果是适合层序遍历就用队列, 当然还是其他情况, 那么就是 先用队列试试行不行, 不行就用栈。
"""
# 递归法
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if self.get_height(root) != -1:
            return True
        else:
            return False

    def get_height(self, root: TreeNode) -> int:
        # Base Case
        if not root:
            return 0
        # 左
        if (left_height := self.get_height(root.left)) == -1:
            return -1
        # 右
        if (right_height := self.get_height(root.right)) == -1:
            return -1
        # 中
        if abs(left_height - right_height) > 1:
            return -1
        else:
            return 1 + max(left_height, right_height)
# *** 递归法精简版, 后序遍历
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        return self.get_hight(root) != -1
    def get_hight(self, node):
        if not node:
            return 0
        left = self.get_hight(node.left)
        right = self.get_hight(node.right)
        if left == -1 or right == -1 or abs(left - right) > 1:
            return -1
        return max(left, right) + 1

"""
1. For Boolean Checks (Early Return):
def traversal(node, count):
    if not node.left and not node.right:
        return count == 0  # True if match, False otherwise
    
    if node.left and traversal(node.left, count - node.left.val):
        return True
    if node.right and traversal(node.right, count - node.right.val):
        return True
    
    return False  # No path found


2. For Collecting Paths (No Early Return):
def traversal(node, count, path, result):
    if not node.left and not node.right:
        if count == 0:
            result.append(path.copy())
        return  # No return value needed
    
    if node.left:
        path.append(node.left.val)
        traversal(node.left, count - node.left.val, path, result)
        path.pop()  # Backtrack
    
    if node.right:
        path.append(node.right.val)
        traversal(node.right, count - node.right.val, path, result)
        path.pop()  # Backtrack
"""
#25 (Easy) 112.路径总和
    # 给定一个二叉树和一个目标和, 判断该树中是否存在根节点到叶子节点的路径, 这条路径上所有节点值相加等于目标和。
    # 说明: 叶子节点是指没有子节点的节点。
    # 示例: 给定如下二叉树, 以及目标和 sum = 22, 
    # 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。
# 统一写法112和113
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:

        if not root:
            return False
        
        path = [root.val]
        res = []
        def traversal(node, path):
            if not node.left and not node.right:
                if sum(path) == targetSum:
                    res.append(path[:])
                return

            if node.left:
                path.append(node.left.val)
                traversal(node.left, path)
                path.pop()
            if node.right:
                path.append(node.right.val)
                traversal(node.right, path)
                path.pop()

        traversal(root, path)
        return bool(res)

# *** (版本一) 递归
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if root is None:
            return False
        
        return self.traversal(root, sum - root.val)
    
    def traversal(self, cur: TreeNode, count: int) -> bool:
        if not cur.left and not cur.right and count == 0: # 遇到叶子节点, 并且计数为0
            return True
        if not cur.left and not cur.right: # 遇到叶子节点直接返回
            return False
        
        if cur.left: # 左
            # count -= cur.left.val
            # if self.traversal(cur.left, count): # 递归, 处理节点
            #     return True
            # count += cur.left.val # 回溯, 撤销处理结果
            if self.traversal(cur.left, count-cur.left.val): # 递归, 处理节点
                return True
 
        if cur.right: # 右
            # count -= cur.right.val
            # if self.traversal(cur.right, count): # 递归, 处理节点
            #     return True
            # count += cur.right.val # 回溯, 撤销处理结果
            if self.traversal(cur.right, count-cur.right.val): # 递归, 处理节点
                return True            

        return False
# (版本二) 递归 + 精简
# class Solution:
#     def hasPathSum(self, root: TreeNode, sum: int) -> bool:
#         if not root:
#             return False
#         if not root.left and not root.right and sum == root.val:
#             return True
#         return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)
# *** (版本三) 迭代
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root:
            return False
        # 此时栈里要放的是pair<节点指针, 路径数值>
        st = [(root, root.val)]
        while st:
            node, path_sum = st.pop()
            # 如果该节点是叶子节点了, 同时该节点的路径数值等于sum, 那么就返回true
            if not node.left and not node.right and path_sum == sum:
                return True
            # 左节点, 压进去一个节点的时候, 将该节点的路径数值也记录下来
            if node.left:
                st.append((node.left, path_sum + node.left.val))
            # 右节点, 压进去一个节点的时候, 将该节点的路径数值也记录下来
            if node.right:
                st.append((node.right, path_sum + node.right.val))
        return False


#26 (Medium) 113.路径总和-ii
    # 给定一个二叉树和一个目标和, 找到所有从根节点到叶子节点路径总和等于给定目标和的路径。
    # 说明: 叶子节点是指没有子节点的节点。
    # 示例: 给定如下二叉树, 以及目标和 sum = 22, 
# 统一写法112和113
# separate functions
"""
Potential Issues (Not Bugs, But Optimizations)
Memory Usage:
    path + [node.val] creates a new list at every step, which uses more memory than append/pop backtracking.
    For large trees, this could lead to higher memory consumption.

Redundant Copies:
    path[:] creates another copy when appending to res, which is slightly redundant since path + [node.val] already created a new list.

path.copy(): Explicitly calls the copy() method of the list (introduced in Python 3.3).
path[:]: Uses slice notation to create a copy (works in all Python versions).
"""
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetsum: int) -> List[List[int]]:

        if not root:
            return []
        
        path = [root.val]
        res = []

        self.traversal(root, targetsum-root.val, path, res)
        return res

    def traversal(self, node, count, path, res):
        if not node.left and not node.right:
            if count == 0:
                # res.append(path[:])
                res.append(path.copy())
            return

        if node.left:
            path.append(node.left.val)
            self.traversal(node.left, count-node.left.val, path, res)
            path.pop()
            # self.traversal(node.left, count-node.left.val, path+[node.left.val], res)
        if node.right:
            path.append(node.right.val)
            self.traversal(node.right, count-node.right.val, path, res)
            path.pop()
            # self.traversal(node.right, count-node.right.val, path+[node.right.val], res)
# nested function with targetsum, path and undo
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetsum: int) -> List[List[int]]:

        if not root:
            return []
        
        path = [root.val]
        res = []
        def traversal(node, count, path):
            # print(path)
            if not node.left and not node.right:
                if count == 0:
                    res.append(path[:])
                return

            if node.left:
                # path.append(node.left.val)
                # path.append(node.left.val) modifies path in-place and returns None (since list.append() is a void method).
                # traversal(node.left, count-node.left.val, path.append(node.left.val))
                traversal(node.left, count-node.left.val, path+[node.left.val])
                # path.pop()
                # Your commented-out path.pop() suggests you tried backtracking, but the current code doesn’t undo append operations.
            if node.right:
                traversal(node.right, count-node.right.val, path+[node.right.val])

        traversal(root, targetsum-root.val, path)
        return res
# with targetSum
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetsum: int) -> List[List[int]]:

        if not root:
            return []
        
        path = [root.val]
        res = []
        def traversal(node, count):
            if not node.left and not node.right:
                if count == 0:
                    res.append(path[:])
                return

            if node.left:
                path.append(node.left.val)
                traversal(node.left, count-node.left.val)
                path.pop()
            if node.right:
                path.append(node.right.val)
                traversal(node.right, count-node.right.val)
                path.pop()

        traversal(root, targetsum-root.val)
        return res
# func with nothing
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetsum: int) -> List[List[int]]:

        if not root:
            return []
        
        path = [root.val]
        res = []
        def traversal(node):
            if not node.left and not node.right:
                if sum(path) == targetsum:
                    res.append(path[:])
                return

            if node.left:
                path.append(node.left.val)
                traversal(node.left)
                path.pop()
            if node.right:
                path.append(node.right.val)
                traversal(node.right)
                path.pop()

        traversal(root)
        return res
# func with path
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetsum: int) -> List[List[int]]:

        if not root:
            return []
        
        path = [root.val]
        res = []
        def traversal(node, path):
            if not node.left and not node.right:
                if sum(path) == targetsum:
                    res.append(path[:])
                return

            if node.left:
                path.append(node.left.val)
                traversal(node.left, path)
                path.pop()
            if node.right:
                path.append(node.right.val)
                traversal(node.right, path)
                path.pop()

        traversal(root, path)
        return res

# *** (版本一) 递归
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetsum: int) -> List[List[int]]:
        def traversal(cur_node, remain): 
            if not cur_node.left and not cur_node.right:
                if remain == 0: 
                    result.append(path[:])
                return

            if cur_node.left: 
                path.append(cur_node.left.val)
                traversal(cur_node.left, remain-cur_node.left.val)
                path.pop()

            if cur_node.right: 
                path.append(cur_node.right.val)
                traversal(cur_node.right, remain-cur_node.right.val)
                path.pop()

        result, path = [], []
        if not root: 
            return []
        path.append(root.val)
        traversal(root, targetsum - root.val)
        return result
    
class Solution:
    def __init__(self):
        self.result = []
        self.path = []
    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:
        self.result.clear()
        self.path.clear()
        if not root:
            return self.result
        self.path.append(root.val) # 把根节点放进路径
        self.traversal(root, sum - root.val)
        return self.result
    def traversal(self, cur, count):
        if not cur.left and not cur.right and count == 0: # 遇到了叶子节点且找到了和为sum的路径
            # update final result
            self.result.append(self.path[:])
            return

        if not cur.left and not cur.right: # 遇到叶子节点而没有找到合适的边, 直接返回
            return

        if cur.left: # 左 (空节点不遍历)
            # update path
            self.path.append(cur.left.val)
            # count -= cur.left.val
            # self.traversal(cur.left, count) # 递归
            # count += cur.left.val # 回溯
            self.traversal(cur.left, count-cur.left.val)
            self.path.pop() # 回溯

        if cur.right: #  右 (空节点不遍历)
            # update path
            self.path.append(cur.right.val) 
            # count -= cur.right.val
            # self.traversal(cur.right, count) # 递归
            # count += cur.right.val # 回溯
            self.traversal(cur.right, count-cur.right.val)
            self.path.pop() # 回溯

        return
# (版本二) 递归 + 精简
# class Solution:
#     def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:
        
#         result = []
#         self.traversal(root, targetSum, [], result)
#         return result
#     def traversal(self,node, count, path, result):
#             if not node:
#                 return
#             path.append(node.val)
#             count -= node.val
#             if not node.left and not node.right and count == 0:
#                 result.append(list(path))
#             self.traversal(node.left, count, path, result)
#             self.traversal(node.right, count, path, result)
#             path.pop()
# *** (版本三) 迭代
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:
        if not root:
            return []
        stack = [(root, [root.val])]
        res = []
        while stack:
            node, path = stack.pop()
            if not node.left and not node.right and sum(path) == targetSum:
                res.append(path)
            if node.left:
                stack.append((node.left, path + [node.left.val]))
            if node.right:
                stack.append((node.right, path + [node.right.val]))
        return res


# (Medium) 155. Min Stack
    # Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
    # Implement the MinStack class:
    # MinStack() initializes the stack object.
    # void push(int val) pushes the element val onto the stack.
    # void pop() removes the element on the top of the stack.
    # int top() gets the top element of the stack.
    # int getMin() retrieves the minimum element in the stack.
    # You must implement a solution with O(1) time complexity for each function.
class MinStack:
    def __init__(self):
        self.stack = []

    def push(self, x: int) -> None:

        # If the stack is empty, then the min value
        # must just be the first value we add
        if not self.stack:
            self.stack.append((x, x))
            return

        current_min = self.stack[-1][1]
        self.stack.append((x, min(x, current_min)))

    def pop(self) -> None:
        self.stack.pop()

    def top(self) -> int:
        return self.stack[-1][0]

    def getMin(self) -> int:
        return self.stack[-1][1]

class MinStack:
    def __init__(self) -> None:
        self.stack = []
        self.min_stack = []

    def push(self, x: int) -> None:
        self.stack.append(x)
        if not self.min_stack or x <= self.min_stack[-1]:
            self.min_stack.append(x)

    def pop(self) -> None:
        if self.min_stack[-1] == self.stack[-1]:
            self.min_stack.pop()
        self.stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]

# Design a Queue data structure to get minimum or maximum in O(1) time
from collections import deque as dq

class MinMaxQueue:
    def __init__(self):
        # Queue to store the
        # element to maintain the
        # order of insertion
        self.Q = dq([])
 
        # Doubly ended queue to
        # get the minimum element
        # in the O(1) time
        self.D = dq([])
 
    def enque_element(self, element):
        if (len(self.Q) == 0):
            self.Q.append(element)
            self.D.append(element)
 
        else:
            self.Q.append(element)
            # Pop the elements out
            # until the element at
            # back is greater than
            # current element
            while (self.D and
                   self.D[-1] > element):
                self.D.pop()
 
            self.D.append(element)
 
    def deque_element(self,):
        # Condition when the Minimum
        # element is the element at
        # the front of the Deque
        if (self.Q[0] == self.D[0]):
            self.Q.popleft()
            self.D.popleft()
 
        else:
            self.Q.popleft()
 
    def getMin(self,):
        return self.D[0]
 
# Driver Code
if __name__ == '__main__':
    k = MinMaxQueue()
    example = [1, 2, 4]
 
    # Loop to enque element
    for i in range(3):
        k.enque_element(example[i])
 
    print(k.getMin())
    k.deque_element()
    print(k.getMin())

# Time Complexity Comparison of Data Structures
## Fundamental Operations 
| Operation               | List (Dynamic Array) | Linked List | Stack (List-based) | Dictionary (Hash Table) | Queue (`deque`) |
|-------------------------|----------------------|-------------|--------------------|-------------------------|-----------------|
| **Access by Index**     | `O(1)`               | `O(n)`      | `O(1)`*            | N/A                     | `O(n)`          |
| **Search by Value**     | `O(n)`               | `O(n)`      | `O(n)`             | `O(1)`**                | `O(n)`          |
| **Insert at Start**     | `O(n)`               | `O(1)`      | `O(n)`             | N/A                     | `O(1)`          |
| **Insert at End**       | `O(1)`†              | `O(n)`‡     | `O(1)`             | N/A                     | `O(1)`          |
| **Delete at Start**     | `O(n)`               | `O(1)`      | `O(n)`             | N/A                     | `O(1)`          |
| **Delete at End**       | `O(1)`               | `O(n)`‡     | `O(1)`             | N/A                     | `O(1)`          |

## Specialized Operations
| Operation               | List   | Linked List | Stack  | Dictionary | Queue |
|-------------------------|--------|-------------|--------|------------|-------|
| **Push (Add to Top)**   | `O(1)`†| `O(1)`      | `O(1)` | N/A        | N/A   |
| **Pop (Remove from Top)**| `O(1)`| `O(1)`      | `O(1)` | N/A        | N/A   |
| **Enqueue (Add to Back)**| N/A    | `O(1)`      | N/A    | N/A        | `O(1)`|
| **Dequeue (Remove Front)`| N/A    | `O(1)`      | N/A    | N/A        | `O(1)`|
| **Key Lookup**          | N/A    | N/A         | N/A    | `O(1)`     | N/A   |

### Footnotes:
- * Stack access assumes `peek` operation (same as list access)
- ** Dictionary has `O(1)` average case, `O(n)` worst case (hash collisions)
- † Amortized `O(1)` for lists (occasional resizing needed)
- ‡ Linked lists can achieve `O(1)` end operations with tail pointer

## Python Implementation Notes
- **Lists**: Use for random access and iterations
- **`deque`**: Preferred for queues (faster than list for FIFO)
- **Dicts**: Keys must be hashable (immutable types recommended)
- **Sets**: Similar to dicts but store only keys

## Best Use Cases
| Data Structure       | Strengths                              | Weaknesses                          | Typical Applications               |
|----------------------|----------------------------------------|-------------------------------------|------------------------------------|
| **List (Array)**     | Fast random access, cache-friendly     | Slow insert/delete at start         | General-purpose storage            |
| **Linked List**      | Fast insert/delete at ends             | Slow random access                  | Undo functionality, queues         |
| **Stack**           | Simple LIFO operations                 | Limited access patterns             | Function calls, backtracking       |
| **Dictionary**      | Instant key lookups                    | No order, memory overhead           | Databases, caches                  |
| **Queue (deque)**   | Efficient FIFO operations              | Slow middle access                  | Task scheduling, buffers           |

## Key Differences
### **Memory Layout**
- **Lists**: Contiguous memory (better cache locality)
- **Linked Lists**: Non-contiguous nodes (more flexible)
- **Dictionaries**: Hash table with buckets

### **Operation Tradeoffs**
- **Lists** sacrifice start operations for fast middle access
- **Linked Lists** sacrifice random access for O(1) start operations
- **Dictionaries** optimize for key-based access at expense of ordering

### **Language Implementations**
- Python: `list` (dynamic array), `collections.deque` (queue)
- Java: `ArrayList`, `LinkedList`
- C++: `std::vector`, `std::list`

## When to Use Which?
1. **Need index-based access?** → List
2. **Frequent insertions/deletions at ends?** → Linked List or Deque
3. **Key-value storage?** → Dictionary
4. **LIFO operations?** → Stack
5. **FIFO operations?** → Queue

> **Pro Tip**: In Python, `collections.deque` is often better than `list` for queue operations due to O(1) operations at both ends.
